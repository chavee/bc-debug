'use strict';

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          } });

      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is used to load ACA (Axway Crash Analytics).
 * This allows ACA to be the first module to load on startup.
 */
Promise.resolve().then(function () {return /*#__PURE__*/_interopNamespace(require('com.appcelerator.aca'));}).catch(() => {// No need to notify of ACA load failure.
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* eslint-disable quote-props */

/* globals OS_ANDROID, OS_IOS */
// Add global constants.

Object.defineProperties(commonjsGlobal, {
  'OS_ANDROID': {
    value: true,
    writable: false },

  'OS_IOS': {
    value: false,
    writable: false },

  OS_VERSION_MAJOR: {
    value: Ti.Platform.versionMajor,
    writable: false },

  OS_VERSION_MINOR: {
    value: Ti.Platform.versionMinor,
    writable: false },

  OS_VERSION_PATCH: {
    value: Ti.Platform.versionPatch,
    writable: false } });



// Copyright Node.js contributors. All rights reserved.
const kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
const isBuffer = Symbol.for('titanium.buffer.isBuffer');
const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
let getStructuredStack;

class StackTraceError extends Error {}

StackTraceError.prepareStackTrace = (err, trace) => trace;

StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }

  let stack = getStructuredStack(); // stack is only an array on v8, try to convert manually if string

  if (typeof stack === 'string') {
    const stackFrames = [];
    const lines = stack.split(/\n/);

    for (const line of lines) {
      const lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);

      if (lineInfo) {
        const filename = lineInfo[2].replace('file://', '');
        stackFrames.push({
          getFileName: () => filename });

      }
    }

    stack = stackFrames;
  } // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:


  if (Array.isArray(stack)) {
    for (const frame of stack) {
      const filename = frame.getFileName(); // If a filename does not start with / or contain \,
      // it's likely from Node.js core.

      if (!/^\/|\\/.test(filename)) {
        continue;
      }

      return kNodeModulesRE.test(filename);
    }
  }

  return false;
}
function join$1(output, separator) {
  let str = '';

  if (output.length !== 0) {
    const lastIndex = output.length - 1;

    for (let i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }

    str += output[lastIndex];
  }

  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
const ALL_PROPERTIES$2 = 0;
const ONLY_ENUMERABLE$2 = 2;
const propertyFilter = {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2 };

function getOwnNonIndexProperties(obj, filter) {
  const props = [];
  const keys = filter === ONLY_ENUMERABLE$2 ? Object.keys(obj) : Object.getOwnPropertyNames(obj);

  for (var i = 0; i < keys.length; ++i) {
    const key = keys[i];

    if (!isAllDigits(key)) {
      props.push(key);
    }
  }

  return props;
}

function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }

  for (var i = 0; i < s.length; ++i) {
    const code = s.charCodeAt(i);

    if (code < 48 || code > 57) {
      return false;
    }
  }

  return true;
}

// Copyright Node.js contributors. All rights reserved.
const TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);

function isObject(value) {
  return typeof value === 'object';
}

function isFunction(value) {
  return typeof value === 'function';
}

function checkPrototype(value, name) {
  return Object.prototype.toString.call(value) === `[object ${name}]`;
}

function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }

  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return isObject(value) && checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return isObject(value) && checkPrototype(value, 'ArrayBuffer');
} // Cached to make sure no userland code can tamper with it.

const isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return isFunction(value) && checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return isObject(value) && checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (!isObject(value)) {
    return false;
  }

  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return isObject(value) && checkPrototype(value, 'DataView');
}
function isDate(value) {
  return isObject(value) && checkPrototype(value, 'Date');
} // @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return isObject(value) && checkPrototype(value, 'Generator');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return isObject(value) && checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
} // @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }

  if (!value || !value.constructor) {
    return false;
  }

  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return isObject(value) && checkPrototype(value, 'Number');
}
function isPromise(value) {
  return isObject(value) && checkPrototype(value, 'Promise');
} // @todo isProxy

function isRegExp(value) {
  return isObject(value) && checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return isObject(value) && checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }

  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return isObject(value) && checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return isObject(value) && checkPrototype(value, 'Symbol');
}
function isTypedArray(value) {
  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;

  if (isBuiltInTypedArray) {
    return true;
  }

  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return isObject(value) && checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return isObject(value) && checkPrototype(value, 'WeakSet');
} // @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet });


// Copyright Node.js contributors. All rights reserved.
let error;

function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }

  return error;
}

function assert$1(value, message) {
  if (!value) {
    const ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}

function fail(message) {
  const ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}

assert$1.fail = fail;

// Copyright Node.js contributors. All rights reserved.
const messages = new Map();
const codes = {}; // @todo implement this once needed

class SystemError extends Error {} // Utility function for registering the error codes.


function E(sym, val, def, ...otherClasses) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);

  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }

  if (otherClasses.length !== 0) {
    otherClasses.forEach((clazz) => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }

  codes[sym] = def;
}

function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor(...args) {
      super();
      const message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true });

      addCodeToName(this, super.name, key);
    }

    get code() {
      return key;
    }

    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true });

    }

    toString() {
      return `${this.name} [${key}]: ${this.message}`;
    }};


}

function getMessage(key, args, self) {
  const msg = messages.get(key);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (assert === undefined) {
  	assert = require('./internal/assert');
  }
  */

  if (typeof msg === 'function') {
    assert$1(msg.length <= args.length, // Default options do not count.
    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);
    return msg.apply(self, args);
  }

  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert$1(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);

  if (args.length === 0) {
    return msg;
  }

  args.unshift(msg);
  return format$1.apply(null, args); // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = `${name} [${code}]`; // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions

  err.stack; // Reset the name to the actual name.

  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true });

  } else {
    delete err.name;
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS', // Using a default argument here is important so the argument is not counted
// towards `Function#length`.
(name = undefined) => {
  if (name) {
    return `"${name}" is outside of buffer bounds`;
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INTERNAL_ASSERTION', (message) => {
  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://jira.appcelerator.org\n';
  return message === undefined ? suffix : `${message}\n${suffix}`;
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert$1(typeof name === 'string', '\'name\' must be a string'); // determiner: 'must be' or 'must not be'

  let determiner;

  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;

  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = name.includes('.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
let maxStack_ErrorName;
let maxStack_ErrorMessage;
/**
 * Returns true if `err.name` and `err.message` are equal to engine-specific
 * values indicating max call stack size has been exceeded.
 * "Maximum call stack size exceeded" in V8.
 *
 * @param {Error} err The error to check
 * @returns {boolean}
 */

function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }

      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }

  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}

function oneOf(expected, thing) {
  assert$1(typeof thing === 'string', '`thing` has to be of type string');

  if (Array.isArray(expected)) {
    const len = expected.length;
    assert$1(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map((i) => String(i));

    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class FastBuffer extends Uint8Array {}
/**
 * loop over input, every 2 characters, parse as an int
 * basically each two characters are a "byte" or an 8-bit uint
 * we append them all together to form a single buffer holding all the values
 * @param {string} value string we're encoding in hex
 * @returns {integer[]} array of encoded bytes
 */

function stringToHexBytes(value) {
  const length = value.length / 2;
  const byteArray = [];

  for (let i = 0; i < length; i++) {
    const numericValue = parseInt(value.substr(i * 2, 2), 16);

    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }

  return byteArray;
}

const arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }

    return Reflect.get(target, propKey, receiver);
  },

  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        setAdjustedIndex(target, num, value);
        return true;
      }
    }

    return Reflect.set(target, propKey, value, receiver);
  },

  has(target, key) {
    if (typeof key === 'string') {
      const num = Number(key);

      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }

    return key in target;
  } };

// This is a special Buffer that wraps Ti.Buffer
// as a result it is *much* slower to read/write values
// because we need to go across the JS/Native boundary per-byte!
// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer

class SlowBuffer {
  /**
   * Constructs a new buffer.
   *
   * Primarily used internally in this module together with `newBuffer` to
   * create a new Buffer instance wrapping a Ti.Buffer.
   *
   * Also supports the deprecated Buffer() constructors which are safe
   * to use outside of this module.
   *
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   */
  constructor(tiBuffer, start = 0, length = tiBuffer.length - start) {
    Object.defineProperties(this, {
      byteOffset: {
        value: start },

      length: {
        value: length },

      _tiBuffer: {
        value: tiBuffer } });


  }
  /**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   * @returns {Buffer} wrapped inside a Proxy
   */


  static fromTiBuffer(tiBuffer, start, length) {
    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
  }

  static fromString(value, encoding) {
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }

    encoding = encoding.toLowerCase();

    if (encoding === 'base64') {
      const blob = Ti.Utils.base64decode(value);
      const blobStream = Ti.Stream.createStream({
        source: blob,
        mode: Ti.Stream.MODE_READ });

      const buffer = Ti.Stream.readAll(blobStream);
      blobStream.close();
      return SlowBuffer.fromTiBuffer(buffer);
    }

    if (encoding === 'hex') {
      const bytes = stringToHexBytes(value);
      const length = bytes.length;
      const tiBuffer = Ti.createBuffer({
        length });


      for (let i = 0; i < length; i++) {
        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte
      }

      return SlowBuffer.fromTiBuffer(tiBuffer);
    }

    const tiBuffer = Ti.createBuffer({
      value: value,
      type: getTiCodecCharset(encoding) });

    return SlowBuffer.fromTiBuffer(tiBuffer);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  get buffer() {
    // Get the slice of the array from byteOffset to length
    return Uint8Array.from(this).buffer;
  }

  _slice(offset, length) {
    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);
  }

  _fill(value, offset, end, encoding) {
    const valueType = typeof value;

    if (valueType === 'string') {
      const bufToFillWith = SlowBuffer.fromString(value, encoding);
      const fillBufLength = bufToFillWith.length;

      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      } // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);


      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);

        return this;
      } // multiple byte fill!


      const length = end - offset;

      for (let i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }

      return this;
    } // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();


    this._tiBuffer.fill(value, offset, end);
  }

  getAdjustedIndex(index) {
    return getAdjustedIndex(this, index);
  }

  setAdjustedIndex(index, value) {
    return setAdjustedIndex(this, index, value);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  set(src, offset = 0) {
    const numBytes = src.length; // check src.length + offset doesn't go beyond our length!
    // FIXME: Re-enable
    // checkOffset(this, offset, numBytes);
    // copy src values into this buffer starting at offset

    for (let i = 0; i < numBytes; i++) {
      setAdjustedIndex(this, i + offset, src[i]);
    }
  }
  /**
   * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
   * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
   */


  toTiBuffer() {
    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {
      return this._tiBuffer;
    }

    return this._tiBuffer.clone(this.byteOffset, this.length);
  }}



function getAdjustedIndex(buf, index) {
  if (index < 0) {
    return undefined;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index >= buf._tiBuffer.length) {
      return undefined;
    }

    return buf._tiBuffer[index + buf.byteOffset];
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  return buf[index];
}

function setAdjustedIndex(buf, index, value) {
  if (index < 0) {
    return;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index < buf._tiBuffer.length) {
      buf._tiBuffer[index + buf.byteOffset] = value;
    }

    return;
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  buf[index] = value;
} // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings


const TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);
/**
 * @param {string} encoding desired encoding name
 * @returns {integer} Ti.Codec constant that maps to the encoding
 */

function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

/**
 * This implementation of Buffer uses a Ti.Buffer internally to back it.
 * This is likley an order of magnitude slower than using a variant that extends Uint8Array!
 * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations
 * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot
 * and then add a simple conversion method to turn it into a Ti.Buffer when needed.
 *
 * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.
 * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array
 * the JS engine provides would be *way* faster.
 *
 * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays
 * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting
 * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.
 */
const {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1 } =
propertyFilter;
const VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le']; // Used to cheat for read/writes of doubles

const doubleArray = new Float64Array(1);
const uint8DoubleArray = new Uint8Array(doubleArray.buffer); // Used to cheat to read/write floats

const floatArray = new Float32Array(1);
const uint8FloatArray = new Uint8Array(floatArray.buffer); // Node.js does some very weird stuff here

FastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?

Buffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!
// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me
// How the hell can we make it happy? We really want to extend Uint8Array if we can
// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods

Buffer$1.poolSize = 8192;
/**
 * Constructs a new buffer.
 *
 * Primarily used internally in this module together with `newBuffer` to
 * create a new Buffer instance wrapping a Ti.Buffer.
 *
 * Also supports the deprecated Buffer() constructors which are safe
 * to use outside of this module.
 *
 * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */

function Buffer$1(arg, encodingOrOffset, length) {
  if (arg === undefined) {
    return;
  }

  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
    showFlaggedDeprecation();

    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(`The "string" argument must be of type "string". Received type ${typeof arg}`);
      }

      return Buffer$1.alloc(arg);
    }

    return Buffer$1.from(arg, encodingOrOffset, length);
  } // The slow case - we're wrapping a Ti.Buffer


  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);
}
/**
 * @param {integer[]|Buffer|string} value value we're wrapping
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */


Buffer$1.from = function (value, encodingOrOffset, length) {
  const valueType = typeof value;

  if (valueType === 'string') {
    return fromString(value, encodingOrOffset);
  } else if (valueType === 'object') {
    if (isAnyArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (Array.isArray(value) || value instanceof Uint8Array) {
      return fromArray(value);
    }

    if (Buffer$1.isBuffer(value)) {
      return fromBuffer(value);
    } // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!


    if (value.apiName && value.apiName === 'Ti.Buffer') {
      return SlowBuffer.fromTiBuffer(value);
    }
  }

  throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
};
/**
 * @param {ArrayBuffer} obj ArrayBuffer to wrap
 * @param {number} [byteOffset=0] byte offste to begin
 * @param {number} [length] length to wrap
 * @returns {Buffer}
 */


function fromArrayBuffer(obj, byteOffset, length) {
  // Convert byteOffset to integer
  if (byteOffset === undefined) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;

    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }

  const maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');
  }

  if (length === undefined) {
    length = maxLength;
  } else {
    // Convert length to non-negative integer.
    length = +length;

    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');
      }
    } else {
      length = 0;
    }
  }

  return new FastBuffer(obj, byteOffset, length);
}
/**
 * @param {string} value value to wrap
 * @param {string} [encoding='utf8'] character encoding
 * @returns {Buffer}
 */


function fromString(value, encoding = 'utf8') {
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError(`Unknown encoding: ${encoding}`);
  }

  encoding = encoding.toLowerCase();

  if (encoding === 'base64') {
    const blob = Ti.Utils.base64decode(value);
    return new FastBuffer(blob.toArrayBuffer());
  }

  if (encoding === 'hex') {
    return fromArray(stringToHexBytes(value));
  } // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here


  return fromBuffer(SlowBuffer.fromString(value, encoding));
}
/**
 * @param {integer[]|Uint8Array|array} value values to wrap
 * @returns {Buffer}
 */


function fromArray(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  return new FastBuffer(value);
}
/**
 * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer
 * @param {Buffer} value buffer to copy
 * @returns {Buffer}
 */


function fromBuffer(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  const buffer = Buffer$1.allocUnsafe(length);
  value.copy(buffer, 0, 0, length);
  return buffer;
}

Object.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now

/**
 * 0 is returned if target is the same as buf
 * 1 is returned if target should come before buf when sorted.
 * -1 is returned if target should come after buf when sorted.
 * @param {Buffer} target Buffer to compare against
 * @param {integer} [targetStart=0] index to start in target
 * @param {integer} [targetEnd=target.length] index to end in target
 * @param {integer} [sourceStart=0] index to start in this Buffer
 * @param {integer} [sourceEnd=this.length] index to end in this Buffer
 * @returns {integer}
 */

Buffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {
  if (!Buffer$1.isBuffer(target)) {
    throw new TypeError(`The "target" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }

  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (targetEnd === undefined) {
    targetEnd = target.length;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  } // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength


  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
    throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
  } // Use slices to make the loop easier


  const source = this.slice(sourceStart, sourceEnd);
  const sourceLength = source.length;
  const dest = target.slice(targetStart, targetEnd);
  const destLength = dest.length;
  const length = Math.min(sourceLength, destLength);

  for (let i = 0; i < length; i++) {
    const targetValue = dest.getAdjustedIndex(i);
    const sourceValue = source.getAdjustedIndex(i);

    if (targetValue !== sourceValue) {
      // No match! Return 1 or -1 based on what is greater!
      if (sourceValue < targetValue) {
        return -1;
      }

      return 1;
    }
  } // sort based on length!


  if (sourceLength < destLength) {
    return -1;
  }

  if (sourceLength > destLength) {
    return 1;
  }

  return 0;
};
/**
 * Copies from this to target
 * @param {Buffer} target destination we're copying into
 * @param {integer} [targetStart=0] start index to copy into in destination Buffer
 * @param {integer} [sourceStart=0] start index to copy from within `this`
 * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
 * @returns {integer} number of bytes copied
 */


Buffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {
  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }

  if (sourceStart === sourceEnd) {
    return 0;
  }

  if (target.length === 0 || this.length === 0) {
    return 0;
  } // TODO: check for out of bounds?


  let length = sourceEnd - sourceStart; // Cap length to remaining bytes in target!

  const remaining = target.length - targetStart;

  if (length > remaining) {
    sourceEnd = sourceStart + remaining;
    length = remaining;
  } // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)


  let numBytes = length;
  const sourceLen = this.length - sourceStart;

  if (numBytes > sourceLen) {
    numBytes = sourceLen;
  } // TODO: handle overlap when target === this!
  // TODO: Do we need to take target byteOffset into account here?


  let source = this;

  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);
  }

  target.set(source, targetStart);
  return numBytes;
};
/**
 * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
 * @returns {Iterator}
 */
// TODO: Is this only necessary for SlowBuffer?


Buffer$1.prototype.entries = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const entryIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return entryIterator;
};

Buffer$1.prototype.equals = function (otherBuffer) {
  if (!Buffer$1.isBuffer(otherBuffer)) {
    throw new TypeError('argument must be a Buffer');
  }

  if (otherBuffer === this) {
    return true;
  }

  return this.compare(otherBuffer) === 0;
};
/**
 * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
 * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
 * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
 * @returns {this}
 */


Buffer$1.prototype.fill = function (value, offset, end, encoding) {
  const offsetType = typeof offset;

  if (offsetType === 'undefined') {
    // value supplied
    offset = 0;
    end = this.length;
    encoding = 'utf8';
  } else if (offsetType === 'string') {
    // value, encoding supplied
    encoding = offset;
    offset = 0;
    end = this.length;
  } else if (typeof end === 'string') {
    // value, offset, encoding supplied
    encoding = end;
    end = this.length;
  }

  this._fill(value, offset, end, encoding);

  return this;
};

const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get;
const TypedArrayFill = TypedArrayPrototype.fill;

Buffer$1.prototype._fill = function (value, offset, end, encoding) {
  if (typeof value === 'number') {
    // OOB check
    const byteLen = TypedArrayProto_byteLength.call(this);
    const fillLength = end - offset;

    if (offset > end || fillLength + offset > byteLen) {
      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }

    TypedArrayFill.call(this, value, offset, end);
  } else {
    const bufToFillWith = SlowBuffer.fromString(value, encoding);
    const fillBufLength = bufToFillWith.length;

    if (fillBufLength === 0) {
      throw new Error('no valid fill data');
    }

    if (fillBufLength === 1) {
      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);
      return this;
    } // multiple byte fill!


    const length = end - offset;

    for (let i = 0; i < length; i++) {
      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
      this.setAdjustedIndex(i + offset, fillChar);
    }
  }
};

Buffer$1.prototype.includes = function (value, byteOffset, encoding) {
  return this.indexOf(value, byteOffset, encoding) !== -1;
};
/**
 * @param {string|Buffer|integer} value What to search for
 * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
 * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
 * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
 */


Buffer$1.prototype.indexOf = function (value, byteOffset, encoding) {
  if (this.length === 0) {
    // empty buffer? can't find anything!
    return -1;
  } // if byteOffset is undefined, make it 0


  if (typeof byteOffset === 'undefined') {
    byteOffset = 0;
  } else if (typeof byteOffset === 'string') {
    // if it's a string, that's actually encoding
    encoding = byteOffset;
    byteOffset = 0;
  } // if we don't have an encoding yet, use utf8


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  if (byteOffset < 0) {
    // convert negative indices
    byteOffset = this.length + byteOffset;

    if (byteOffset < 0) {
      // still negative? start at 0
      byteOffset = 0;
    }
  } else if (byteOffset >= this.length) {
    return -1; // can't find past end of buffer!
  }

  if (typeof value === 'number') {
    value &= 0xFF; // clamp to 255
    // This is a simpler case, we have a single byte we need to search for
    // so just loop through and try to find it

    return indexOf(this, value, byteOffset);
  } // coerce a string to a Buffer


  if (typeof value === 'string') {
    value = fromString(value, encoding);
  } // value is now a Buffer...


  const matchLength = value.length;

  if (matchLength === 0) {
    return -1; // never find empty value!
  }

  if (matchLength === 1) {
    // simple case, match one byte!
    return indexOf(this, value[0], byteOffset);
  }

  let currentIndex = byteOffset;
  const thisLength = this.length;

  if (matchLength > thisLength) {
    return -1; // can't match if the value is longer than this Buffer!
  } // FIXME: Can we rewrite this in a less funky way?
  // FIXME: Can stop earlier based on matchLength!


  firstMatch: while (currentIndex < thisLength) {
    // eslint-disable-line no-labels
    // match first byte!
    let firstByteMatch = indexOf(this, value[0], currentIndex);

    if (firstByteMatch === -1) {
      // couldn't even match the very first byte, so no match overall!
      return -1;
    } // ok, we found the first byte, now we need to see if the next consecutive bytes match!


    for (let x = 1; x < matchLength; x++) {
      if (firstByteMatch + x >= thisLength) {
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }

      if (this[firstByteMatch + x] !== value[x]) {
        // didn't match!
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }
    }

    return firstByteMatch; // the rest matched, hurray!
  }

  return -1;
};

Buffer$1.prototype.keys = function () {
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: nextIndex,
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readDoubleBE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[7] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[0] = this[offset++];
  return doubleArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readDoubleLE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[0] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[7] = this[offset++];
  return doubleArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readFloatBE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[3] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[0] = this[offset++];
  return floatArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */


Buffer$1.prototype.readFloatLE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[0] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[3] = this[offset++];
  return floatArray[0];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.readInt8 = function (offset = 0) {
  const unsignedValue = this.readUInt8(offset);
  return unsignedToSigned(unsignedValue, 1);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readInt16BE = function (offset) {
  const unsignedValue = this.readUInt16BE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readInt16LE = function (offset = 0) {
  const unsignedValue = this.readUInt16LE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readInt32BE = function (offset = 0) {
  const unsignedValue = this.readUInt32BE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readInt32LE = function (offset = 0) {
  const unsignedValue = this.readUInt32LE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readIntBE = function (offset, byteLength) {
  const unsignedValue = this.readUIntBE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readIntLE = function (offset, byteLength) {
  const unsignedValue = this.readUIntLE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt8 = function (offset = 0) {
  checkOffset(this, offset, 1);
  return this[offset];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt16BE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte shifted and OR'd with second byte

  return this[offset] << 8 | this[offset + 1];
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt16LE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte OR'd with second byte shifted

  return this[offset] | this[offset + 1] << 8;
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt32BE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]); // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
  // (because bit-wise operators assume a 32-bit number)
};
/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.readUInt32LE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000; // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
};
/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readUIntBE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  // we're doing the same loop as #readUIntLE, just backwards!

  for (let i = byteLength - 1; i >= 0; i--) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.readUIntLE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte

  for (let i = 0; i < byteLength; i++) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */


Buffer$1.prototype.slice = function (start, end) {
  const thisLength = this.length;

  if (typeof start === 'undefined') {
    start = 0;
  } else if (start < 0) {
    start = thisLength + start;

    if (start < 0) {
      // if this is still negative, use 0 (that matches Node)
      start = 0;
    }
  }

  if (typeof end === 'undefined') {
    end = thisLength;
  } else if (end < 0) {
    end = thisLength + end;
  } // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.


  if (end > thisLength) {
    end = thisLength;
  } // What if end is less than start?


  let length = end - start;

  if (length <= 0) {
    length = 0; // return empty view of Buffer! retain byte offset, set length to 0
  } // Wrap the same ArrayBuffer object but specify the start/end to "crop" with


  return this._slice(this.byteOffset + start, length);
};

Buffer$1.prototype._slice = function (offset, length) {
  return new FastBuffer(this.buffer, offset, length);
};
/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */


Buffer$1.prototype.subarray = function (start, end) {
  return this.slice(start, end);
};
/**
 * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap16 = function () {
  const length = this.length;

  if (length % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (let i = 0; i < length; i += 2) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    this.setAdjustedIndex(i, second);
    this.setAdjustedIndex(i + 1, first);
  }

  return this;
};
/**
 * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap32 = function () {
  const length = this.length;

  if (length % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (let i = 0; i < length; i += 4) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    this.setAdjustedIndex(i, fourth);
    this.setAdjustedIndex(i + 1, third);
    this.setAdjustedIndex(i + 2, second);
    this.setAdjustedIndex(i + 3, first);
  }

  return this;
};
/**
 * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
 * @returns {Buffer}
 */


Buffer$1.prototype.swap64 = function () {
  const length = this.length;

  if (length % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (let i = 0; i < length; i += 8) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    const fifth = this.getAdjustedIndex(i + 4);
    const sixth = this.getAdjustedIndex(i + 5);
    const seventh = this.getAdjustedIndex(i + 6);
    const eighth = this.getAdjustedIndex(i + 7);
    this.setAdjustedIndex(i, eighth);
    this.setAdjustedIndex(i + 1, seventh);
    this.setAdjustedIndex(i + 2, sixth);
    this.setAdjustedIndex(i + 3, fifth);
    this.setAdjustedIndex(i + 4, fourth);
    this.setAdjustedIndex(i + 5, third);
    this.setAdjustedIndex(i + 6, second);
    this.setAdjustedIndex(i + 7, first);
  }

  return this;
};
/**
 * @returns {object}
 */


Buffer$1.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    // Take advantage of slice working on "Array-like" objects (just like `arguments`)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
    data: [].slice.call(this) };

};
/**
 * @param {string} [encoding='utf8'] The character encoding to use
 * @param {integer} [start=0] The byte offset to start decoding at
 * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
 * @returns {string}
 */


Buffer$1.prototype.toString = function (encoding, start, end) {
  // fast case of no args
  if (arguments.length === 0) {
    return this.toTiBuffer().toString();
  }

  const length = this.length;

  if (start >= length) {
    return ''; // start is past end of buffer, return empty string
  }

  if (start < 0 || typeof start !== 'number') {
    start = 0;
  }

  if (end > length || typeof end !== 'number') {
    // no end specified, or past end of buffer, use length of buffer
    end = length;
  } // else keep end as passed in


  if (end <= start) {
    return ''; // if end is before start return empty string
  } // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?


  if (start !== 0 || end !== length) {
    return this.slice(start, end).toString(encoding);
  } // base case, start is 0, end is length


  if (encoding === undefined) {
    encoding = 'utf8';
  } else {
    encoding = encoding.toLowerCase(); // Throw if bad encoding!

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
  }

  if (encoding === 'utf8' || encoding === 'utf-8') {
    return this.toTiBuffer().toString(); // we return utf-8 by default natively
  }

  if (encoding === 'base64') {
    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();
  }

  if (encoding === 'hex') {
    return this.hexSlice(0, length);
  }

  if (encoding === 'latin1' || encoding === 'binary') {
    let latin1String = '';

    for (let i = 0; i < length; i++) {
      // each one is a "byte"
      latin1String += String.fromCharCode(this.getAdjustedIndex(i));
    }

    return latin1String;
  }

  if (encoding === 'ascii') {
    let ascii = '';

    for (let i = 0; i < length; i++) {
      // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);
    }

    return ascii;
  } // UCS2/UTF16


  return this.ucs2Slice(0, length);
};

Buffer$1.prototype.getAdjustedIndex = function (index) {
  return this[index];
};

Buffer$1.prototype.setAdjustedIndex = function (index, value) {
  return this[index] = value;
};

Buffer$1.prototype.hexSlice = function (start, end) {
  let hexStr = '';

  for (let i = start; i < end; i++) {
    // each one is a "byte"
    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);
    hex = hex.length === 1 ? '0' + hex : hex;
    hexStr += hex;
  }

  return hexStr;
};

Buffer$1.prototype.ucs2Slice = function (start, end) {
  let out = '';
  let i = start;

  while (i < end) {
    // utf-16/ucs-2 is 2-bytes per character
    const byte1 = this.getAdjustedIndex(i++);
    const byte2 = this.getAdjustedIndex(i++);
    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes

    out += String.fromCodePoint(code_unit);
  }

  return out;
};
/**
 * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
 * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
 */


Buffer$1.prototype.toTiBuffer = function () {
  const tiBuffer = Ti.createBuffer({
    length: this.length });

  copyBuffer(this, tiBuffer, 0, this.length);
  return tiBuffer;
};
/**
 * @param {Buffer} src source Buffer we're copying from
 * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into
 * @param {integer} offset start offset we're copying to in destination
 * @param {integer} length number of bytes to copy
 * @returns {integer} actual number of bytes copied
 */


function copyBuffer(src, dest, offset, length) {
  const srcLength = src.length;
  const destLength = dest.length;
  let i = 0;

  for (; i < length; i++) {
    const destIndex = i + offset; // are we trying to write past end of destination? Or read past end of source? Stop!

    if (destIndex >= destLength || i >= srcLength) {
      break;
    }

    dest[destIndex] = src[i];
  }

  return i;
}
/**
 * Creates and returns an iterator for buf values (bytes)
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?


Buffer$1.prototype.values = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: buffer.getAdjustedIndex(nextIndex),
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
 * Called when buffer is used in a for..of loop. Delegates to #values()
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?


Buffer$1.prototype[Symbol.iterator] = function () {
  return this.values();
};
/**
 * Writes string to buf at offset according to the character encoding in encoding.
 * The length parameter is the number of bytes to write. If buf did not contain enough space to
 * fit the entire string, only part of string will be written. However, partially encoded
 * characters will not be written.
 * @param {string} string String to write to `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write string
 * @param {integer} [length=buf.length - offset] Number of bytes to write
 * @param {string} [encoding='utf8'] The character encoding of string
 * @returns {integer}
 */


Buffer$1.prototype.write = function (string, offset, length, encoding) {
  if (typeof offset === 'string') {
    encoding = offset;
    offset = 0;
    length = this.length;
  } else if (typeof length === 'string') {
    encoding = length;
    length = this.length - offset;
  } else {
    // we cap `length` at the length of our buffer
    const remaining = this.length - offset;

    if (length > remaining) {
      length = remaining;
    }
  }

  encoding = encoding || 'utf8'; // so we need to convert `remaining` bytes of our string into a byte array/buffer

  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?
  // then stick that into our buffer starting at `offset`!

  return src.copy(this, offset, 0, length);
};

Buffer$1.prototype.writeDoubleBE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeDoubleLE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeFloatBE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  return offset; // at this point, we should have already added 4 to offset
};

Buffer$1.prototype.writeFloatLE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  return offset; // at this point, we should have already added 4 to offset
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, -128, 127);

  if (value >= 0) {
    // just write it normally
    this.setAdjustedIndex(offset, value);
  } else {
    // convert from signed to 2's complement bits
    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one
  }

  return offset + 1;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte

  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte

  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xFF);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0x100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, 0, 255);
  this.setAdjustedIndex(offset, value);
  return offset + 1;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value >>> 8);
  this.setAdjustedIndex(offset + 1, value & 0xff);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xff);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */


Buffer$1.prototype.writeUInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */


Buffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
}; // TODO: Implement remaining instance methods:
// buf.lastIndexOf(value[, byteOffset][, encoding])
// buf.readBigInt64BE([offset])
// buf.readBigInt64LE([offset])
// buf.readBigUInt64BE([offset])
// buf.readBigUInt64LE([offset])
// buf.writeBigInt64BE(value[, offset])
// buf.writeBigInt64LE(value[, offset])
// buf.writeBigUInt64BE(value[, offset])
// buf.writeBigUInt64LE(value[, offset])
// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because
// going back and forth across the bridge for every byte is *very* expensive
// Ideally we should have a "SlowBuffer" that is used when we explicitly wrap a Ti.Buffer
// So that writes are passed through. Otherwise we should avoid using one at all costs
// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?
// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?


Buffer$1.allocUnsafe = function (length) {
  return new FastBuffer(length);
};

Buffer$1.allocUnsafeSlow = function (length) {
  return Buffer$1.allocUnsafe(length);
};

Buffer$1.alloc = function (length, fill = 0, encoding = 'utf8') {
  const buf = Buffer$1.allocUnsafe(length);

  if (fill !== 0) {
    buf.fill(fill, encoding);
  }

  return buf;
};
/**
 * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
 * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
 * @returns {integer}
 */


Buffer$1.byteLength = function (string, encoding = 'utf8') {
  if (typeof string !== 'string') {
    if (Buffer$1.isBuffer(string)) {
      return string.length; // return Buffer's length
    }

    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
  }

  let length = string.length;

  switch (encoding.toLowerCase()) {
    case 'utf8':
    case 'utf-8':
      return utf8ByteLength(string);

    case 'latin1':
    case 'binary':
    case 'ascii':
      return length;

    case 'ucs-2':
    case 'ucs2':
    case 'utf16le':
    case 'utf16-le':
      return 2 * length;

    case 'hex':
      return length / 2;

    case 'base64':
      // Subtract up to two padding chars from end of string!
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      return Math.floor(length * 3 / 4);
    // drop fractional value
  }

  return utf8ByteLength(string);
};

Buffer$1.compare = function (buf1, buf2) {
  if (!Buffer$1.isBuffer(buf1)) {
    throw new TypeError(`The "buf1" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  } // TODO: Wrap UInt8Array args in buffers?


  return buf1.compare(buf2);
};
/**
 * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
 * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
 * @returns {Buffer}
 */


Buffer$1.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new TypeError('list argument must be an Array');
  }

  if (list.length === 0) {
    return new FastBuffer(); // one empty Buffer!
  } // allocate one Buffer of `totalLength`? Cap at totalLength?


  if (totalLength === undefined) {
    totalLength = 0; // generate the total length from each buffer's length?

    for (let i = 0; i < list.length; i++) {
      totalLength += list[i].length;
    }
  }

  const result = Buffer$1.allocUnsafe(totalLength);
  let position = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(result, position);
    position += buf.length;

    if (position >= totalLength) {
      break;
    }
  }

  return result;
};
/**
 * @param {string} encoding possible encoding name
 * @returns {boolean}
 */


Buffer$1.isEncoding = function (encoding) {
  if (typeof encoding !== 'string') {
    return false;
  }

  return VALID_ENCODINGS.includes(encoding.toLowerCase());
};
/**
 * @param {*} obj possible Buffer instance
 * @returns {boolean}
 */


Buffer$1.isBuffer = function (obj) {
  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);
};

let INSPECT_MAX_BYTES = 50; // Override how buffers are presented by util.inspect().

Buffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {
  const max = INSPECT_MAX_BYTES;
  const actualMax = Math.min(max, this.length);
  const remaining = this.length - max;
  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  } // Inspect special properties as well, if possible.


  if (ctx) {
    let extras = false;
    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
      extras = true;
      obj[key] = this[key];
      return obj;
    }, Object.create(null));

    if (extras) {
      if (this.length !== 0) {
        str += ', ';
      } // '[Object: null prototype] {'.length === 26
      // This is guarded with a test.


      str += inspect(obj, { ...ctx,
        breakLength: Infinity,
        compact: true }).
      slice(27, -2);
    }
  }

  return `<${this.constructor.name} ${str}>`;
};

Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol]; // HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method

const ArrayBufferIsView = ArrayBuffer.isView;

ArrayBuffer.isView = function (thing) {
  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;
};

Object.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);
Object.setPrototypeOf(SlowBuffer, Buffer$1);
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799 } };


/**
 * Searches a Buffer for the index of a single byte.
 * @param {Buffer} buffer buffer to search
 * @param {integer} singleByte byte we're looking for
 * @param {integer} offset start offset we search at
 * @returns {integer}
 */

function indexOf(buffer, singleByte, offset) {
  const length = buffer.length;

  for (let i = offset; i < length; i++) {
    if (buffer.getAdjustedIndex(i) === singleByte) {
      return i;
    }
  }

  return -1;
}
/**
 * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
 * It's possible we may be able to use them when byteLength < 4 if that's faster.
 *
 * @param {integer} unsignedValue value before converting back to signed
 * @param {integer} byteLength number of bytes
 * @returns {integer} the signed value that is represented by the unsigned value's bytes
 */


function unsignedToSigned(unsignedValue, byteLength) {
  const bitLength = byteLength * 8;
  const maxPositiveValue = Math.pow(2, bitLength - 1);

  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }

  const maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}
/**
 * @param {string} string utf-8 string
 * @returns {integer}
 */


function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  const buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8 });

  const length = buf.length;
  buf.release(); // release the buffer since we just needed the length

  return length;
}
/**
 * Throws a RangeError if offset is out of bounds
 * @param {Buffer} buffer buffer we're operating on
 * @param {integer} offset user supplied offset
 * @param {integer} byteLength number of bytes needed in range
 * @throws {RangeError}
 */


function checkOffset(buffer, offset, byteLength) {
  const endOffset = buffer.length - byteLength;

  if (offset < 0 || offset > endOffset) {
    throw new RangeError(`The value of "offset" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);
  }
}
/**
 * @param {integer} value user-supplied value
 * @param {integer} min minimum valid value
 * @param {integer} max maximum valid value
 * @throws {RangeError}
 */


function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError(`The value of "value" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);
  }
}

let bufferWarningAlreadyEmitted = false;
let nodeModulesCheckCounter = 0;
const bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';

function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }

  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

// Copyright Node.js contributors. All rights reserved.
const {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE } =
propertyFilter;
const BooleanPrototype = Boolean.prototype;
const DatePrototype = Date.prototype;
const ErrorPrototype = Error.prototype;
const NumberPrototype = Number.prototype;
const MapPrototype = Map.prototype;
const RegExpPrototype = RegExp.prototype;
const StringPrototype = String.prototype;
const SetPrototype = Set.prototype;
const SymbolPrototype = Symbol.prototype;
const isIos = ['ipad', 'iphone'].includes("android");
const {
  ERR_INVALID_ARG_TYPE } =
codes;
const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
let hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
const builtInObjects = new Set(Object.getOwnPropertyNames(global).filter((e) => /^([A-Z][a-z]+)+$/.test(e)));
const inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false });

const kObjectType = 0;
const kArrayType = 1;
const kArrayExtrasType = 2;
/* eslint-disable no-control-regex */

const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const kMinLineLength = 16; // Constants to map the iterator state.

const kWeak = 0;
const kIterator = 1;
const kMapEntries = 2; // Escaped special characters. Use empty strings to fill up unused entries.

/* eslint-disable quotes */

const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  const obj = {
    stylize: ctx.stylize };


  for (const key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }

  if (ctx.userOptions === undefined) {
    return obj;
  }

  return { ...obj,
    ...ctx.userOptions };

}
/**
 * Echos the value of any input. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {any} value The value to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @return {string} The string representation of `value`
 */


function inspect(value, opts) {
  // Default options
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters };


  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }

      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    } // Set user-specified options


    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);

      for (const key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }

  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },

  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    Object.assign(inspectDefaultOptions, options);
  } });

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39] });
// Don't use 'blue' not visible on cmd.exe

inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline' });


function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }

  if (quotes === -2) {
    return `\`${str}\``;
  }

  return `'${str}'`;
}

const escapeFn = (str) => meta[str.charCodeAt(0)]; // Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.


function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39; // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes

  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }

    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  } // Some magic numbers that worked out fine while benchmarking with v8 6.0


  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }

  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }

  let result = '';
  let last = 0;
  const lastIndex = str.length;

  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);

    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }

      last = i + 1;
    }
  }

  if (last !== lastIndex) {
    result += str.slice(last);
  }

  return addQuotes(result, singleQuote);
}

function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];

  if (style !== undefined) {
    const color = inspect.colors[style];
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
  }

  return str;
}

function stylizeNoColor(str) {
  return str;
} // Return a new empty array to push in the results of the default formatter.


function getEmptyFormatArray() {
  return [];
}

function getConstructorName(obj, _ctx) {
  let firstProto; // const tmp = obj;

  while (obj) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');

    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }

    obj = Object.getPrototypeOf(obj);

    if (firstProto === undefined) {
      firstProto = obj;
    }
  }

  if (firstProto === null) {
    return null;
  }
  /*
   @todo this calls into native, can we replace this somehow?
  return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
  	...ctx,
  	customInspect: false
  })}>`;
  */


  return null;
}

function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return `[${fallback}: null prototype] [${tag}] `;
    }

    return `[${fallback}: null prototype] `;
  }

  if (tag !== '' && constructor !== tag) {
    return `${constructor} [${tag}] `;
  }

  return `${constructor} `;
} // Look up the keys of the object.


function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);

  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);

    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?

      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }

    if (symbols.length !== 0) {
      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));
    }
  }

  return keys;
}

function getCtxStyle(value, constructor, tag) {
  let fallback = '';

  if (constructor === null) {
    fallback = 'Object';
  }

  return getPrefix(constructor, tag, fallback);
}

function findTypedConstructor(value) {
  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}

let lazyNullPrototypeCache; // Creates a subclass and name
// the constructor as `${clazz} : null prototype`

function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    const cachedClass = lazyNullPrototypeCache.get(clazz);

    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }

  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }}



  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: `[${name}: null prototype]` });

  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}

function noPrototypeIterator(ctx, value, recurseTimes) {
  let newVal;

  if (isSet(value)) {
    const clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    const clazz = clazzWithNullPrototype(Map, 'Map');
    newVal = new clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    const clazz = clazzWithNullPrototype(Array, 'Array');
    newVal = new clazz(value.length);
  } else if (isTypedArray(value)) {
    const constructor = findTypedConstructor(value);
    const clazz = clazzWithNullPrototype(constructor, constructor.name);
    newVal = new clazz(value);
  }

  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}

function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }

  if (value === null) {
    return ctx.stylize('null', 'null');
  } // Memorize the context for custom inspection on proxies.


  const context = value;
  /*
  @fixme check for proxies
  // Always check for proxies to prevent side effects and to prevent triggering
  // any proxy handlers.
  const proxy = getProxyDetails(value);
  if (proxy !== undefined) {
  	if (ctx.showProxy) {
  		return formatProxy(ctx, proxy, recurseTimes);
  	}
  	value = proxy[0];
  }
  */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.

  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];

    if (typeof maybeCustom === 'function' // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx)); // If the custom inspection method returned `this`, don't go into
      // infinite recursion.

      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }

        return ret.replace(/\n/g, `\n${' '.repeat(ctx.indentationLvl)}`);
      }
    }
  } // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.


  if (ctx.seen.includes(value)) {
    let index = 1;

    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);

      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }

    return ctx.stylize(`[Circular *${index}]`, 'special');
  }

  return formatRaw(ctx, value, recurseTimes, typedArray);
}

function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  const constructor = getConstructorName(value);
  let tag = value[Symbol.toStringTag]; // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.

  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {
    tag = '';
  }

  let base = '';
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType; // Iterators and the rest are split to reduce checks.

  if (value[Symbol.iterator]) {
    noIterator = false;

    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter); // Only set the constructor for non ordinary ("Array [...]") arrays.

      const prefix = getPrefix(constructor, tag, 'Array');
      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0) {
        return `${braces[0]}]`;
      }

      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Set');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Map');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatMap;
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);
      braces = [`${prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }

      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }

  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];

    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
      }

      if (keys.length === 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);

      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);
      const prefix = getPrefix(constructor, tag, 'RegExp');

      if (prefix !== 'RegExp ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);
      const prefix = getPrefix(constructor, tag, 'Date');

      if (prefix !== 'Date ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);

      if (keys.length === 0) {
        return base;
      } else if (isIos) {
        const nativeErrorProps = ['line', 'column', 'sourceURL'];

        if (keys.every((key) => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';
      const prefix = getPrefix(constructor, tag, arrayType);

      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }

      braces[0] = `${prefix}{`;
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`; // .buffer goes last, it's not a primitive like the others.

      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
       * @fixme how to do isModuleNamespaceObject?
      } else if (isModuleNamespaceObject(value)) {
      	braces[0] = `[${tag}] {`;
      	formatter = formatNamespaceObject;
      */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);

      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);

        if (specialIterator) {
          return specialIterator;
        }
      }

      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator; // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return `${getCtxStyle(value, constructor, tag)}{}`;
        }

        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
      }
    }
  }

  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);

    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }

    return ctx.stylize(constructorName, 'special');
  }

  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;

  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);

    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }

  if (ctx.circular !== undefined) {
    const index = ctx.circular.get(value);

    if (index !== undefined) {
      const reference = ctx.stylize(`<ref *${index}>`, 'special'); // Add reference always to the very beginning of the output.

      if (ctx.compact !== true) {
        base = base === '' ? reference : `${reference} ${base}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }

  ctx.seen.pop();

  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? undefined : ctx.sorted;

    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }

  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength; // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.

  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }

  return res;
}

function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== '') {
      tag += '] [';
    }

    tag += `${type} Iterator`;
  }

  return [`[${tag}] {`, '}'];
}

function getBoxedBase(value, ctx, keys, constructor, tag) {
  let fn;
  let type;

  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String'; // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such

    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }

  let base = `[${type}`;

  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += ` (${constructor})`;
    }
  }

  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;

  if (tag !== '' && tag !== constructor) {
    base += ` [${tag}]`;
  }

  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }

  return ctx.stylize(base, type.toLowerCase());
}

function getFunctionBase(value, constructor, tag) {
  let type = 'Function';

  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }

  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }

  let base = `[${type}`;

  if (constructor === null) {
    base += ' (null prototype)';
  }

  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += `: ${value.name}`;
  }

  base += ']';

  if (constructor !== type && constructor !== null) {
    base += ` ${constructor}`;
  }

  if (tag !== '' && constructor !== tag) {
    base += ` [${tag}]`;
  }

  return base;
}

function formatError(err, constructor, tag, ctx) {
  let stack = err.stack || ErrorPrototype.toString.call(err); // try to normalize JavaScriptCore stack to match v8

  if (isIos) {
    const lines = stack.split('\n');
    stack = `${err.name}: ${err.message}`;

    if (lines.length > 0) {
      stack += lines.map((stackLine) => {
        const atSymbolIndex = stackLine.indexOf('@');
        const source = stackLine.slice(atSymbolIndex + 1);
        const sourcePattern = /(.*):(\d+):(\d+)/;
        let symbolName = 'unknown';

        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }

        const sourceMatch = source.match(sourcePattern);

        if (sourceMatch) {
          let filePath = sourceMatch[1];
          const lineNumber = sourceMatch[2];
          const column = sourceMatch[3];

          if (filePath.startsWith('file:')) {
            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');
          }

          return `\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;
        } else {
          return `\n    at ${symbolName} (${source})`;
        }
      }).join('');
    }
  } // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.


  const name = err.name || 'Error';
  let len = name.length;

  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    let fallback = 'Error';

    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }

    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);

    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  } // Ignore the error message if it's contained in the stack.


  let pos = err.message && stack.indexOf(err.message) || -1;

  if (pos !== -1) {
    pos += err.message.length;
  } // Wrap the error in brackets in case it has no stack trace.


  let stackStart = stack.indexOf('\n    at', pos);

  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split('\n');

    for (const line of lines) {
      // This adds underscores to all node_modules to quickly identify them.
      let nodeModule;
      newStack += '\n';
      let pos = 0;

      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        pos = nodeModule.index + nodeModule[0].length;
      }

      newStack += pos === 0 ? line : line.slice(pos);
    }

    stack = newStack;
  } // The message and the stack have to be indented as well!


  if (ctx.indentationLvl !== 0) {
    const indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `\n${indentation}`);
  }

  return stack;
}

function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}

function formatProperty(ctx, value, recurseTimes, key, type) {
  let name, str;
  let extra = ' ';
  const desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true };


  if (desc.value !== undefined) {
    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);

    if (diff === 3) {
      const len = ctx.colors ? removeColors(str).length : str.length;

      if (ctx.breakLength < len) {
        extra = `\n${' '.repeat(ctx.indentationLvl)}`;
      }
    }

    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    const s = ctx.stylize;
    const sp = 'special';

    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        const tmp = value[key];
        ctx.indentationLvl += 2;

        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
        } else if (typeof tmp === 'object') {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
        }

        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }

  if (type === kArrayType) {
    return str;
  }

  if (typeof key === 'symbol') {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, 'symbol')}]`;
  } else if (desc.enumerable === false) {
    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }

  return `${name}:${extra}${str}`;
}

function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;

  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }

  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.

  const dataLen = new Array(outputLength); // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.

  for (; i < outputLength; i++) {
    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;

    if (maxLength < len) {
      maxLength = len;
    }
  } // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.


  const actualMax = maxLength + separatorSpace; // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.

  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1); // Dynamically check how many columns seem possible.

    const columns = Math.min( // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4, // Limit the columns to a maximum of fifteen.
    15); // Return with the original output if no grouping should happen.

    if (columns <= 1) {
      return output;
    }

    const tmp = [];
    const maxLineLength = [];

    for (let i = 0; i < columns; i++) {
      let lineMaxLength = 0;

      for (let j = i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }

      lineMaxLength += separatorSpace;
      maxLineLength[i] = lineMaxLength;
    }

    let order = 'padStart';

    if (value !== undefined) {
      for (let i = 0; i < output.length; i++) {
        if (typeof value[i] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    } // Each iteration creates a single line of grouped entries.


    for (let i = 0; i < outputLength; i += columns) {
      // The last lines may contain less entries than columns.
      const max = Math.min(i + columns, outputLength);
      let str = '';
      let j = i;

      for (; j < max - 1; j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
        str += `${output[j]}, `[order](padding, ' ');
      }

      if (order === 'padStart') {
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, ' ');
      } else {
        str += output[j];
      }

      tmp.push(str);
    }

    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }

    output = tmp;
  }

  return output;
}

function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');
  }

  throw err;
}

function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');
}

function formatBigInt(fn, value) {
  return fn(`${value}n`, 'bigint');
}

function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map((line) => fn(strEscape(line), 'string')).join(` +\n${' '.repeat(ctx.indentationLvl + 2)}`);
    }

    return fn(strEscape(value), 'string');
  }

  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
  if (typeof value === 'bigint') {
  	return formatBigInt(fn, value);
  }
  */


  if (typeof value === 'boolean') {
    return fn(`${value}`, 'boolean');
  }

  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  } // es6 symbol primitive


  return fn(SymbolPrototype.toString.call(value), 'symbol');
} // The array is sparse and/or has extra keys


function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;

  for (; i < keys.length && output.length < maxLength; i++) {
    const key = keys[i];
    const tmp = +key; // Arrays can only have up to 2^32 - 1 entries

    if (tmp > 2 ** 32 - 2) {
      break;
    }

    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }

      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? 's' : '';
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;

      if (output.length === maxLength) {
        break;
      }
    }

    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }

  const remaining = value.length - index;

  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? 's' : '';
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatArrayBuffer(ctx, value) {
  const buffer = new Uint8Array(value);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (hexSlice === undefined) {
  	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
  }
  */

  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  const remaining = buffer.length - ctx.maxArrayLength;

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }

  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
}

function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];

  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }

    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatTypedArray(ctx, value, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;

  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }

  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;
  }

  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;

    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      output.push(`[${key}]: ${str}`);
    }

    ctx.indentationLvl -= 2;
  }

  return output;
}

function formatSet(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }

  ctx.indentationLvl -= 2; // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatMap(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const [k, v] of value) {
    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }

  ctx.indentationLvl -= 2; // See comment in formatSet

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  let output = new Array(maxLength);
  ctx.indentationLvl += 2;

  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }

  ctx.indentationLvl -= 2;

  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }

  const remaining = entries.length - maxLength;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0); // Entries exist as [key1, val1, key2, val2, ...]

  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;

  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    } // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.


    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }

  ctx.indentationLvl -= 2;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}

function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  const entries = [];
  let isKeyValue = false;
  let result = value.next();

  while (!result.done) {
    const currentEntry = result.value;
    entries.push(currentEntry);

    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }

    result = value.next();
  }

  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }

  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}

function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  let totalLength = output.length + start;

  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }

  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }

    if (totalLength > ctx.breakLength) {
      return false;
    }
  } // Do not line up properties on the same line if `base` contains line breaks.


  return base === '' || !base.includes('\n');
}

function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      const entries = output.length; // Group array elements together if the array contains at least six
      // separate entries.

      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      } // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.


      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;

        if (isBelowBreakLength(ctx, output, start, base)) {
          return `${base ? `${base} ` : ''}${braces[0]} ${join$1(output, ', ')} ${braces[1]}`;
        }
      }
    } // Line up each entry on an individual line.


    const indentation = `\n${' '.repeat(ctx.indentationLvl)}`;
    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join$1(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  } // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.


  if (isBelowBreakLength(ctx, output, 0, base)) {
    return `${braces[0]}${base ? ` ${base}` : ''} ${join$1(output, ', ')} ` + braces[1];
  }

  const indentation = ' '.repeat(ctx.indentationLvl); // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.

  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `; // Line up each entry on an individual line.

  return `${braces[0]}${ln}${join$1(output, `,\n${indentation}  `)} ${braces[1]}`;
}

function format$1(...args) {
  return formatWithOptions(undefined, ...args);
}

const firstErrorLine = (error) => error.message.split('\n')[0];

let CIRCULAR_ERROR_MESSAGE;

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }

    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
}
/* eslint-disable max-depth */


function formatWithOptions(inspectOptions, ...args) {
  const first = args[0];
  let a = 0;
  let str = '';
  let join = '';

  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }

    let tempStr;
    let lastPos = 0;

    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        const nextChar = first.charCodeAt(++i);

        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              const tempArg = args[++a];

              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                } else if (typeof tempArg === 'bigint') {
                	tempStr = `${tempArg}n`;
                */
              } else {
                let constr;

                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString') // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, { ...inspectOptions,
                    compact: 3,
                    colors: false,
                    depth: 0 });

                }
              }

              break;

            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;

            case 100:
              // 'd'
              const tempNum = args[++a];
              /*
              if (typeof tempNum === 'bigint') {
              	tempStr = `${tempNum}n`;
              } else
              */

              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }

              break;

            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;

            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], { ...inspectOptions,
                  showHidden: true,
                  showProxy: true,
                  depth: 4 });

                break;
              }

            case 105:
              // 'i'
              const tempInteger = args[++a];
              /*
              if (typeof tempInteger === 'bigint') {
              	tempStr = `${tempInteger}n`;
              } else */

              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }

              break;

            case 102:
              // 'f'
              const tempFloat = args[++a];

              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }

              break;

            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;

            default:
              // Any other character is not a correct placeholder
              continue;}


          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }

          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }

    if (lastPos !== 0) {
      a++;
      join = ' ';

      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }

  while (a < args.length) {
    const value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }

  return str;
}
/* eslint-enable max-depth */

function noop$1() {}

function logTime(self, label, logData) {
  label = `${label}`;

  const startTime = self._times.get(label);

  if (!startTime) {
    process.emitWarning(`Label "${label}" does not exist`);
    return true;
  }

  const duration = Date.now() - startTime;

  if (logData) {
    self.log(`${label}: ${duration}ms`, ...logData);
  } else {
    self.log(`${label}: ${duration}ms`);
  }

  return false;
}

const kColorInspectOptions = {
  colors: true };

const kNoColorInspectOptions = {};
let tableWarned; // boolean flag for one-time warning about console.table not being implemented
// Make a function that can serve as the callback passed to `stream.write()`.

function createWriteErrorHandler(stream) {
  return (err) => {
    // This conditional evaluates to true if and only if there was an error
    // that was not already emitted (which happens when the _write callback
    // is invoked asynchronously).
    if (err !== null && !stream._writableState.errorEmitted) {
      // If there was an error, it will be emitted on `stream` as
      // an `error` event. Adding a `once` listener will keep that error
      // from becoming an uncaught exception, but since the handler is
      // removed after the event, non-console.* writes won't be affected.
      // we are only adding noop if there is no one else listening for 'error'
      if (stream.listenerCount('error') === 0) {
        stream.once('error', noop$1);
      }
    }
  };
}

class Console {
  constructor(options, stderr, ignoreErrors) {
    if (options && options.apiName === 'Ti.API') {
      // Passing in Ti.API module where we retain log levels
      this._apiModule = options;
    } else {
      // Node.JS streams
      if (!options || typeof options.write === 'function') {
        // no args, or first arg is a stream
        options = {
          stdout: options,
          stderr,
          ignoreErrors };

      }

      this._stdout = options.stdout; // TODO: enforce has write function?

      this._stderr = options.stderr || this._stdout;
      this._ignoreErrors = options.ignoreErrors !== false;

      if (this._ignoreErrors) {
        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);
        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);
      }

      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'

      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'
    }

    this._times = new Map();
    this._counts = new Map();
    this._groupIndent = '';
  }

  _writeToConsole(level, string) {
    if (this._groupIndent.length !== 0) {
      if (string.includes('\n')) {
        string = string.replace(/\n/g, `\n${this._groupIndent}`);
      }

      string = this._groupIndent + string;
    } // Support wrapping Ti.API (which retains log level)


    if (this._apiModule) {
      this._apiModule[level](string);
    } else {
      // Support Node.JS streams like stdout/stderr which don't have log levels
      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';
      const stream = useStdErr ? this._stderr : this._stdout;

      if (this._ignoreErrors === false) {
        return stream.write(string);
      } // There may be an error occurring synchronously (e.g. for files or TTYs
      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so
      // handle both situations.


      try {
        // Add and later remove a noop error handler to catch synchronous errors.
        if (stream.listenerCount('error') === 0) {
          stream.once('error', noop$1);
        }

        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;
        stream.write(string, errorHandler);
      } catch (e) {
        // Console is a debugging utility, so it swallowing errors is not desirable
        // even in edge cases such as low stack space.
        if (isStackOverflowError(e)) {
          throw e;
        } // Sorry, there's no proper way to pass along the error here.

      } finally {
        stream.removeListener && stream.removeListener('error', noop$1);
      }
    }
  }

  info(...args) {
    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));
  }

  warn(...args) {
    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  error(...args) {
    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  debug(...args) {
    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));
  }

  trace(...args) {
    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));
  }

  clear() {} // no-op


  group(...data) {
    if (data.length > 0) {
      this.log(...data);
    }

    this._groupIndent += '  ';
  }

  groupEnd() {
    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);
  }

  dir(obj, options) {
    this._writeToConsole('info', inspect(obj, {
      customInspect: false,
      ...options }));

  }

  assert(value, ...args) {
    if (!value) {
      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
      this.warn(...args); // The arguments will be formatted in warn() again
    }
  }

  count(label = 'default') {
    // Ensures that label is a string, and only things that can be
    // coerced to strings. e.g. Symbol is not allowed
    label = `${label}`;

    let count = this._counts.get(label);

    if (count === undefined) {
      count = 1;
    } else {
      count++;
    }

    this._counts.set(label, count);

    this.log(`${label}: ${count}`);
  }

  countReset(label = 'default') {
    if (!this._counts.has(label)) {
      process.emitWarning(`Count for '${label}' does not exist`);
      return;
    }

    this._counts.delete(`${label}`);
  }

  time(label = 'default') {
    label = `${label}`;

    if (this._times.has(label)) {
      process.emitWarning(`Label ${label}" already exists`);
      return;
    }

    this._times.set(label, Date.now());
  }

  timeEnd(label = 'default') {
    const warned = logTime(this, label);

    if (!warned) {
      this._times.delete(label);
    }
  }

  timeLog(label = 'default', ...logData) {
    logTime(this, label, logData);
  } // TODO: implement console.table()


  table() {
    if (!tableWarned) {
      tableWarned = true;
      process.emitWarning('"console.table" is not yet implemented in Titanium!');
    }
  }}



Console.prototype.log = Console.prototype.info; // Treat log as alias to info

Console.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log

Console.prototype.groupCollapsed = Console.prototype.group;
const globalConsole = new Console(Ti.API);
globalConsole.Console = Console;
global.console = globalConsole;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  Date.prototype.toLocaleDateString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;

    if (!oldOptions || !oldOptions.dateStyle && !oldOptions.month && !oldOptions.day && !oldOptions.year) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };

  Date.prototype.toLocaleTimeString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;

    if (!oldOptions || !oldOptions.timeStyle && !oldOptions.hour && !oldOptions.minute && !oldOptions.second) {
      const defaultOptions = {
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };

  Date.prototype.toLocaleString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const oldOptions = properties.options;
    let hasOption = false;

    if (oldOptions) {
      hasOption = !!oldOptions.dateStyle || !!oldOptions.timeStyle || !!oldOptions.weekday || !!oldOptions.month || !!oldOptions.day || !!oldOptions.year || !!oldOptions.hour || !!oldOptions.minute || !!oldOptions.second;
    }

    if (!hasOption) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric' };

      properties.options = Object.assign(defaultOptions, oldOptions);
    }

    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

/**
 * Generates a "creation" properties dictionary for Titanium's Collator, DateTimeFormat, and NumberFormat proxies
 * from the given Intl type's constructor arguments.
 * @param {Object[]} args
 * The arguments array that was passed into Intl Collator, DateTimeFormat, or NumberFormat type's constructor.
 * @param {Function} supportedFormatLocalesFunction Reference to a supportedLocalesOf() function.
 * @return {Object} Returns a properties dictionary to be passed into a Titanium proxy's constructor.
 */

function makeTiFormatCreationPropertiesFrom(args, supportedFormatLocalesFunction) {
  const properties = {};

  if (args.length >= 1) {
    if (typeof args[0] === 'string') {
      properties.locale = args[0];
    } else if (Array.isArray(args[0])) {
      const supportedLocales = supportedFormatLocalesFunction(args[0]);

      if (supportedLocales.length > 0) {
        properties.locale = supportedLocales[0];
      }
    }
  }

  if (args.length >= 2 && typeof args[1] === 'object') {
    properties.options = args[1];
  }

  return properties;
} // Add "Intl" APIs missing on Android.


{
  // Set up an "Intl.Collator" type which wraps our undocumented "Ti.Locale.Collator" proxy.
  function TiCollator() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedCollatorLocales);
    const collator = new Ti.Locale.Collator(properties);
    collator.compare = collator.compare.bind(collator);
    return collator;
  }

  TiCollator.supportedLocalesOf = Ti.Locale.getSupportedCollatorLocales; // Set up an "Intl.DateTimeFormat" type which wraps our undocumented "Ti.Locale.DateTimeFormat" proxy.

  function TiDateTimeFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedDateTimeFormatLocales);
    return new Ti.Locale.DateTimeFormat(properties);
  }

  TiDateTimeFormat._makeTiCreationPropertiesFrom = (args) => {
    return makeTiFormatCreationPropertiesFrom(args, Ti.Locale.getSupportedDateTimeFormatLocales);
  };

  TiDateTimeFormat.supportedLocalesOf = Ti.Locale.getSupportedDateTimeFormatLocales; // Set up an "Intl.NumberFormat" type which wraps our undocumented "Ti.Locale.NumberFormat" proxy.

  function TiNumberFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedNumberFormatLocales);
    return new Ti.Locale.NumberFormat(properties);
  }

  TiNumberFormat.supportedLocalesOf = Ti.Locale.getSupportedNumberFormatLocales; // Make our custom "Intl" module available globally.

  commonjsGlobal.Intl = {
    Collator: TiCollator,
    DateTimeFormat: TiDateTimeFormat,
    NumberFormat: TiNumberFormat,
    getCanonicalLocales: Ti.Locale.getCanonicalLocales };

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  Number.prototype.toLocaleString = function () {
    const formatter = new Intl.NumberFormat(...arguments);
    return formatter.format(this.valueOf());
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  String.prototype.localeCompare = function (compareString, locales, options) {
    const collator = new Intl.Collator(locales, options);
    return collator.compare(this, compareString);
  };

  String.prototype.toLocaleLowerCase = function (locale) {
    return Ti.Locale.makeLowerCase(this, locale);
  };

  String.prototype.toLocaleUpperCase = function (locale) {
    return Ti.Locale.makeUpperCase(this, locale);
  };
}

/**
 * This file is used to hijack the standard require to allow for JS
 * implementations of "core" modules.
 *
 * You add a binding from the "core" module id to the under the hood JS
 * implementation. We then intercept require calls to handle requests for these modules
 * and lazily load the file.
 */

/**
 * Used by @function bindObjectToCoreModuleId
 * @type {map<string, object>}
 */
const bindings = new Map();
/**
 * Used by @function redirectCoreModuleIdToPath
 * @type {map<string, string>}
 */

const redirects = new Map();
/**
 * Does the request look like a typical core module? (no '.' or '/' characters)
 * @param {string} path original require path/id
 * @returns {boolean}
 */

function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }

  const firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
} // Hack require to point to this as core module "binding". (Note that iOS does not have a global require.)


const originalRequire = global.require ? global.require : require.main.require.bind(require.main); // This works for Windows as-is, and also intercepts the call on Android/iOS for ti.main.js (the first file executed)

global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }

  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }

  return originalRequire(moduleId);
}; // ... but we still need to hack it when requiring from other files for Android/iOS (due to module.js impl)


const originalModuleRequire = global.Module.prototype.require;

global.Module.prototype.require = function (path, context) {
  if (bindings.has(path)) {
    return bindings.get(path);
  }

  if (redirects.has(path)) {
    path = redirects.get(path);
  }

  return originalModuleRequire.call(this, path, context);
};
/**
 * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {*} binding an already constructured value/object to return
 */


function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  bindings.set(moduleId, binding);
}
/**
 * Registers a binding from a short module id to the full under the hood filepath if given a string.
 * This allows for lazy instantiation of the module on-demand
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {string} filepath the full filepath to require under the hood.
 *                              This should be an already resolved absolute path,
 *                              as otherwise the context of the call could change what gets loaded!
 */

function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  redirects.set(moduleId, filepath);
} // FIXME: There's a collision here with global.binding declared in KrollBridge.m on iOS

if (!global.binding) {
  global.binding = {};
}

global.binding.register = register;
global.binding.redirect = redirect;

// Load all JavaScript extensions/polyfills
register('console', globalConsole);

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.Activity.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'window' || k === 'intent' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/* globals OS_ANDROID */
{
  const Properties = Titanium.App.Properties;

  function nullOrDefaultValue(defaultValue) {
    if (typeof defaultValue === 'undefined') {
      return null;
    }

    return defaultValue;
  }

  function propertyGetter(delegate) {
    return function (key, defaultValue) {
      if (!Properties.hasProperty(key)) {
        return nullOrDefaultValue(defaultValue);
      }

      return delegate.call(Properties, key);
    };
  }

  ['getBool', 'getDouble', 'getInt', 'getString'].forEach(function (getter) {
    Properties[getter] = propertyGetter(Properties[getter]);
  });

  Properties.getList = Properties.getObject = function (key, defaultValue) {
    if (!Properties.hasProperty(key)) {
      return nullOrDefaultValue(defaultValue);
    }

    return JSON.parse(Properties.getString(key));
  };

  Properties.setList = Properties.setObject = function (key, val) {
    Properties.setString(key, JSON.stringify(val));
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2019-Present by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID, OS_IOS, OS_VERSION_MAJOR */
const buffer = Ti.createBuffer({
  value: '' });

const blob = buffer.toBlob();
const BlobPrototype = Object.getPrototypeOf(blob);

{
  // This doesn't "stick" for iOS. It is implemented natively.
  // Web Blob has an arrayBuffer() method that returns a Promise
  // https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer
  Object.defineProperty(BlobPrototype, 'arrayBuffer', {
    value: function () {
      return new Promise((resolve, reject) => {
        let buf;

        try {
          buf = this.toArrayBuffer();
        } catch (err) {
          return reject(err);
        }

        resolve(buf);
      });
    },
    enumerable: true });

}

/* globals OS_ANDROID */

{
  const Locale = Titanium.Locale;
  const wrappedGetString = Locale.getString;

  Locale.getString = function (key, defaultValue) {
    const defaultValueType = typeof defaultValue; // If the hint/default is not a string, ignore it!

    if (defaultValueType !== 'string') {
      return wrappedGetString.call(Locale, key);
    }

    return wrappedGetString.call(Locale, key, defaultValue);
  };

  commonjsGlobal.L = Locale.getString;
}

// Keeps an object alive until dispose() is called.
// This is currently used to keep "top level" objects
// (ex: windows, tab groups) alive until their lifecycle ends.
function PersistentHandle(object) {
  this.cell = PersistentHandle.lastId++;
  PersistentHandle.objects[this.cell] = object;
} // Objects retained by persistent handles.
// Each element in this array acts as a storage "cell"
// keeping the object reachable and alive until it is removed.


PersistentHandle.objects = {};
PersistentHandle.lastId = 0;

PersistentHandle.prototype.dispose = function () {
  if (this.cell === -1) {
    // This handle has already been disposed.
    return;
  }

  delete PersistentHandle.objects[this.cell];
  this.cell = -1;
};

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2013-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

{
  const HTTPClient = Titanium.Network.HTTPClient;
  const _send = HTTPClient.prototype.send;

  HTTPClient.prototype.send = function (options) {
    // Retain the httpclient until the request has been finished.
    const handle = new PersistentHandle(this);
    this.on('disposehandle', function () {
      handle.dispose();

      if (kroll.DBG) {
        kroll.log('HTTPClient', 'The persistent handle is disposed.');
      }
    });

    _send.call(this, options);
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2012-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  function iPhoneConstant(name) {
    Titanium.API.error('!!!');
    Titanium.API.error('!!! WARNING : Use of unsupported constant Ti.UI.iPhone.' + name + ' !!!');
    Titanium.API.error('!!!');
    return 0;
  } // TODO: Remove me. Only for temporary compatibility


  Titanium.UI.iPhone = {
    ActivityIndicatorStyle: {
      get BIG() {
        return iPhoneConstant('ActivityIndicatorStyle.BIG');
      },

      get DARK() {
        return iPhoneConstant('ActivityIndicatorStyle.DARK');
      } },


    AnimationStyle: {
      get FLIP_FROM_LEFT() {
        return iPhoneConstant('AnimationStyle.FLIP_FROM_LEFT');
      } },


    ProgressBarStyle: {
      get SIMPLE() {
        return iPhoneConstant('ProgressBarStyle.SIMPLE');
      } },


    SystemButton: {
      get FLEXIBLE_SPACE() {
        return iPhoneConstant('SystemButton.FLEXIBLE_SPACE');
      },

      get DISCLOSURE() {
        return iPhoneConstant('SystemButton.DISCLOSURE');
      } },


    SystemButtonStyle: {
      get BAR() {
        return iPhoneConstant('SystemButtonStyle.BAR');
      } },


    TableViewCellSelectionStyle: {
      get NONE() {
        return iPhoneConstant('TableViewCellSelectionStyle.NONE');
      } },


    TableViewSeparatorStyle: {
      get NONE() {
        return iPhoneConstant('TableViewSeparatorStyle.NONE');
      } },


    RowAnimationStyle: {
      get NONE() {
        return iPhoneConstant('RowAnimationStyle.NONE');
      } },


    TableViewScrollPosition: {
      get MIDDLE() {
        return iPhoneConstant('TableViewScrollPosition.MIDDLE');
      } },


    TableViewStyle: {
      get GROUPED() {
        return iPhoneConstant('TableViewStyle.GROUPED');
      } } };



}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2020-Present by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* global OS_ANDROID */

{
  const ListView = Titanium.UI.ListView;
  const defaultTemplate = {
    properties: {
      height: '45dp' },

    childTemplates: [{
      type: 'Ti.UI.Label',
      bindId: 'title',
      properties: {
        left: '6dp',
        width: '75%' } },

    {
      type: 'Ti.UI.ImageView',
      bindId: 'image',
      properties: {
        right: '25dp',
        width: '15%' } }] };




  function createListView(options) {
    if (!options) {
      options = {};
    }

    options.templates = {
      [Titanium.UI.LIST_ITEM_TEMPLATE_DEFAULT]: defaultTemplate,
      ...options.templates };

    const templates = options.templates;

    for (const binding in templates) {
      const currentTemplate = templates[binding];
      processTemplate(currentTemplate);
      processChildTemplates(currentTemplate);
    }

    return new ListView(options);
  } // Create ListItemProxy, add events, then store it in 'tiProxy' property


  function processTemplate(properties) {
    const cellProxy = Titanium.UI.createListItem();
    const events = properties.events;
    properties.tiProxy = cellProxy;
    addEventListeners(events, cellProxy);
  } // Recursive function that process childTemplates and append corresponding proxies to
  // property 'tiProxy'. I.e: type: "Titanium.UI.Label" -> tiProxy: LabelProxy object


  function processChildTemplates(properties) {
    if (!Object.prototype.hasOwnProperty.call(properties, 'childTemplates')) {
      return;
    }

    const childProperties = properties.childTemplates;

    if (!childProperties) {
      return;
    }

    for (let i = 0; i < childProperties.length; i++) {
      const child = childProperties[i];
      const proxyType = child.type;

      if (proxyType) {
        const creationProperties = child.properties;
        const creationFunction = lookup(proxyType); // Create proxy.

        let childProxy;

        if (creationProperties) {
          childProxy = creationFunction(creationProperties);
        } else {
          childProxy = creationFunction();
        } // Add event listeners.


        const events = child.events;
        addEventListeners(events, childProxy); // Append proxy to tiProxy property.

        child.tiProxy = childProxy;
      }

      processChildTemplates(child);
    }
  } // Add event listeners.


  function addEventListeners(events, proxy) {
    if (events !== undefined) {
      for (const eventName in events) {
        proxy.addEventListener(eventName, events[eventName]);
      }
    }
  }

  function lookupProxyConstructor(namespace) {
    const namespaceIndex = namespace.lastIndexOf('.');
    const proxyName = namespace.slice(namespaceIndex + 1);
    const parentNamespace = namespace.substring(0, namespaceIndex);
    const segments = parentNamespace.split('.');
    let parentProxy = commonjsGlobal;

    for (let i = 0; i < segments.length; i++) {
      parentProxy = parentProxy[segments[i]];
    }

    if (parentProxy) {
      const method = parentProxy[`create${proxyName}`];

      if (method) {
        return method;
      }
    }

    throw new Error(`Could not lookup constructor for namespace: "${namespace}"`);
  } // Convert name of UI elements into a constructor function.
  // i.e: lookup("Titanium.UI.Label") returns Titanium.UI.createLabel function.


  function lookup(namespace) {
    // Handle Titanium widgets.
    if (/^(Ti|Titanium)/.test(namespace)) {
      return lookupProxyConstructor(namespace); // Handle Alloy widgets.
    } else {
      let widget;

      try {
        // Attempt to load alloy widget.
        widget = commonjsGlobal.Module.main.require(`/alloy/widgets/${namespace}/controllers/widget`);
      } catch (e) {
        try {
          // Widget does not exist, attempt to load namespace.
          widget = commonjsGlobal.Module.main.require(namespace);
        } catch (err) {
          // Namespace does not exist, fall back to legacy behaviour.
          return lookupProxyConstructor(namespace);
        }
      }

      if (widget) {
        return function (parameters) {
          const obj = new widget(parameters);
          return obj.getView();
        };
      }
    }
  } // Overwrite list view constructor function with our own.


  Titanium.UI.createListView = createListView;
}

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.UI.NavigationWindow.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'parent' || k === 'window' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/**
 * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.
 * It provides a common interface for handling colors and converting to necessary string forms.
 */

const HEX_3_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F3

const HEX_4_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F38

const HEX_6_REGEX = /^#?([a-f\d]){6}$/i; // i.e. #00FF33

const HEX_8_REGEX = /^#?([a-f\d]){8}$/i; // i.e. #00FF3388

/**
 * @param {number} integer in range of 0-255
 * @returns {string} 2-character hex string value
 */

function paddedHex(integer) {
  const str = integer.toString(16);

  if (str.length === 1) {
    return `0${str}`;
  }

  return str;
}

class Color {
  /**
   * @param {number} r red value in range 0-255
   * @param {number} g green value in range 0-255
   * @param {number} b blue value in range 0-255
   * @param {number} [a=1.0] alpha value in range 0.0-1.0
   */
  constructor(r, g, b, a = 1.0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = a;
  }
  /**
   * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)
   * @returns {boolean}
   */


  isOpaque() {
    return this.alpha === 1.0;
  }
  /**
   * Converts the alpha value into equivalent hex string value properly.
   * @returns {string}
   */


  alphaHex() {
    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha
    return paddedHex(Math.round(this.alpha * 255.0));
  }
  /**
   * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.
   * @returns {string}
   */


  _toRGBHexString() {
    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;
  }
  /**
   * Used by CSS.
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0)
   * @returns {string}
   */


  toRGBAHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this._toRGBHexString()}${this.alphaHex()}`;
  }
  /**
   * Used by Android/iOS
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)
   * @returns {string}
   */


  toARGBHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this.alphaHex()}${this._toRGBHexString()}`;
  }
  /**
   * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string
   * @returns {string}
   */


  toHex() {
    return this.toARGBHexString();
  }
  /**
   * Converts this color to an rgba expression. This expression is more consistent across platforms.
   * (whereas iOS/Android differ in expectations for hex strings.)
   * @returns {string}
   */


  toRGBAString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;
  }
  /**
   * @returns {Color}
   */


  static fallback() {
    return new Color(0, 0, 0); // return black to match native impl in iOS
  }
  /**
   * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)
   * @param {string} hex hexadecimal color string
   * @param {number} [alpha] alpha value
   * @returns {Color}
   */


  static fromHex6String(hex, alpha) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const r = parseInt(hex.substr(startIndex, 2), 16);
    const g = parseInt(hex.substr(startIndex + 2, 2), 16);
    const b = parseInt(hex.substr(startIndex + 4, 2), 16);
    return new Color(r, g, b, alpha);
  }
  /**
   * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)
   * @param {string} hex hexadecimal color string
   * @returns {Color}
   */


  static fromHex8String(hex) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255

    const r = parseInt(hex.substr(startIndex + 2, 2), 16);
    const g = parseInt(hex.substr(startIndex + 4, 2), 16);
    const b = parseInt(hex.substr(startIndex + 6, 2), 16);
    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)
  }
  /**
   * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)
   * @param {string|object} entry possible hex string or an object
   * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object
  	 * @param {string} [hex.color] hex string for the base color when hex is an object
   * @returns {Color}
   * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value
   */


  static fromSemanticColorsEntry(entry) {
    let color = entry;
    let alpha = 1.0;
    let hadAlpha = false;

    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {
      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range

      hadAlpha = true;
      color = entry.color; // if it has an alpha property assume it has a color property too!
    } // expand the shorter hex string forms to 6 or 8 digits


    if (color.length === 3) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);
    } else if (color.length === 4) {
      // Expand shorthand form (e.g. "03F8") to full form (e.g. "0033FF88")
      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);
    }

    if (HEX_6_REGEX.exec(color)) {
      return Color.fromHex6String(color, alpha);
    }

    if (HEX_8_REGEX.exec(color)) {
      if (hadAlpha) {
        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);
      }

      return Color.fromHex8String(color);
    } // uh-oh, something is up!


    return Color.fallback();
  }}



var color = Color;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2019-2020 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.

const UI = kroll.binding('Titanium').Titanium.UI; // Make our read-only constants
// TODO: Remove in SDK 10, DEPRECATED in 9.1.0

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {
  value: 'light',
  writable: false });

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {
  value: 'dark',
  writable: false });

Object.defineProperty(UI, 'semanticColorType', {
  get: () => {
    // TODO: Guard against ios < 13 and Android api < 29?
    // Assume "light" mode unless we explicitly know it's dark
    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {
      return UI.SEMANTIC_COLOR_TYPE_DARK;
    }

    return UI.SEMANTIC_COLOR_TYPE_LIGHT;
  } });
// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl
// on iOS 13+, we have a native version

{

  let colorset;

  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {
    // Load all semantic colors from JSON if not done already.
    // Do so via require() in case this file was changed while running LiveView.
    if (!colorset) {
      const colorsetFileName = 'semantic.colors.json';

      try {
        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, colorsetFileName);

        if (colorsetFile.exists()) {
          // eslint-disable-next-line security/detect-non-literal-require
          colorset = require(`/${colorsetFileName}`);
        }
      } catch (error) {
        console.error(`Failed to load colors file '${colorsetFileName}'`);
        return color.fallback().toHex();
      }
    }

    try {
      if (true) {
        // On Android, use custom string references to be handled by "TiColorHelper.java".
        if (colorset[colorName]) {
          // Add all theme colors to a single string.
          // Example: "ti.semantic.color:dark=<ColorString>;light=<ColorString>"
          const colorArray = [];

          for (const colorType in colorset[colorName]) {
            const colorObj = color.fromSemanticColorsEntry(colorset[colorName][colorType]);
            colorArray.push(`${colorType}=${colorObj.toRGBAString()}`);
          }

          return 'ti.semantic.color:' + colorArray.join(';');
        } else if (Ti.Android.R.color[colorName]) {
          // We're referencing a native "res" color entry.
          return `@color/${colorName}`;
        }
      }
    } catch (error) {
      console.error(`Failed to lookup color for ${colorName}`);
    }

    return color.fallback().toHex();
  };
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID, OS_IOS */
{
  const Tab = Titanium.UI.Tab;

  function createTab(options) {
    const tab = new Tab(options);

    if (options) {
      tab._window = options.window;
    }

    return tab;
  }

  Titanium.UI.createTab = createTab;

  Tab.prototype.open = function (window, options) {
    if (!window) {
      return;
    }

    if (!options) {
      options = {};
    } // When we open a window using tab.open(win), we treat it as
    // opening a HW window on top of the tab.


    options.tabOpen = true;
    window.open(options);
  };

  Tab.prototype.close = function (options) {
    const window = this.getWindow();

    if (window) {
      window.close(options);
      this.setWindow(null);
    }
  };

  const _setWindow = Tab.prototype.setWindow;

  Tab.prototype.setWindow = function (window) {
    this._window = window;

    _setWindow.call(this, window);
  }; // TODO: Remove! This is an undocumented accessor method


  Tab.prototype.getWindow = function () {
    return this._window;
  };

  Object.defineProperty(Tab.prototype, 'window', {
    enumerable: true,
    set: Tab.prototype.setWindow,
    get: Tab.prototype.getWindow });

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2021 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  const TabGroup = Titanium.UI.TabGroup; // Avoid circular loops in toJSON()

  Object.defineProperty(TabGroup.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'activity' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

  Object.defineProperty(Titanium.UI.Tab.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'window' || k === 'tabGroup' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2015-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */
{
  const View = Titanium.UI.View;
  const _add = View.prototype.add;

  View.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to a view.');
    }

    this._children = this._children || [];

    _add.call(this, child); // The children have to be retained by the view in the Javascript side
    // in order to let V8 know the relationship between children and the view.
    // Therefore, as long as its window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.


    this._children.push(child);
  };

  const _remove = View.prototype.remove;

  View.prototype.remove = function (child) {
    _remove.call(this, child); // Remove the child in the Javascript side so it can be detached and garbage collected.


    const children = this._children || [];
    const childIndex = children.indexOf(child);

    if (childIndex !== -1) {
      children.splice(childIndex, 1);
    }
  }; // Do not serialize the parent view. Doing so will result
  // in a circular reference loop.


  Object.defineProperty(Titanium.TiView.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};

      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];

        if (k === 'parent' || k.charAt(0) === '_') {
          continue;
        }

        serialized[k] = this[k];
      }

      return serialized;
    },
    enumerable: false });

}

/* globals OS_ANDROID */
{
  const createWebView = Titanium.UI.createWebView;

  function createWebViewWrapper(...args) {
    const webView = createWebView.apply(this, args);

    webView.onCreateWindow = function (e) {
      if (!e.isUserGesture) {
        return null;
      }

      const win = Titanium.UI.createWindow({}, {
        fullscreen: false // Force new activity.
      });

      const newWebView = Titanium.UI.createWebView();
      win.add(newWebView);
      win.open();
      return newWebView;
    };

    return webView;
  }

  Titanium.UI.createWebView = createWebViewWrapper;
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

{
  const TAG = 'Window';
  const Script = kroll.binding('evals').Script; // Android-specific way to grab binding, hangs off 'script' on iOS

  const Window = Titanium.UI.Window;
  Window.prototype._cachedActivityProxy = null;

  function createWindow(options) {
    const window = new Window(options);
    window._children = [];
    return window;
  }

  Titanium.UI.createWindow = createWindow; // Activity getter (account for scenario when heavy weight window's activity is not created yet)

  function activityProxyGetter() {
    const activityProxy = this._getWindowActivityProxy();

    if (activityProxy) {
      return activityProxy;
    }

    if (this._cachedActivityProxy == null) {
      // eslint-disable-line
      this._cachedActivityProxy = {};
    }

    return this._cachedActivityProxy;
  }

  Window.prototype.getActivity = activityProxyGetter;
  Object.defineProperty(Window.prototype, 'activity', {
    get: activityProxyGetter });

  const _open = Window.prototype.open;

  Window.prototype.open = function (options) {
    // Retain the window until it has closed.
    const handle = new PersistentHandle(this);
    const self = this;
    this.once('close', function (e) {
      if (e._closeFromActivityForcedToDestroy) {
        if (kroll.DBG) {
          kroll.log(TAG, 'Window is closed because the activity is forced to destroy by Android OS.');
        }

        return;
      } // Dispose the URL context if the window's activity is destroyed.


      if (self._urlContext) {
        Script.disposeContext(self._urlContext);
        self._urlContext = null;
      }

      handle.dispose();

      if (kroll.DBG) {
        kroll.log(TAG, 'Window is closed normally.');
      }
    });
    return _open.call(this, options);
  };

  const _add = Window.prototype.add;

  Window.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to another window/tabGroup.');
    }

    _add.call(this, child); // The children have to be retained by the window in the Javascript side
    // in order to let V8 know the relationship between children and the window.
    // Therefore, as long as the window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.


    this._children.push(child);
  };

  const _remove = Window.prototype.remove;

  Window.prototype.remove = function (child) {
    _remove.call(this, child); // Remove the child in the Javascript side so it can be detached and garbage collected.


    const children = this._children;

    if (children) {
      const childIndex = children.indexOf(child);

      if (childIndex !== -1) {
        children.splice(childIndex, 1);
      }
    }
  };

  Window.prototype.postWindowCreated = function () {
    if (kroll.DBG) {
      kroll.log(TAG, 'Checkpoint: postWindowCreated()');
    }

    if (this._cachedActivityProxy) {
      this._internalActivity.extend(this._cachedActivityProxy);
    }
  };
}

/**
 * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
 * @param {string} eventName the name of the event to register for
 * @param {function} listener the listener callback/function to invoke when the event is emitted
 * @param {boolean} prepend whether to prepend or append the listener
 * @returns {EventEmitter}
 */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  } // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)


  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }

  const eventListeners = emitter._eventsToListeners[eventName] || [];

  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }

  emitter._eventsToListeners[eventName] = eventListeners; // Check max listeners and spit out warning if >

  const max = emitter.getMaxListeners();
  const length = eventListeners.length;

  if (max > 0 && length > max) {
    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }

  return emitter;
}

function onceWrap(emitter, eventName, listener) {
  function wrapper(...args) {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves

    this.listener.apply(this.emitter, args); // then forward the event callback
  } // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter


  const wrapperThis = {
    emitter,
    eventName,
    listener };

  const bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener

  bound.listener = listener; // have to add listener property for "unwrapping"

  wrapperThis.wrappedFunc = bound;
  return bound;
} // many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it


class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }

  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }

  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }

  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }

  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }

  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }

  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    const length = eventListeners.length;
    let foundIndex = -1;
    let unwrappedListener; // Need to search LIFO, and need to handle wrapped functions (once wrappers)

    for (let i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }

    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      } // Don't emit if there's no listeners for 'removeListener' type!


      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }

    return this;
  }

  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }

  emit(eventName, ...args) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];

    for (const listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }

    return eventListeners.length !== 0;
  }

  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }

  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }

  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    } // Need to "unwrap" once wrappers!


    const raw = this._eventsToListeners[eventName] || [];
    return raw.map((l) => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }

    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }

  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)

    return this;
  }

  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }

      return this;
    } // yuck, we'll have to emit 'removeListener' events as we go


    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      const names = Object.keys(this._eventsToListeners).filter((name) => name !== 'removeListener');
      names.forEach((name) => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      const listeners = this._eventsToListeners[eventName] || [];

      for (let i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }

    return this;
  }}


EventEmitter.defaultMaxListeners = 10;

EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};

EventEmitter.EventEmitter = EventEmitter;

/**
 * @param  {*} arg passed in argument value
 * @param  {string} name name of the argument
 * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
 * @return {void}
 * @throws {TypeError}
 */
function assertArgumentType(arg, name, typename) {
  const type = typeof arg;

  if (type !== typename.toLowerCase()) {
    throw new TypeError(`The "${name}" argument must be of type ${typename}. Received type ${type}`);
  }
}

const startTime = Date.now();
/**
 * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
 * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
 * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
 * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
 * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
 * @param {string} original original architecture reported by Ti.Platform
 * @returns {string}
 */

function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';
    // coerce 'arm64-v8a' -> 'arm64'

    case 'arm64-v8a':
      return 'arm64';
    // coerce 'i386', 'x86' -> 'ia32'

    case 'i386':
    case 'x86':
      return 'ia32';
    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'

    case 'x86_64':
    case 'ia64':
      return 'x64';
    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17

    case 'mips64':
      return 'mips';
    // coerce 'Unknown' -> 'unknown'

    case 'Unknown':
      return 'unknown';

    default:
      return original;}

}

const process$1 = new EventEmitter();

process$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here


process$1.arch = standardizeArch(Ti.Platform.architecture);
process$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?

Object.defineProperty(process$1, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false });


process$1.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};

process$1.channel = undefined;

process$1.chdir = () => {
  throw new Error('process.chdir is unsupported');
};

process$1.config = {};
process$1.connected = false;

process$1.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0 };

};

process$1.cwd = () => __dirname;

Object.defineProperty(process$1, 'debugPort', {
  get: function () {
    let value = 0; // default to 0

    try {
      if ("android" === 'android') {
        const assets = kroll.binding('assets');
        const json = assets.readAsset('deploy.json');

        if (json) {
          const deployData = JSON.parse(json);

          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      }
    } catch (error) {} // ignore
    // overwrite this getter with static value


    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true });

    return value;
  },
  enumerable: true,
  configurable: true });


process$1.disconnect = () => {}; // no-op


process$1.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};

process$1.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  let type;
  let detail;

  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }

  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';

    if (code !== undefined) {
      warning.code = code;
    }

    if (detail !== undefined) {
      warning.detail = detail;
    }
  } // TODO: Throw TypeError if not an instanceof Error at this point!


  const isDeprecation = warning.name === 'DeprecationWarning';

  if (isDeprecation && process$1.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$1.throwDeprecation) {
    throw warning;
  }

  this.emit('warning', warning);
};

function loadEnvJson() {
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');

    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error(`Failed to read "_env_.json". Reason: ${error.message}`);
  }

  return {};
}

Object.defineProperty(process$1, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true });

process$1.execArgv = [];
process$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?

process$1.exit = () => {
  throw new Error('process.exit is not supported');
};

process$1.exitCode = undefined;
process$1.noDeprecation = false;
process$1.pid = 0; // FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?

process$1.platform = "android";
process$1.ppid = 0; // TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?
// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)

process$1.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.error(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.info(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.title = Ti.App.name;
process$1.throwDeprecation = false;
process$1.traceDeprecation = false;

process$1.umask = () => 0; // just always return 0


process$1.uptime = () => {
  const diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$1.version = "10.1.1";
process$1.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

process$1[Symbol.toStringTag] = 'process';
global.process = process$1; // handle spitting out warnings

const WARNING_PREFIX = `(titanium:${process$1.pid}) `;
process$1.on('warning', (warning) => {
  const isDeprecation = warning.name === 'DeprecationWarning'; // if we're not doing deprecations, ignore!

  if (isDeprecation && process$1.noDeprecation) {
    return;
  } // TODO: Check process.traceDeprecation and if set, include stack trace in message!


  let msg = WARNING_PREFIX;

  if (warning.code !== undefined) {
    msg += `[${warning.code}] `;
  }

  if (warning.toString) {
    msg += warning.toString();
  }

  if (warning.detail) {
    msg += `\n${warning.detail}`;
  }

  console.error(msg);
});
let uncaughtExceptionCallback = null;

process$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;

process$1.setUncaughtExceptionCaptureCallback = (fn) => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }

  assertArgumentType(fn, 'fn', 'function');

  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }

  uncaughtExceptionCallback = fn;
};

Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  const error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;

  if (process$1.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  } // otherwise forward the event!


  process$1.emit('uncaughtException', error);
});
// JS engine should be able to optimize easier

class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }

  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }}

// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/


const tickQueue = [];
const immediateQueue = [];
let drainingTickQueue = false;
let drainQueuesTimeout = null;
/**
 * Iteratively runs all "ticks" until there are no more.
 * This can cause infinite recursion if a tick schedules another forever.
 */

function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }

  drainingTickQueue = true;

  while (tickQueue.length) {
    const tick = tickQueue.shift();
    tick.run();
  }

  drainingTickQueue = false;
}

function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue(); // tick queue should be empty!

  const immediatesRemaining = processImmediateQueue();

  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}
/**
 * Attempts to process "immediates" (in a much more leisurely way than ticks)
 * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
 * If any ticks are added during invocation of immediate, we drain the tick queue fully before
 * proceeding to next immediate (if we still have time in our window).
 * @returns {number} number of remaining immediates to be processed
 */


function processImmediateQueue() {
  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates

  while (immediateQueue.length && Date.now() < immediateDeadline) {
    const immediate = immediateQueue.shift();
    immediate.run();

    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }

  return immediateQueue.length;
}

process$1.nextTick = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  tickQueue.push(new CallbackWithArgs(callback, args));

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};

global.setImmediate = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  const immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }

  return immediate;
};

global.clearImmediate = function (immediate) {
  const index = immediateQueue.indexOf(immediate);

  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

const FORWARD_SLASH = 47; // '/'

const BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */

function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}
/**
 * [isAbsolute description]
 * @param  {boolean} isPosix whether this impl is for POSIX or not
 * @param  {string} filepath   input file path
 * @return {Boolean}          [description]
 */


function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length; // empty string special case

  if (length === 0) {
    return false;
  }

  const firstChar = filepath.charCodeAt(0);

  if (firstChar === FORWARD_SLASH) {
    return true;
  } // we already did our checks for posix


  if (isPosix) {
    return false;
  } // win32 from here on out


  if (firstChar === BACKWARD_SLASH) {
    return true;
  }

  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    const thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }

  return false;
}
/**
 * [dirname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */


function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;

  if (length === 0) {
    return '.';
  } // ignore trailing separator


  let fromIndex = length - 1;
  const hadTrailing = filepath.endsWith(separator);

  if (hadTrailing) {
    fromIndex--;
  }

  const foundIndex = filepath.lastIndexOf(separator, fromIndex); // no separators

  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      const firstChar = filepath.charCodeAt(0);

      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  } // only found root separator


  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  } // Handle special case of '//something'


  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }

  return filepath.slice(0, foundIndex);
}
/**
 * [extname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */


function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const index = filepath.lastIndexOf('.');

  if (index === -1 || index === 0) {
    return '';
  } // ignore trailing separator


  let endIndex = filepath.length;

  if (filepath.endsWith(separator)) {
    endIndex--;
  }

  return filepath.slice(index, endIndex);
}

function lastIndexWin32Separator(filepath, index) {
  for (let i = index; i >= 0; i--) {
    const char = filepath.charCodeAt(i);

    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }

  return -1;
}
/**
 * [basename description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @param  {string} [ext]      file extension to drop if it exists
 * @return {string}            [description]
 */


function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');

  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }

  const length = filepath.length;

  if (length === 0) {
    return '';
  }

  const isPosix = separator === '/';
  let endIndex = length; // drop trailing separator (if there is one)

  const lastCharCode = filepath.charCodeAt(length - 1);

  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  } // Find last occurence of separator


  let lastIndex = -1;

  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1); // handle special case of root path like 'C:' or 'C:\\'

    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  } // Take from last occurrence of separator to end of string (or beginning to end if not found)


  const base = filepath.slice(lastIndex + 1, endIndex); // drop trailing extension (if specified)

  if (ext === undefined) {
    return base;
  }

  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}
/**
 * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
 *
 * When multiple, sequential path segment separation characters are found (e.g.
 * / on POSIX and either \ or / on Windows), they are replaced by a single
 * instance of the platform-specific path segment separator (/ on POSIX and \
 * on Windows). Trailing separators are preserved.
 *
 * If the path is a zero-length string, '.' is returned, representing the
 * current working directory.
 *
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath  input file path
 * @return {string} [description]
 */


function normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');

  if (filepath.length === 0) {
    return '.';
  } // Windows can handle '/' or '\\' and both should be turned into separator


  const isWindows = separator === '\\';

  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }

  const hadLeading = filepath.startsWith(separator); // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash

  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  const hadTrailing = filepath.endsWith(separator);
  const parts = filepath.split(separator);
  const result = [];

  for (const segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }

  let normalized = hadLeading ? separator : '';
  normalized += result.join(separator);

  if (hadTrailing) {
    normalized += separator;
  }

  if (isUNC) {
    normalized = '\\' + normalized;
  }

  return normalized;
}
/**
 * [assertSegment description]
 * @param  {*} segment [description]
 * @return {void}         [description]
 */


function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError(`Path must be a string. Received ${segment}`);
  }
}
/**
 * The `path.join()` method joins all given path segments together using the
 * platform-specific separator as a delimiter, then normalizes the resulting path.
 * Zero-length path segments are ignored. If the joined path string is a zero-
 * length string then '.' will be returned, representing the current working directory.
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       The joined filepath
 */


function join(separator, paths) {
  const result = []; // naive impl: just join all the paths with separator

  for (const segment of paths) {
    assertSegment(segment);

    if (segment.length !== 0) {
      result.push(segment);
    }
  }

  return normalize(separator, result.join(separator));
}
/**
 * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       [description]
 */


function resolve(separator, paths) {
  let resolved = '';
  let hitRoot = false;
  const isPosix = separator === '/'; // go from right to left until we hit absolute path/root

  for (let i = paths.length - 1; i >= 0; i--) {
    const segment = paths[i];
    assertSegment(segment);

    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment

    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  } // if we didn't hit root, prepend cwd


  if (!hitRoot) {
    resolved = (global.process ? process.cwd() : '/') + separator + resolved;
  }

  const normalized = normalize(separator, resolved);

  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    } // otherwise trim trailing separator


    return normalized.slice(0, normalized.length - 1);
  }

  return normalized;
}
/**
 * The `path.relative()` method returns the relative path `from` from to `to` based
 * on the current working directory. If from and to each resolve to the same
 * path (after calling `path.resolve()` on each), a zero-length string is returned.
 *
 * If a zero-length string is passed as `from` or `to`, the current working directory
 * will be used instead of the zero-length strings.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string} from [description]
 * @param  {string} to   [description]
 * @return {string}      [description]
 */


function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');

  if (from === to) {
    return '';
  }

  from = resolve(separator, [from]);
  to = resolve(separator, [to]);

  if (from === to) {
    return '';
  } // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;


  let upCount = 0;
  let remainingPath = '';

  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    } // FIXME: Break/throw if we hit bad edge case of no common root!


    from = dirname(separator, from);
    upCount++;
  } // remove leading separator from remainingPath if there is any


  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }

  return ('..' + separator).repeat(upCount) + remainingPath;
}
/**
 * The `path.parse()` method returns an object whose properties represent
 * significant elements of the path. Trailing directory separators are ignored,
 * see `path.sep`.
 *
 * The returned object will have the following properties:
 *
 * - dir <string>
 * - root <string>
 * - base <string>
 * - name <string>
 * - ext <string>
 * @param  {string} separator platform-specific file separator
 * @param  {string} filepath [description]
 * @return {object}
 */


function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: '' };

  const length = filepath.length;

  if (length === 0) {
    return result;
  } // Cheat and just call our other methods for dirname/basename/extname?


  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  const baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!

  const firstCharCode = filepath.charCodeAt(0); // both win32 and POSIX return '/' root

  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  } // we're done with POSIX...


  if (separator === '/') {
    return result;
  } // for win32...


  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  } // check for C: style root


  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      const thirdCharCode = filepath.charCodeAt(2);

      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    } // nope, just C:, no trailing separator


    result.root = filepath.slice(0, 2);
  }

  return result;
}
/**
 * The `path.format()` method returns a path string from an object. This is the
 * opposite of `path.parse()`.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {object} pathObject object of format returned by `path.parse()`
 * @param  {string} pathObject.dir directory name
 * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
 * @param  {string} pathObject.base file basename
 * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
 * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
 * @return {string}
 */


function format(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`; // append base to root if `dir` wasn't specified, or if
  // dir is the root

  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return `${pathObject.root || ''}${base}`;
  } // combine dir + / + base


  return `${pathObject.dir}${separator}${base}`;
}
/**
 * On Windows systems only, returns an equivalent namespace-prefixed path for
 * the given path. If path is not a string, path will be returned without modifications.
 * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
 * @param  {string} filepath [description]
 * @return {string}          [description]
 */


function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }

  if (filepath.length === 0) {
    return '';
  }

  const resolvedPath = resolve('\\', [filepath]);
  const length = resolvedPath.length;

  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }

  const firstCharCode = resolvedPath.charCodeAt(0); // if start with '\\\\', prefix with UNC root, drop the slashes

  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      const thirdChar = resolvedPath.charAt(2);

      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }

    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }

  return filepath;
}

const Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath };

const PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  } };

const path = PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

const PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18 },

  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12 },

  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20 } };

// default implementations

const OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    const count = Ti.Platform.processorCount;
    const array = [];

    for (let i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0 } });


    }

    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    const result = Ti.Codec.getNativeByteOrder();

    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }

    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it

  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,

  /**
   * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
   * @return {integer} [description]
   */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom

  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      gid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null };

  } };
// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)

{
  OS.cpus = () => Ti.Platform.cpus();

  OS.type = () => 'Linux';
}

const tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  } };


const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const util = {
  format: format$1,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: (value) => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: (value) => typeof value === 'function',
  isNull: (value) => value === null,
  isNullOrUndefined: (value) => value === undefined || value === null,
  isNumber: (value) => typeof value === 'number',
  isObject: (value) => value !== null && typeof value === 'object',
  isPrimitive: (value) => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: (value) => typeof value === 'string',
  isSymbol: (value) => typeof value === 'symbol',
  isUndefined: (value) => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: (e) => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: (string) => {
    const date = new Date();
    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`; // Produces output like: "21 Feb 10:04:23 - message"

    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);
  },
  print: (...args) => console.log(args.join('')),
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: (...args) => console.log(args.join('\n')),
  error: (...args) => console.error(args.join('\n')),
  debug: (string) => console.error(`DEBUG: ${string}`),
  types };

/**
 * @param {Function} constructor subclass
 * @param {Function} superConstructor base class
 * @returns {void}
 */

util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor });

  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};
/**
 * @param {Function} original original function to wrap which is expected to have a final callback argument
 * @returns {Function} function that returns a Promise
 */


util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      });
    });
  } // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks


  return wrapped;
};
/**
 * @param {Function} original original function to convert from async/Promise return value to a callback style
 * @returns {Function} wrapped function
 */


util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    const callback = args.pop();
    const promise = original.apply(this, args);
    promise.then((result) => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch((err) => {
      if (!err) {
        const wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }

      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};
/**
 * @param {Function} func function to deprecate/wrap
 * @param {string} string message to give when deprecation warning is emitted
 * @param {string} code deprecation code to use to group warnings
 * @returns {Function} wrapped function
 */


util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  } // TODO: Support `code` argument by tracking a map of codes we've warned about


  function wrapped(...args) {
    let warned = false;

    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }

    return func.apply(this, args);
  }

  return wrapped;
}; // TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?


const noop = () => {};

util.debuglog = () => {
  return noop;
};

const DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:' };
// Fake enums to use internally

const COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2 };

const STRICTNESS = {
  Strict: 0,
  Loose: 1 };


class AssertionError extends Error {
  constructor(options) {
    let {
      actual,
      expected,
      message,
      operator } =
    options;

    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = `${DEFAULT_MESSAGES[operator]}\n\n`;
    }

    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?


const assert = (value, message) => assert.ok(value, message);

assert.AssertionError = AssertionError;

assert.ok = (...args) => {
  const value = args[0];

  if (value) {
    return;
  }

  let message = args[1];
  let generatedMessage = false; // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so

  if (args.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }

  const err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '==' });

  err.generatedMessage = generatedMessage;
  throw err;
};

function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }

  throw new AssertionError(obj);
}

assert.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'equal' });

};

assert.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual' });

};

assert.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual' });

};

assert.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual' });

};

const isPrimitive = (value) => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};
/**
 * @param {Map} actual map we are comparing
 * @param {Map} expected map we're comparing against
 * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */


function compareMaps(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()

  for (const [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }

      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      } // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again


      looseChecks.add(key);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // only go through the second Map once!


  for (const [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    } // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!


    let found = false;

    for (const key of looseChecks) {
      // if both key and value matches
      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched keys? if so, fail


  return looseChecks.size === 0;
}
/**
 * @param {Set} actual map we are comparing
 * @param {Set} expected map we're comparing against
 * @param {strictness.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */


function compareSets(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()

  for (const value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)
      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      } // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly


      looseChecks.add(value);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!


  for (const expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }

    let found = false;

    for (const object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!

        looseChecks.delete(object); // remove from our looseChecks Set since we matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched values? if so, fail


  return looseChecks.size === 0;
}
/**
 * @param {*} actual value we are comparing
 * @param {*} expected values we're comparing against
 * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
 * @param {object} [references] optional object to keep track of circular references in the hierarchy
 * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
 * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
 * @param {number} [references.depth] The current depth of the hierarchy
 * @returns {boolean}
 */


function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  } // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc
  // Type tags of objects should be the same


  const actualTag = Object.prototype.toString.call(actual);
  const expectedTag = Object.prototype.toString.call(expected);

  if (actualTag !== expectedTag) {
    return false;
  } // [[Prototype]] of objects are compared using the Strict Equality Comparison.


  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    const actualPrototype = Object.getPrototypeOf(actual);
    const expectedPrototype = Object.getPrototypeOf(expected);

    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }

  let comparison = COMPARE_TYPE.Object;

  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    } // continue on to check properties...

  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    } // continue on to check properties...

  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    } // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!


    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false; // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Set; // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Map; // continue on to check properties...
  } // Now iterate over properties and compare them!


  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values

  const expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties

  if (actualKeys.length !== expectedKeys.length) {
    return false;
  } // Are they the same keys? If one is missing, then no, fail right away


  if (!actualKeys.every((key) => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  } // Don't check own symbols when doing "loose"


  if (strictness === STRICTNESS.Strict) {
    const actualSymbols = Object.getOwnPropertySymbols(actual);
    const expectedSymbols = Object.getOwnPropertySymbols(expected); // Must have same number of symbols

    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }

    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (const key of actualSymbols) {
        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);

        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  } // Avoid circular references!
  // Record map from objects to depth in the hierarchy


  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0 };

  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    const memoizedActual = references.actual.get(actual);

    if (memoizedActual !== undefined) {
      const memoizedExpected = references.expected.get(expected);

      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }

    references.depth++;
  } // store the object -> depth mapping


  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth); // When comparing Maps/Sets, compare elements before custom properties

  let result = true;

  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }

  if (result) {
    // Now loop over keys and compare them to each other!
    for (const key of actualKeys) {
      if (!deepEqual(actual[key], expected[key], strictness, references)) {
        result = false;
        break;
      }
    }
  } // wipe the object to depth mapping for these objects now


  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}

assert.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual' });

  }
};

assert.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual' });

  }
};

assert.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual' });

  }
};

assert.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual' });

  }
};

assert.fail = (message = 'Failed') => throwError({
  message });


const NO_EXCEPTION = {};

function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}

async function executePromise(fn) {
  let promise;
  const fnType = typeof fn;

  if (fnType === 'function') {
    promise = fn();

    if (!isPromiseLike(promise)) {
      throw new TypeError(`Expected instanceof Promise to be returned from the "fn" function but got ${typeof promise}`);
    }
  } else {
    if (!isPromiseLike(fn)) {
      throw new TypeError(`The "fn" argument must be of type Function or Promise. Received type ${fnType}`);
    }

    promise = fn;
  }

  try {
    await promise;
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

assert.throws = (fn, error, message) => {
  const actual = execute(fn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.rejects = async function (asyncFn, error, message) {
  const actual = await executePromise(asyncFn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'rejects' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.doesNotThrow = (fn, error, message) => {
  const actual = execute(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};

assert.doesNotReject = async function (fn, error, message) {
  const actual = await executePromise(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};
/**
 * @param {Error} actual the actual Error generated by the wrapped function/block
 * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
 * @param {string} [message] custom message to append
 * @returns {boolean} true if the Error matches the expected value/object
 */


function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    } // Test properties (`expected` is either a generic Object or an Error instance)


    const keys = Object.keys(expected); // If we're testing against an instance of an Error, we need to hack in name/message properties.

    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (const key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual' });

          } catch (err) {
            message = err.message;
          }
        }

        throwError({
          actual,
          expected,
          message,
          operator: 'throws' });

        return false;
      }
    }

    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    } // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail


    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    } // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received


    return expected.call({}, actual);
  }

  return false;
}

assert.ifError = (value) => {
  if (value === null || value === undefined) {
    return;
  }

  throwError({
    actual: value,
    expected: null,
    message: `ifError got unwanted exception: ${value}`,
    operator: 'ifError' });

}; // Create "strict" copy which overrides "loose" methods to call strict equivalents


assert.strict = (value, message) => assert.ok(value, message); // "Copy" methods from assert to assert.strict!


Object.assign(assert.strict, assert); // Override the "loose" methods to point to the strict ones

assert.strict.deepEqual = assert.deepStrictEqual;
assert.strict.notDeepEqual = assert.notDeepStrictEqual;
assert.strict.equal = assert.strictEqual;
assert.strict.notEqual = assert.notStrictEqual; // hang strict off itself

assert.strict.strict = assert.strict;

/**
 * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
 */
function StringDecoder(encoding = 'utf8') {
  this.encoding = encoding.toLowerCase();

  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;

    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;

    case 'base64':
      this._impl = new Base64StringDecoder();
      break;

    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}
/**
 * Returns any remaining input stored in the internal buffer as a string.
 * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
 * characters appropriate for the character encoding.
 *
 * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
 * @param {Buffer} [buffer] containing the bytes to decode.
 * @returns {string}
 */


StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};
/**
 * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
 * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
 * next call to stringDecoder.write() or stringDecoder.end().
 * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
 * @returns {string}
 */


StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  } // empty string for empty buffer


  if (buffer.length === 0) {
    return '';
  }

  return this._impl.write(buffer);
};
/**
 * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
 */


class StringDecoderImpl {
  constructor(encoding = 'utf8') {
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  } // the actual underlying implementation!


  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }

    return '';
  }

  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }}

// For multi-byte encodings, let's implement some base logic...


class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }
  /**
   * @typedef {Object} IncompleteCharObject
   * @property {integer} bytesNeeded bytes missing to complete the character
   * @property {integer} charLength bytes expected to complete the character
   * @property {integer} index location in the buffer where the character starts
   */

  /**
   * Given a Buffer, sees if we have an incomplete "character" at the end of it.
   * Returns info on that:
   * - bytesNeeded: 0-3, number of bytes still remaining
   * - charLength: expected number of bytes for the incomplete character
   * - index: index in the buffer where the incomplete character begins
   * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
   */


  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }

  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }

  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }

  end(buffer) {
    let result = super.end(buffer);

    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }

    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer


    return result;
  }

  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    let char = '';

    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer

      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      } // we were able to complete, yay!
      // grab the character we completed


      char = this.incomplete.slice(0, this.charLength).toString(this.encoding); // reset our counters

      this._incompleteBufferEmptied(); // do we have any bytes left in this buffer?


      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      } // we still have more bytes, so slice the buffer up


      buffer = buffer.slice(bytesCopied, buffer.length);
    } // check this buffer to see if it indicates we need more bytes?


    const incompleteCharData = this._checkIncompleteBytes(buffer);

    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    } // ok so the buffer holds an incomplete character at it's end


    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'

    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete
    // copy from index of incomplete character to end of buffer

    const bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }

    return char; // any now-completed character that was previously incomplete, possibly empty
  }}



class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length; // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"
    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155
    // if buffer.length >= 3, check 3rd to last byte

    if (length >= 3) {
      let charLength = checkCharLengthForUTF8(buffer[length - 3]);

      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4 };

      }
    } // if buffer.length >= 2, check 2nd to last byte


    if (length >= 2) {
      let charLength = checkCharLengthForUTF8(buffer[length - 2]);

      if (charLength >= 3) {
        return {
          bytesNeeded: charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength };

      }
    } // if buffer.length >= 1, check last byte


    if (length >= 1) {
      let charLength = checkCharLengthForUTF8(buffer[length - 1]);

      if (charLength >= 2) {
        return {
          bytesNeeded: charLength - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength };

      }
    } // base case, no bytes needed - ends on complete character


    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1 };

  }

  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }}



class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 2; // ok, we have a multiple of 2 bytes

    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      const byte = buffer[buffer.length - 1];

      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2 };

      } // we're good, not a surrogate, so we have our needed 2 bytes


      return {
        bytesNeeded: 0,
        charLength: 2 };

    } // ok we have 1 byte left over, assume we need 2 to form the character


    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2 };

  }

  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }}



class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 3; // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer

    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3 };

    } // ok we have 1 or 2 bytes left over


    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };

  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }}



function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  } // 1110XXXX => 1110 => 0x1E


  if (byte >> 4 === 0x0E) {
    return 3;
  } // 110XXXXX => 110 => 0x06


  if (byte >> 5 === 0x06) {
    return 2;
  }

  return 1;
}

var StringDecoder$1 = {
  StringDecoder };


const printedWarnings = {};

function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
 * Prints a one-time warning message that we do not support the given API and performs an effective no-op
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @returns {Function} no-op function
 */


function unsupportedNoop(moduleName, name) {
  return () => {
    const fqn = `${moduleName}.${name}`;
    oneTimeWarning(fqn, `"${fqn}" is not supported yet on Titanium and uses a no-op fallback.`);
    return undefined;
  };
}
/**
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @param {Function} callback async callback we call in a quick setTimeout
 */


function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback

  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
} // Used to choose the buffer/chunk size when pumping bytes during copies


const COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?
// Keep track of integer -> FileStream mappings

const fileDescriptors = new Map();
let fileDescriptorCount = 4; // global counter used to report file descriptor integers
// Map file system access flags to Ti.Filesystem.MODE_* constants

const FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE); // Common errors

const permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);

const noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);

const fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);

const notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);

const directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);

const illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);

const fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1 } };



class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem

    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);

    if (path) {
      this._file = getTiFileFromPathLikeValue(path); // TODO: use lazy getters here?

      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize); // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }

  isDirectory() {
    return this._file.isDirectory();
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isSymbolicLink() {
    return this._file.symbolicLink;
  }

  isFIFO() {
    return false;
  }

  isSocket() {
    return false;
  }}



fs.Stats = Stats;

class ReadStream {}

fs.ReadStream = ReadStream;

class WriteStream {}

fs.WriteStream = WriteStream;
/**
 * @callback statsCallback
 * @param {Error} err - Error if one occurred
 * @param {fs.Stats} stats - file stats
 */

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 * @param {function} callback async callback
 */

fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 */


fs.accessSync = function (path, mode = fs.constants.F_OK) {
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  const fileHandle = getTiFileFromPathLikeValue(path);

  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  } // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?


  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }

  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};
/**
 * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 * @param {Function} callback function to call back with error if failed
 */


fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFile(file, data, options, callback);
};
/**
 * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 */


fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFileSync(file, data, options); // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);

fs.chmodSync = unsupportedNoop('fs', 'chmodSync');

fs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);

fs.chownSync = unsupportedNoop('fs', 'chownSync');
/**
 * Callback for functions that can only throw errors
 *
 * @callback errorCallback
 * @param {Error} [err] - Error thrown
 */

/**
 * @param {integer} fd file descriptor
 * @param {errorCallback} callback callback function
 */

fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 */


fs.closeSync = (fd) => {
  const stream = streamForDescriptor(fd);
  stream.close();
}; // Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */


fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }

  callback = maybeCallback(callback); // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)

  const srcFile = Ti.Filesystem.getFile(src);
  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  const destFile = Ti.Filesystem.getFile(dest);
  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};
/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 */


fs.copyFileSync = function (src, dest, flags = 0) {
  const srcFile = Ti.Filesystem.getFile(src);

  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }

  if (!srcFile.copy(dest)) {
    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?
  }
}; // TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });
// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
 * @param {string} path path to check
 * @param {existsCallback} callback callback function
 * @returns {void}
 */


fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};
/**
 * @param {string} path path to check
 * @returns {boolean} whether a file or directory exists at that path
 */


fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};

fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);

fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');

fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);

fs.fchownSync = unsupportedNoop('fs', 'fchownSync');

fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);

fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');
/**
 * @param {integer} fd file descriptor
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {function} callback async callback function
 */

fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let stats;

    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, stats);
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats} stats for file descriptor
 */


fs.fstatSync = (fd, _options) => {
  const path = pathForFileDescriptor(fd);
  return fs.statSync(path);
}; // TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)
// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!


fs.lstat = (path, options, callback) => fs.stat(path, options, callback);

fs.lstatSync = (path, options) => fs.statSync(path, options);
/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 * @param {errorCallback} callback async callback
 */


fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777 };

  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null);
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 */


fs.mkdirSync = (path, options) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options };

  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777 });

  }

  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    } // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error


    throw noSuchFile('mkdir', path);
  }
};
/**
 * @callback tempDirCallback
 * @param {Error} err - Error if one occurred
 * @param {string} folder - generated folder name
 */

/**
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @param {tempDirCallback} callback async callback
 */


fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });
  // try to be all async

  const tryMkdtemp = () => {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;
    fs.mkdir(path, 0o700, (err) => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        } // bubble up error


        callback(err);
        return;
      } // succeeded! Hurray!


      callback(null, path);
    });
  };

  setTimeout(tryMkdtemp, 1);
};
/**
 * Creates a unique temporary directory.
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @returns {string} path to created directory
 */


fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });

  let retryCount = 0;
  const MAX_RETRIES = 100;

  while (retryCount < MAX_RETRIES) {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;

    try {
      fs.mkdirSync(path, 0o700); // don't try recursive

      return path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      } // name was not unique, so retry


      retryCount++;
    }
  }

  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);
};
/**
 * @callback fileDescriptorCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} fileDescriptor - generated file descriptor
 */

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [mode=0o666] file mode to use when creating file
 * @param {fileDescriptorCallback} callback async callback
 */


fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let fileDescriptor;

    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, fileDescriptor);
  }, 1);
};
/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [_mode=0o666] file mode to use when creating file
 * @returns {integer}
 */


fs.openSync = (path, flags = 'r', _mode = 0o666) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');

    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }

      throw new Error(`failed to create file at path ${path}`);
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }

    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }

  const tiMode = FLAGS_TO_TI_MODE.get(flags);

  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    const err = new TypeError(`The value "${String(flags)}" is invalid for option "flags"`);
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }

  return createFileDescriptor(path, tiFile.open(tiMode));
};
/**
 * @callback readCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} bytesRead - number of bytes read
 * @param {Buffer} buffer buffer
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} position where to begin reading from in the file
 * @param {readCallback} callback async callback
 */


fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  const tiFileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  tiFileStream.read(buffer.toTiBuffer(), offset, length, (readObj) => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }

    callback(null, readObj.bytesProcessed, buffer);
  });
};
/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} _position where to begin reading from in the file
 * @returns {integer} bytes read
 */


fs.readSync = (fd, buffer, offset, length, _position) => {
  const fileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  return fileStream.read(buffer.toTiBuffer(), offset, length);
};
/**
 * @callback filesCallback
 * @param {Error} err - Error if one occurred
 * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
 */

/**
 * @param {string} path directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @param {filesCallback} callback async callback
 */


fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let result;

    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, result);
  }, 1);
};
/**
 * @param {string} filepath directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @returns {string[]|Buffer[]|fs.Dirent[]}
 */


fs.readdirSync = (filepath, options) => {
  const file = getTiFileFromPathLikeValue(filepath);

  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }

  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }

  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false });

  const listing = file.getDirectoryListing();

  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map((name) => Buffer.from(name));
  }

  return listing;
};
/**
 * @callback readFilePostOpenCallback
 * @param {Error} err - Error if one occurred
 * @param {Ti.Buffer} buffer
 */

/**
 * @param {integer} fileDescriptor file descriptor
 * @param {readFilePostOpenCallback} callback async callback
 */


function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }

    const fileSize = stats.size; // Create a Ti.Buffer to read into

    const buffer = Ti.createBuffer({
      length: fileSize });
    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!

    const sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, (readAllObj) => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }

      callback(null, buffer);
    });
  });
}
/**
 * @callback readFileCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} data
 */

/**
 * Asynchronously read entire contents of file
 * @param {string|Buffer|URL|integer} path filename or file descriptor
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @param {readFileCallback} callback async callback
 */


fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r' };

  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r' });

  }

  callback = maybeCallback(callback);
  const wasFileDescriptor = typeof path === 'number';
  let fileDescriptor = path; // may be overriden later

  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */

  const handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    } // fs.closeSync if it was not originally a file descriptor


    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    } // TODO: trim buffer if we didn't read full size?


    callback(null, encodeBuffer(options.encoding, buffer));
  };

  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};
/**
 * Returns the contents of the path.
 * @param {string|Buffer|URL|integer} path path to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
 */


fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r' });

  const wasFileDescriptor = typeof path === 'number';
  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  const tiFileStream = streamForDescriptor(fileDescriptor); // Just use our own API that reads full stream in

  const buffer = Ti.Stream.readAll(tiFileStream); // fs.closeSync if it was not originally a file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  } // TODO: trim buffer if we didn't read full size?


  return encodeBuffer(options.encoding, buffer);
}; // TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */

/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] optiosn object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @param {realpathCallback} callback async callback
 */


fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });

  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    const result = path.normalize(filepath);
    fs.exists(result, (resultExists) => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }

        return callback(null, result);
      } // this path doesn't exist, try each segment until we find first that doesn't


      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?

      let partialFilePath = '';
      let index = 0; // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case

      if (segments[index].length === 0) {
        index++;
      }

      setTimeout(tryPath, 1);

      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        } // grab next segment


        const segment = segments[index++];

        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        } // normal case


        partialFilePath += path.sep + segment; // check if path up to this point exists...

        fs.exists(partialFilePath, (partialExists) => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          } // try again at next depth of dir tree


          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};

fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};
/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] options object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @returns {string|Buffer}
 */


fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.

  const result = path.normalize(filepath);

  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    const segments = result.split(path.sep);
    let partialFilePath = '';

    for (const segment of segments) {
      if (segment.length === 0) {
        continue;
      }

      partialFilePath += path.sep + segment;

      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }

  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }

  return result;
};

fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};
/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 * @param {errorCallback} callback async callback
 */


fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 */


fs.renameSync = (oldPath, newPath) => {
  const tiFile = getTiFileFromPathLikeValue(oldPath); // src doesn't actually exist?

  if (!tiFile.exists()) {
    const err = noSuchFile('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  const destFile = getTiFileFromPathLikeValue(newPath);

  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    const err = illegalOperationOnADirectory('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  let tempPath;

  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));
    destFile.move(tempPath);
  }

  let success = false;

  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, (_err) => {});
      } else {
        // move it back, because we failed!
        const tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */


fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 */


fs.rmdirSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    } // is it a file?


    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    } // is it not empty?


    const subFiles = tiFile.getDirectoryListing();

    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {statsCallback} callback async callback
 */


fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
 * @param {string|Buffer|URL|integer} path filepath or file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats}
 */


fs.statSync = (path, _options) => new fs.Stats(path);

fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);

fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');
/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 * @param {errorCallback} callback async callback
 */

fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);

  if (typeof len !== 'number') {
    len = 0;
  }

  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file

    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }

    const buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }

      fs.close(fd, (err) => {
        if (err) {
          return callback(err);
        }

        fs.writeFile(path, buffer, callback);
      });
    });
  });
};
/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 */


fs.truncateSync = (path, len = 0) => {
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  const fd = fs.openSync(path);
  const buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};
/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */


fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }

    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @returns {undefined}
 */


fs.unlinkSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }

    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};

fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');

fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);

fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');
/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string|null} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 * @param {errorCallback} callback async callback
 */

fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  let fileDescriptor = file; // may be overriden later

  const finish = (err) => {
    if (err) {
      callback(err);
      return;
    }

    if (wasFileDescriptor) {
      callback();
      return;
    } // fs.close if it was not originally a file descriptor


    fs.close(fileDescriptor, callback);
  };

  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};
/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 */


fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode); // if data is a string, make it a buffer first

  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data); // close if user didn't give us file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};
/**
 * @callback writeTiFileStreamCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 */

/**
 * @param {Ti.Filesystem.FileStream} tiFileStream file stream
 * @param {Buffer} buffer buffer we're writing
 * @param {writeTiFileStreamCallback} callback async callback
 */


function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), (writeObj) => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }

    callback(null, writeObj.bytesProcessed);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write: Buffer or string
 * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
 * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
 * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
 * @param {writeCallback} [callback] async callback (if Buffer)
 */


fs.write = (fd, buffer, offset, length, position, callback) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};
/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write
 * @param {integer} [offset] offset from the beginning of the file where this data should be written
 * @param {string|integer} [length]  expected string encoding
 * @param {integer} [position] position
 * @returns {integer} number of bytes written
 */


fs.writeSync = (fd, buffer, offset, length, position) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }

  return writeStringSync(fd, buffer, offset, length);
}; // TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!
// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)
// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */


class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }}


/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */


function pipe(srcStream, destStream, callback) {
  {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  } // iOS has some... issues with writeStream calling the callback every iteration of the loop *and* at the end
}
/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */


function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, (result) => {
    if (!result.success) {
      return callback(new Error(result.error));
    } // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira.appcelerator.org/browse/TIMOB-27320


    callback();
  });
}
/**
 * @param {string|Buffer|URL} path file path
 * @param {Ti.Filesystem.FileStream} fileStream file stream
 * @returns {integer} file descriptor
 */


function createFileDescriptor(path, fileStream) {
  const pointer = fileDescriptorCount++; // increment global counter

  const fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"

  return pointer;
}
/**
 * @param {integer} fd file descriptor
 * @returns {Ti.Filesystem.FileStream} matching stream
 */


function streamForDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}
/**
 * @param {integer} fd file descriptor
 * @returns {string} matching stream
 */


function pathForFileDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}
/**
 * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
 * @param {*} options user-supplied options
 * @param {object} defaults defaults to use
 * @return {object}
 */


function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }

  const optionsType = typeof options;

  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;

    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      const merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;

    case 'object':
      return options;

    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}
/**
 * Enforces that we have a valid callback function. Throws TypeError if not.
 * @param {*} cb possible callback function
 * @returns {Function}
 * @throws {TypeError}
 */


function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }

  const err = new TypeError(`Callback must be a function. Received ${cb}`);
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}
/**
 * returns randomly generated characters of given length 1-16
 * @param {integer} length 1 - 16
 * @param {string} [_encoding='utf8'] encoding of the string generated
 * @returns {string}
 */


function randomCharacters(length, _encoding = 'utf8') {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}

function makeError(code, message, errno, syscall, path) {
  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}
/**
 * @param {string} encoding what we're encoding to
 * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
 * @returns {Buffer} node-compatible Buffer instance
 */


function encodeBuffer(encoding, tiBuffer) {
  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      // In this case we're always reading a file into a Ti.Buffer
      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it
      // Go the faster path by converting to ArrayBuffer and wrapping that
      // TODO: Explicitly release the blob after conversion?
      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());

    default:
      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases
      // so I don't think there's much benefit from converting to ArrayBuffer first
      return Buffer.from(tiBuffer).toString(encoding);}

}
/**
 * @param {string|Buffer|URL} path file path
 * @return {Ti.Filesystem.File}
 */


function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  } // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet


  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}
/**
 * @callback writeBufferCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {Buffer} buffer - original Buffer being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {writeBufferCallback} callback async callback
 */


function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);

  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }

  if (typeof position !== 'number') {
    position = null;
  } // ok now what?


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, buffer);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @returns {integer} number of bytes written
 */


function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  return tiFileStream.write(buffer.toTiBuffer());
}
/**
 * @callback writeStringCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {string} string - original string being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @param {writeStringCallback} [callback] async callback
 */


function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position); // position could be: number, function (callback)

  if (typeof position !== 'number') {
    position = null;
  } // encoding could be: function (callback) or string


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, string);
  });
}
/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @returns {integer} number of bytes written
 */


function writeStringSync(fd, string, position, encoding) {

  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  return tiFileStream.write(buffer.toTiBuffer());
}

function Stream(_opts) {
  // FIXME: Can't call EventEmitter as a function!
  this._eventsToListeners = {};
  this._maxListeners = undefined; // EventEmitter.call(this, opts);
  // TODO: Provide more than an empty class?
}

Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter); // Use util.inherits?

function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  } // TODO: readableState?


  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') {
      this._read = options.read;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
  }

  Stream.call(this);
}

util.inherits(Readable, Stream);

Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

Readable.prototype._read = function (_n) {
  throw new Error('method not implemented: _read()');
};

function Writable(options) {
  const isDuplex = this instanceof Duplex;

  if (!isDuplex && !(this instanceof Writable)) {
    return new Writable(options);
  }

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') {
      this._write = options.write;
    }

    if (typeof options.writev === 'function') {
      this._writev = options.writev;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }

    if (typeof options.final === 'function') {
      this._final = options.final;
    }
  }

  Stream.call(this);
}

util.inherits(Writable, Stream);

function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }

  Readable.call(this, options);
  Writable.call(this, options); // TODO: Provide more than an empty class!

  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }

    if (options.writable === false) {
      this.writable = false;
    }

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false; // this.once('end', onend);
    }
  }
}

util.inherits(Duplex, Readable); // Copy Writable methods to Duplex (basically the odd double-inheritance)

const writableMethods = Object.keys(Writable.prototype);

for (let i = 0; i < writableMethods.length; i++) {
  const method = writableMethods;

  if (!Duplex.prototype[method]) {
    Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }

  Duplex.call(this, options); // TODO: Provide more than an empty class!

  if (options) {
    if (typeof options.transform === 'function') {
      this._transform = options.transform;
    }

    if (typeof options.flush === 'function') {
      this._flush = options.flush;
    }
  } // When the writable side finishes, then flush out anything remaining.
  // this.on('prefinish', prefinish);

}

util.inherits(Transform, Duplex);
Stream.Stream = Stream; // legacy compat

Stream.Transform = Transform;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex; // Stream.PassThrough = PassThrough;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs);
register('stream', Stream); // Register require('buffer').Buffer as global

global.Buffer = BufferModule.Buffer;

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * Description:
 * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
 * The main intention of this feature is to allow JavaScript files to kick-off functionality or
 * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
 * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
 *
 * Use-Cases:
 * - Automatically kick-off analytics functionality on app startup.
 * - Ensure "Google Play Services" is installed/updated on app startup on Android.
 */

/**
 * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
 * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
 * This JSON file, if provided, must be in the same directory as this script.
 * @returns {string[]}
 * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
 * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
 * Returns null if JSON file was not found.
 */
function fetchScriptsFromJson() {
  const JSON_FILE_NAME = 'bootstrap.json';

  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);

    if (jsonFile.exists()) {
      const settings = JSON.parse(jsonFile.read().text);

      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }

      return [];
    }
  } catch (error) {
    Ti.API.error(`Failed to read "${JSON_FILE_NAME}". Reason: ${error.message}`);
  }

  return null;
}
/**
 * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
 * @returns {Array.<string>}
 * Returns an array of require() compatible strings for each bootstrap found in the search.
 * Returns an empty array if no bootstrap files were found.
 */


function fetchScriptsFromResourcesDirectory() {
  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  const bootstrapScripts = [];

  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        const fileNameArray = file.getDirectoryListing();

        if (fileNameArray) {
          for (let index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        let bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }

  loadFrom(resourceDirectory);
  return bootstrapScripts;
}
/**
 * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
 * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
 */


function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  let bootstrapScripts = fetchScriptsFromJson();

  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  } // Do not continue if no bootstraps were found.


  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  } // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.


  bootstrapScripts.sort(); // Loads all bootstrap scripts found.

  function loadBootstrapScripts(finished) {
    let bootstrapIndex = 0;

    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        const fileName = bootstrapScripts[bootstrapIndex];

        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require
        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.


        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        } // We're done with the current bootstrap. Time to load the next one.


        bootstrapIndex++;
      } // Invoke given callback to inform caller that all loading is done.


      finished();
    }

    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }

    doLoad();
  } // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().


  loadBootstrapScripts(finished);
}

/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is loaded on app startup on all platforms. It is used to do the following:
 * - Provide consistent startup behavior between platforms, such as logging Titanium version.
 * - Load Titanium's core JavaScript extensions shared by all platforms.
 * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
 * - Load the app developer's main "app.js" script after doing all of the above.
 */

Ti.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${"10.1.1"}.${"2448cfa671"})`); // Load JS language polyfills
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app'); // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.


  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpLm1haW4uanMiXSwibmFtZXMiOlsiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicmVxdWlyZSIsImNhdGNoIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImRlZmluZVByb3BlcnRpZXMiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT1NfVkVSU0lPTl9NQUpPUiIsIlRpIiwiUGxhdGZvcm0iLCJ2ZXJzaW9uTWFqb3IiLCJPU19WRVJTSU9OX01JTk9SIiwidmVyc2lvbk1pbm9yIiwiT1NfVkVSU0lPTl9QQVRDSCIsInZlcnNpb25QYXRjaCIsImtOb2RlTW9kdWxlc1JFIiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsImZvciIsImlzQnVmZmVyIiwiY29sb3JSZWdFeHAiLCJyZW1vdmVDb2xvcnMiLCJzdHIiLCJyZXBsYWNlIiwiaXNFcnJvciIsImlzTmF0aXZlRXJyb3IiLCJFcnJvciIsImdldFN0cnVjdHVyZWRTdGFjayIsIlN0YWNrVHJhY2VFcnJvciIsInByZXBhcmVTdGFja1RyYWNlIiwiZXJyIiwidHJhY2UiLCJzdGFja1RyYWNlTGltaXQiLCJJbmZpbml0eSIsImlzSW5zaWRlTm9kZU1vZHVsZXMiLCJ1bmRlZmluZWQiLCJzdGFjayIsInN0YWNrRnJhbWVzIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJsaW5lSW5mbyIsIm1hdGNoIiwiZmlsZW5hbWUiLCJwdXNoIiwiZ2V0RmlsZU5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJmcmFtZSIsInRlc3QiLCJqb2luJDEiLCJvdXRwdXQiLCJzZXBhcmF0b3IiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJpIiwidW5jdXJyeVRoaXMiLCJmIiwiY2FsbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiQUxMX1BST1BFUlRJRVMkMiIsIk9OTFlfRU5VTUVSQUJMRSQyIiwicHJvcGVydHlGaWx0ZXIiLCJBTExfUFJPUEVSVElFUyIsIk9OTFlfRU5VTUVSQUJMRSIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsIm9iaiIsImZpbHRlciIsInByb3BzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsImlzQWxsRGlnaXRzIiwicyIsImNvZGUiLCJjaGFyQ29kZUF0IiwiVHlwZWRBcnJheVByb3RvdHlwZSQxIiwiZ2V0UHJvdG90eXBlT2YiLCJVaW50OEFycmF5IiwicHJvdG90eXBlIiwiVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJjaGVja1Byb3RvdHlwZSIsIm5hbWUiLCJ0b1N0cmluZyIsImlzQW55QXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzQXN5bmNGdW5jdGlvbiIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzU3ltYm9sT2JqZWN0IiwiaXNEYXRhVmlldyIsImlzRGF0ZSIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JPYmplY3QiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzTWFwIiwiaXNNYXBJdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiaW5jbHVkZXMiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsImlzU2V0IiwiaXNTZXRJdGVyYXRvciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5IiwiaXNCdWlsdEluVHlwZWRBcnJheSIsImlzVWludDhBcnJheSIsImlzVWludDhDbGFtcGVkQXJyYXkiLCJpc1VpbnQxNkFycmF5IiwiaXNVaW50MzJBcnJheSIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsInR5cGVzIiwiX19wcm90b19fIiwiZXJyb3IiLCJsYXp5RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlRFUk5BTF9BU1NFUlRJT04iLCJhc3NlcnQkMSIsIm1lc3NhZ2UiLCJmYWlsIiwibWVzc2FnZXMiLCJNYXAiLCJTeXN0ZW1FcnJvciIsIkUiLCJzeW0iLCJ2YWwiLCJkZWYiLCJvdGhlckNsYXNzZXMiLCJzZXQiLCJtYWtlTm9kZUVycm9yV2l0aENvZGUiLCJjbGF6eiIsIkJhc2UiLCJOb2RlRXJyb3IiLCJhcmdzIiwiZ2V0TWVzc2FnZSIsImNvbmZpZ3VyYWJsZSIsImFkZENvZGVUb05hbWUiLCJtc2ciLCJleHBlY3RlZExlbmd0aCIsInVuc2hpZnQiLCJmb3JtYXQkMSIsIlJhbmdlRXJyb3IiLCJzdWZmaXgiLCJleHBlY3RlZCIsImFjdHVhbCIsImRldGVybWluZXIiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJvbmVPZiIsInR5cGUiLCJUeXBlRXJyb3IiLCJtYXhTdGFja19FcnJvck5hbWUiLCJtYXhTdGFja19FcnJvck1lc3NhZ2UiLCJpc1N0YWNrT3ZlcmZsb3dFcnJvciIsIm92ZXJmbG93U3RhY2siLCJ0aGluZyIsImxlbiIsIm1hcCIsIlN0cmluZyIsInNsaWNlIiwiam9pbiIsIkZhc3RCdWZmZXIiLCJzdHJpbmdUb0hleEJ5dGVzIiwiYnl0ZUFycmF5IiwibnVtZXJpY1ZhbHVlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJOdW1iZXIiLCJpc05hTiIsImFycmF5SW5kZXhIYW5kbGVyIiwidGFyZ2V0IiwicHJvcEtleSIsInJlY2VpdmVyIiwibnVtIiwiaXNTYWZlSW50ZWdlciIsImdldEFkanVzdGVkSW5kZXgiLCJSZWZsZWN0Iiwic2V0QWRqdXN0ZWRJbmRleCIsImhhcyIsIl90aUJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJ0aUJ1ZmZlciIsInN0YXJ0IiwiYnl0ZU9mZnNldCIsImZyb21UaUJ1ZmZlciIsIlByb3h5IiwiZnJvbVN0cmluZyIsImVuY29kaW5nIiwiQnVmZmVyIiwiaXNFbmNvZGluZyIsInRvTG93ZXJDYXNlIiwiYmxvYiIsIlV0aWxzIiwiYmFzZTY0ZGVjb2RlIiwiYmxvYlN0cmVhbSIsIlN0cmVhbSIsImNyZWF0ZVN0cmVhbSIsInNvdXJjZSIsIm1vZGUiLCJNT0RFX1JFQUQiLCJidWZmZXIiLCJyZWFkQWxsIiwiY2xvc2UiLCJieXRlcyIsImNyZWF0ZUJ1ZmZlciIsImdldFRpQ29kZWNDaGFyc2V0IiwiZnJvbSIsIl9zbGljZSIsIm9mZnNldCIsIl9maWxsIiwiZW5kIiwidmFsdWVUeXBlIiwiYnVmVG9GaWxsV2l0aCIsImZpbGxCdWZMZW5ndGgiLCJmaWxsIiwiZmlsbENoYXIiLCJpbmRleCIsInNyYyIsIm51bUJ5dGVzIiwidG9UaUJ1ZmZlciIsImNsb25lIiwiYnVmIiwiVElfQ09ERUNfTUFQIiwiQ29kZWMiLCJDSEFSU0VUX1VURjgiLCJDSEFSU0VUX1VURjE2TEUiLCJDSEFSU0VUX0lTT19MQVRJTl8xIiwiQ0hBUlNFVF9BU0NJSSIsIkFMTF9QUk9QRVJUSUVTJDEiLCJPTkxZX0VOVU1FUkFCTEUkMSIsIlZBTElEX0VOQ09ESU5HUyIsImRvdWJsZUFycmF5IiwiRmxvYXQ2NEFycmF5IiwidWludDhEb3VibGVBcnJheSIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ1aW50OEZsb2F0QXJyYXkiLCJCdWZmZXIkMSIsInBvb2xTaXplIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFwaU5hbWUiLCJzaG93RmxhZ2dlZERlcHJlY2F0aW9uIiwiYWxsb2MiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXkiLCJmcm9tQnVmZmVyIiwibWF4TGVuZ3RoIiwiYnl0ZUxlbmd0aCIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsInRvQXJyYXlCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJzZXRQcm90b3R5cGVPZiIsImNvbXBhcmUiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsInNvdXJjZVN0YXJ0Iiwic291cmNlRW5kIiwiYnVmMSIsInNvdXJjZUxlbmd0aCIsImRlc3QiLCJkZXN0TGVuZ3RoIiwiTWF0aCIsIm1pbiIsInRhcmdldFZhbHVlIiwic291cmNlVmFsdWUiLCJyZW1haW5pbmciLCJzb3VyY2VMZW4iLCJlbnRyaWVzIiwibmV4dEluZGV4IiwiZW50cnlJdGVyYXRvciIsIm5leHQiLCJyZXN1bHQiLCJkb25lIiwiaXRlcmF0b3IiLCJlcXVhbHMiLCJvdGhlckJ1ZmZlciIsIm9mZnNldFR5cGUiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGgiLCJUeXBlZEFycmF5RmlsbCIsImJ5dGVMZW4iLCJmaWxsTGVuZ3RoIiwiaW5kZXhPZiIsIm1hdGNoTGVuZ3RoIiwiY3VycmVudEluZGV4IiwidGhpc0xlbmd0aCIsImZpcnN0TWF0Y2giLCJmaXJzdEJ5dGVNYXRjaCIsIngiLCJteUl0ZXJhdG9yIiwicmVhZERvdWJsZUJFIiwiY2hlY2tPZmZzZXQiLCJyZWFkRG91YmxlTEUiLCJyZWFkRmxvYXRCRSIsInJlYWRGbG9hdExFIiwicmVhZEludDgiLCJ1bnNpZ25lZFZhbHVlIiwicmVhZFVJbnQ4IiwidW5zaWduZWRUb1NpZ25lZCIsInJlYWRJbnQxNkJFIiwicmVhZFVJbnQxNkJFIiwicmVhZEludDE2TEUiLCJyZWFkVUludDE2TEUiLCJyZWFkSW50MzJCRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnQzMkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZEludEJFIiwicmVhZFVJbnRCRSIsInJlYWRJbnRMRSIsInJlYWRVSW50TEUiLCJtdWx0aXBsaWVyIiwic3ViYXJyYXkiLCJzd2FwMTYiLCJmaXJzdCIsInNlY29uZCIsInN3YXAzMiIsInRoaXJkIiwiZm91cnRoIiwic3dhcDY0IiwiZmlmdGgiLCJzaXh0aCIsInNldmVudGgiLCJlaWdodGgiLCJ0b0pTT04iLCJkYXRhIiwiYmFzZTY0ZW5jb2RlIiwidG9CbG9iIiwiaGV4U2xpY2UiLCJsYXRpbjFTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhc2NpaSIsInVjczJTbGljZSIsImhleFN0ciIsImhleCIsIm91dCIsImJ5dGUxIiwiYnl0ZTIiLCJjb2RlX3VuaXQiLCJmcm9tQ29kZVBvaW50IiwiY29weUJ1ZmZlciIsInNyY0xlbmd0aCIsImRlc3RJbmRleCIsInZhbHVlcyIsIndyaXRlIiwic3RyaW5nIiwid3JpdGVEb3VibGVCRSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUludDgiLCJjaGVja1ZhbHVlIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQzMkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnRCRSIsIm1pbk1heEJhc2UiLCJwb3ciLCJieXRlVmFsdWUiLCJ3cml0ZUludExFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludExFIiwiYWxsb2NVbnNhZmVTbG93IiwidXRmOEJ5dGVMZW5ndGgiLCJjaGFyQXQiLCJmbG9vciIsImJ1ZjIiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJwb3NpdGlvbiIsIklOU1BFQ1RfTUFYX0JZVEVTIiwicmVjdXJzZVRpbWVzIiwiY3R4IiwibWF4IiwiYWN0dWFsTWF4IiwidHJpbSIsImV4dHJhcyIsInNob3dIaWRkZW4iLCJyZWR1Y2UiLCJpbnNwZWN0IiwiYnJlYWtMZW5ndGgiLCJjb21wYWN0IiwiQXJyYXlCdWZmZXJJc1ZpZXciLCJCdWZmZXJNb2R1bGUiLCJ0cmFuc2NvZGUiLCJfc291cmNlIiwiX2Zyb21FbmNvZGluZyIsIl90b0VuY29kaW5nIiwia01heExlbmd0aCIsImtTdHJpbmdNYXhMZW5ndGgiLCJjb25zdGFudHMiLCJNQVhfTEVOR1RIIiwiTUFYX1NUUklOR19MRU5HVEgiLCJzaW5nbGVCeXRlIiwiYml0TGVuZ3RoIiwibWF4UG9zaXRpdmVWYWx1ZSIsIm1heFVuc2lnbmVkVmFsdWUiLCJyZWxlYXNlIiwiZW5kT2Zmc2V0IiwiYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkIiwibm9kZU1vZHVsZXNDaGVja0NvdW50ZXIiLCJidWZmZXJXYXJuaW5nIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiQm9vbGVhblByb3RvdHlwZSIsIkJvb2xlYW4iLCJEYXRlUHJvdG90eXBlIiwiRGF0ZSIsIkVycm9yUHJvdG90eXBlIiwiTnVtYmVyUHJvdG90eXBlIiwiTWFwUHJvdG90eXBlIiwiUmVnRXhwUHJvdG90eXBlIiwiUmVnRXhwIiwiU3RyaW5nUHJvdG90eXBlIiwiU2V0UHJvdG90eXBlIiwiU2V0IiwiU3ltYm9sUHJvdG90eXBlIiwiaXNJb3MiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJidWlsdEluT2JqZWN0cyIsImluc3BlY3REZWZhdWx0T3B0aW9ucyIsInNlYWwiLCJkZXB0aCIsImNvbG9ycyIsImN1c3RvbUluc3BlY3QiLCJzaG93UHJveHkiLCJtYXhBcnJheUxlbmd0aCIsInNvcnRlZCIsImdldHRlcnMiLCJrT2JqZWN0VHlwZSIsImtBcnJheVR5cGUiLCJrQXJyYXlFeHRyYXNUeXBlIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHBTaW5nbGUiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZSIsImtleVN0clJlZ0V4cCIsIm51bWJlclJlZ0V4cCIsIm5vZGVNb2R1bGVzUmVnRXhwIiwia01pbkxpbmVMZW5ndGgiLCJrV2VhayIsImtJdGVyYXRvciIsImtNYXBFbnRyaWVzIiwibWV0YSIsImdldFVzZXJPcHRpb25zIiwic3R5bGl6ZSIsInVzZXJPcHRpb25zIiwib3B0cyIsImJ1ZGdldCIsImluZGVudGF0aW9uTHZsIiwic2VlbiIsImN1cnJlbnREZXB0aCIsInN0eWxpemVOb0NvbG9yIiwib3B0S2V5cyIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsImN1c3RvbSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJib2xkIiwiaXRhbGljIiwidW5kZXJsaW5lIiwiaW52ZXJzZSIsIndoaXRlIiwiZ3JleSIsImJsYWNrIiwiYmx1ZSIsImN5YW4iLCJncmVlbiIsIm1hZ2VudGEiLCJyZWQiLCJ5ZWxsb3ciLCJzdHlsZXMiLCJzcGVjaWFsIiwibnVtYmVyIiwiYmlnaW50IiwiYm9vbGVhbiIsIm51bGwiLCJzeW1ib2wiLCJkYXRlIiwicmVnZXhwIiwibW9kdWxlIiwiYWRkUXVvdGVzIiwicXVvdGVzIiwiZXNjYXBlRm4iLCJzdHJFc2NhcGUiLCJlc2NhcGVUZXN0IiwiZXNjYXBlUmVwbGFjZSIsInNpbmdsZVF1b3RlIiwibGFzdCIsInBvaW50Iiwic3R5bGVUeXBlIiwic3R5bGUiLCJjb2xvciIsImdldEVtcHR5Rm9ybWF0QXJyYXkiLCJnZXRDb25zdHJ1Y3Rvck5hbWUiLCJfY3R4IiwiZmlyc3RQcm90byIsImRlc2NyaXB0b3IiLCJnZXRQcmVmaXgiLCJ0YWciLCJmYWxsYmFjayIsImdldEtleXMiLCJzeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0Q3R4U3R5bGUiLCJmaW5kVHlwZWRDb25zdHJ1Y3RvciIsImNoZWNrIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJsYXp5TnVsbFByb3RvdHlwZUNhY2hlIiwiY2xhenpXaXRoTnVsbFByb3RvdHlwZSIsImNhY2hlZENsYXNzIiwiTnVsbFByb3RvdHlwZSIsIm5vUHJvdG90eXBlSXRlcmF0b3IiLCJuZXdWYWwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZm9ybWF0UmF3IiwidHlwZWRBcnJheSIsImZvcm1hdFByaW1pdGl2ZSIsImNvbnRleHQiLCJtYXliZUN1c3RvbSIsInJldCIsInJlcGVhdCIsImNpcmN1bGFyIiwic2l6ZSIsImJhc2UiLCJmb3JtYXR0ZXIiLCJicmFjZXMiLCJub0l0ZXJhdG9yIiwiZXh0cmFzVHlwZSIsInByZWZpeCIsImZvcm1hdEFycmF5IiwiZm9ybWF0U2V0IiwiZm9ybWF0TWFwIiwiZm9ybWF0VHlwZWRBcnJheSIsImdldEl0ZXJhdG9yQnJhY2VzIiwiZm9ybWF0SXRlcmF0b3IiLCJnZXRGdW5jdGlvbkJhc2UiLCJyZWdFeHAiLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRFcnJvciIsIm5hdGl2ZUVycm9yUHJvcHMiLCJldmVyeSIsImFycmF5VHlwZSIsImZvcm1hdEFycmF5QnVmZmVyIiwiZm9ybWF0TnVtYmVyIiwiZm9ybWF0UHJvbWlzZSIsImZvcm1hdFdlYWtTZXQiLCJmb3JtYXRXZWFrQ29sbGVjdGlvbiIsImZvcm1hdFdlYWtNYXAiLCJnZXRCb3hlZEJhc2UiLCJzcGVjaWFsSXRlcmF0b3IiLCJjb25zdHJ1Y3Rvck5hbWUiLCJmb3JtYXRQcm9wZXJ0eSIsImhhbmRsZU1heENhbGxTdGFja1NpemUiLCJyZWZlcmVuY2UiLCJwb3AiLCJjb21wYXJhdG9yIiwic29ydCIsInNwbGljZSIsInJlcyIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwibmV3TGVuZ3RoIiwiZm4iLCJ2YWx1ZU9mIiwic3RhY2tMaW5lIiwiYXRTeW1ib2xJbmRleCIsInNvdXJjZVBhdHRlcm4iLCJzeW1ib2xOYW1lIiwic291cmNlTWF0Y2giLCJmaWxlUGF0aCIsImxpbmVOdW1iZXIiLCJjb2x1bW4iLCJGaWxlc3lzdGVtIiwicmVzb3VyY2VzRGlyZWN0b3J5IiwicG9zIiwic3RhY2tTdGFydCIsIm5ld1N0YWNrIiwibm9kZU1vZHVsZSIsImV4ZWMiLCJpbmRlbnRhdGlvbiIsIl92YWx1ZSIsIl9yZWN1cnNlVGltZXMiLCJleHRyYSIsImRlc2MiLCJkaWZmIiwibGFiZWwiLCJzcCIsInRtcCIsInByaW1pdGl2ZSIsImdyb3VwQXJyYXlFbGVtZW50cyIsIm91dHB1dExlbmd0aCIsInNlcGFyYXRvclNwYWNlIiwiZGF0YUxlbiIsImFwcHJveENoYXJIZWlnaHRzIiwiYXZlcmFnZUJpYXMiLCJzcXJ0IiwiYmlhc2VkTWF4IiwiY29sdW1ucyIsInJvdW5kIiwibWF4TGluZUxlbmd0aCIsImxpbmVNYXhMZW5ndGgiLCJqIiwib3JkZXIiLCJwYWRkaW5nIiwicGFkU3RhcnQiLCJpcyIsImZvcm1hdEJpZ0ludCIsImZvcm1hdFNwZWNpYWxBcnJheSIsImVtcHR5SXRlbXMiLCJlbmRpbmciLCJ2YWxMZW4iLCJlbGVtZW50Rm9ybWF0dGVyIiwidiIsImZvcm1hdFNldEl0ZXJJbm5lciIsInN0YXRlIiwiZm9ybWF0TWFwSXRlcklubmVyIiwiX2tleXMiLCJpc0tleVZhbHVlIiwiY3VycmVudEVudHJ5IiwiaXNCZWxvd0JyZWFrTGVuZ3RoIiwibG4iLCJmb3JtYXRXaXRoT3B0aW9ucyIsImZpcnN0RXJyb3JMaW5lIiwiQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSIsInRyeVN0cmluZ2lmeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJhIiwiaW5zcGVjdE9wdGlvbnMiLCJ0ZW1wU3RyIiwibGFzdFBvcyIsIm5leHRDaGFyIiwidGVtcEFyZyIsImNvbnN0ciIsInRlbXBOdW0iLCJ0ZW1wSW50ZWdlciIsInRlbXBGbG9hdCIsInBhcnNlRmxvYXQiLCJub29wJDEiLCJsb2dUaW1lIiwibG9nRGF0YSIsInN0YXJ0VGltZSIsIl90aW1lcyIsImR1cmF0aW9uIiwibm93IiwibG9nIiwia0NvbG9ySW5zcGVjdE9wdGlvbnMiLCJrTm9Db2xvckluc3BlY3RPcHRpb25zIiwidGFibGVXYXJuZWQiLCJjcmVhdGVXcml0ZUVycm9ySGFuZGxlciIsInN0cmVhbSIsIl93cml0YWJsZVN0YXRlIiwiZXJyb3JFbWl0dGVkIiwibGlzdGVuZXJDb3VudCIsIm9uY2UiLCJDb25zb2xlIiwic3RkZXJyIiwiaWdub3JlRXJyb3JzIiwiX2FwaU1vZHVsZSIsInN0ZG91dCIsIl9zdGRvdXQiLCJfc3RkZXJyIiwiX2lnbm9yZUVycm9ycyIsIl9zdGRvdXRFcnJvckhhbmRsZXIiLCJfc3RkZXJyRXJyb3JIYW5kbGVyIiwiX2NvbG9yTW9kZSIsImNvbG9yTW9kZSIsIl9pbnNwZWN0T3B0aW9ucyIsIl9jb3VudHMiLCJfZ3JvdXBJbmRlbnQiLCJfd3JpdGVUb0NvbnNvbGUiLCJsZXZlbCIsInVzZVN0ZEVyciIsImVycm9ySGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwiaW5mbyIsIndhcm4iLCJkZWJ1ZyIsImNsZWFyIiwiZ3JvdXAiLCJncm91cEVuZCIsImRpciIsImFzc2VydCIsImNvdW50IiwiY291bnRSZXNldCIsImRlbGV0ZSIsInRpbWUiLCJ0aW1lRW5kIiwid2FybmVkIiwidGltZUxvZyIsInRhYmxlIiwiZGlyeG1sIiwiZ3JvdXBDb2xsYXBzZWQiLCJnbG9iYWxDb25zb2xlIiwiQVBJIiwiY29uc29sZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInByb3BlcnRpZXMiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJfbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbSIsIm9sZE9wdGlvbnMiLCJkYXRlU3R5bGUiLCJtb250aCIsImRheSIsInllYXIiLCJkZWZhdWx0T3B0aW9ucyIsImxvY2FsZSIsImZvcm1hdCIsInRvTG9jYWxlVGltZVN0cmluZyIsInRpbWVTdHlsZSIsImhvdXIiLCJtaW51dGUiLCJ0b0xvY2FsZVN0cmluZyIsImhhc09wdGlvbiIsIndlZWtkYXkiLCJtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tIiwic3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIiwic3VwcG9ydGVkTG9jYWxlcyIsIlRpQ29sbGF0b3IiLCJMb2NhbGUiLCJnZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXMiLCJjb2xsYXRvciIsIkNvbGxhdG9yIiwiYmluZCIsInN1cHBvcnRlZExvY2FsZXNPZiIsIlRpRGF0ZVRpbWVGb3JtYXQiLCJnZXRTdXBwb3J0ZWREYXRlVGltZUZvcm1hdExvY2FsZXMiLCJUaU51bWJlckZvcm1hdCIsImdldFN1cHBvcnRlZE51bWJlckZvcm1hdExvY2FsZXMiLCJOdW1iZXJGb3JtYXQiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwibG9jYWxlQ29tcGFyZSIsImNvbXBhcmVTdHJpbmciLCJsb2NhbGVzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJtYWtlTG93ZXJDYXNlIiwidG9Mb2NhbGVVcHBlckNhc2UiLCJtYWtlVXBwZXJDYXNlIiwiYmluZGluZ3MiLCJyZWRpcmVjdHMiLCJpc0hpamFja2FibGVNb2R1bGVJZCIsInBhdGgiLCJmaXJzdENoYXIiLCJvcmlnaW5hbFJlcXVpcmUiLCJtYWluIiwibW9kdWxlSWQiLCJvcmlnaW5hbE1vZHVsZVJlcXVpcmUiLCJNb2R1bGUiLCJyZWdpc3RlciIsImJpbmRpbmciLCJyZWRpcmVjdCIsImZpbGVwYXRoIiwiVGl0YW5pdW0iLCJBY3Rpdml0eSIsImtleUNvdW50Iiwic2VyaWFsaXplZCIsIlByb3BlcnRpZXMiLCJBcHAiLCJudWxsT3JEZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJwcm9wZXJ0eUdldHRlciIsImRlbGVnYXRlIiwiaGFzUHJvcGVydHkiLCJnZXR0ZXIiLCJnZXRMaXN0IiwiZ2V0T2JqZWN0IiwicGFyc2UiLCJnZXRTdHJpbmciLCJzZXRMaXN0Iiwic2V0T2JqZWN0Iiwic2V0U3RyaW5nIiwiQmxvYlByb3RvdHlwZSIsInJlamVjdCIsIndyYXBwZWRHZXRTdHJpbmciLCJkZWZhdWx0VmFsdWVUeXBlIiwiTCIsIlBlcnNpc3RlbnRIYW5kbGUiLCJvYmplY3QiLCJjZWxsIiwibGFzdElkIiwib2JqZWN0cyIsImRpc3Bvc2UiLCJIVFRQQ2xpZW50IiwiTmV0d29yayIsIl9zZW5kIiwic2VuZCIsImhhbmRsZSIsIm9uIiwia3JvbGwiLCJEQkciLCJpUGhvbmVDb25zdGFudCIsIlVJIiwiaVBob25lIiwiQWN0aXZpdHlJbmRpY2F0b3JTdHlsZSIsIkJJRyIsIkRBUksiLCJBbmltYXRpb25TdHlsZSIsIkZMSVBfRlJPTV9MRUZUIiwiUHJvZ3Jlc3NCYXJTdHlsZSIsIlNJTVBMRSIsIlN5c3RlbUJ1dHRvbiIsIkZMRVhJQkxFX1NQQUNFIiwiRElTQ0xPU1VSRSIsIlN5c3RlbUJ1dHRvblN0eWxlIiwiQkFSIiwiVGFibGVWaWV3Q2VsbFNlbGVjdGlvblN0eWxlIiwiTk9ORSIsIlRhYmxlVmlld1NlcGFyYXRvclN0eWxlIiwiUm93QW5pbWF0aW9uU3R5bGUiLCJUYWJsZVZpZXdTY3JvbGxQb3NpdGlvbiIsIk1JRERMRSIsIlRhYmxlVmlld1N0eWxlIiwiR1JPVVBFRCIsIkxpc3RWaWV3IiwiZGVmYXVsdFRlbXBsYXRlIiwiaGVpZ2h0IiwiY2hpbGRUZW1wbGF0ZXMiLCJiaW5kSWQiLCJsZWZ0Iiwid2lkdGgiLCJyaWdodCIsImNyZWF0ZUxpc3RWaWV3IiwidGVtcGxhdGVzIiwiTElTVF9JVEVNX1RFTVBMQVRFX0RFRkFVTFQiLCJjdXJyZW50VGVtcGxhdGUiLCJwcm9jZXNzVGVtcGxhdGUiLCJwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMiLCJjZWxsUHJveHkiLCJjcmVhdGVMaXN0SXRlbSIsImV2ZW50cyIsInRpUHJveHkiLCJhZGRFdmVudExpc3RlbmVycyIsImNoaWxkUHJvcGVydGllcyIsImNoaWxkIiwicHJveHlUeXBlIiwiY3JlYXRpb25Qcm9wZXJ0aWVzIiwiY3JlYXRpb25GdW5jdGlvbiIsImxvb2t1cCIsImNoaWxkUHJveHkiLCJwcm94eSIsImV2ZW50TmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJsb29rdXBQcm94eUNvbnN0cnVjdG9yIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlSW5kZXgiLCJsYXN0SW5kZXhPZiIsInByb3h5TmFtZSIsInBhcmVudE5hbWVzcGFjZSIsInN1YnN0cmluZyIsInNlZ21lbnRzIiwicGFyZW50UHJveHkiLCJtZXRob2QiLCJ3aWRnZXQiLCJwYXJhbWV0ZXJzIiwiZ2V0VmlldyIsIk5hdmlnYXRpb25XaW5kb3ciLCJIRVhfM19SRUdFWCIsIkhFWF80X1JFR0VYIiwiSEVYXzZfUkVHRVgiLCJIRVhfOF9SRUdFWCIsInBhZGRlZEhleCIsImludGVnZXIiLCJDb2xvciIsInIiLCJnIiwiYiIsImFscGhhIiwiaXNPcGFxdWUiLCJhbHBoYUhleCIsIl90b1JHQkhleFN0cmluZyIsInRvUkdCQUhleFN0cmluZyIsInRvQVJHQkhleFN0cmluZyIsInRvSGV4IiwidG9SR0JBU3RyaW5nIiwidG9GaXhlZCIsImZyb21IZXg2U3RyaW5nIiwic3RhcnRJbmRleCIsImZyb21IZXg4U3RyaW5nIiwiZnJvbVNlbWFudGljQ29sb3JzRW50cnkiLCJlbnRyeSIsImhhZEFscGhhIiwibSIsInVzZXJJbnRlcmZhY2VTdHlsZSIsIlVTRVJfSU5URVJGQUNFX1NUWUxFX0RBUksiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUIiwiY29sb3JzZXQiLCJmZXRjaFNlbWFudGljQ29sb3IiLCJjb2xvck5hbWUiLCJjb2xvcnNldEZpbGVOYW1lIiwiY29sb3JzZXRGaWxlIiwiZ2V0RmlsZSIsImV4aXN0cyIsImNvbG9yQXJyYXkiLCJjb2xvclR5cGUiLCJjb2xvck9iaiIsIkFuZHJvaWQiLCJSIiwiVGFiIiwiY3JlYXRlVGFiIiwidGFiIiwiX3dpbmRvdyIsIm9wZW4iLCJ0YWJPcGVuIiwiZ2V0V2luZG93Iiwic2V0V2luZG93IiwiX3NldFdpbmRvdyIsIlRhYkdyb3VwIiwiVmlldyIsIl9hZGQiLCJhZGQiLCJUaVdpbmRvdyIsIl9jaGlsZHJlbiIsIl9yZW1vdmUiLCJyZW1vdmUiLCJjaGlsZHJlbiIsImNoaWxkSW5kZXgiLCJUaVZpZXciLCJjcmVhdGVXZWJWaWV3IiwiY3JlYXRlV2ViVmlld1dyYXBwZXIiLCJ3ZWJWaWV3Iiwib25DcmVhdGVXaW5kb3ciLCJpc1VzZXJHZXN0dXJlIiwid2luIiwiY3JlYXRlV2luZG93IiwiZnVsbHNjcmVlbiIsIm5ld1dlYlZpZXciLCJUQUciLCJTY3JpcHQiLCJXaW5kb3ciLCJfY2FjaGVkQWN0aXZpdHlQcm94eSIsImFjdGl2aXR5UHJveHlHZXR0ZXIiLCJhY3Rpdml0eVByb3h5IiwiX2dldFdpbmRvd0FjdGl2aXR5UHJveHkiLCJnZXRBY3Rpdml0eSIsIl9vcGVuIiwiX2Nsb3NlRnJvbUFjdGl2aXR5Rm9yY2VkVG9EZXN0cm95IiwiX3VybENvbnRleHQiLCJkaXNwb3NlQ29udGV4dCIsInBvc3RXaW5kb3dDcmVhdGVkIiwiX2ludGVybmFsQWN0aXZpdHkiLCJleHRlbmQiLCJfYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwibGlzdGVuZXIiLCJwcmVwZW5kIiwiX2V2ZW50c1RvTGlzdGVuZXJzIiwibmV3TGlzdGVuZXIiLCJlbWl0IiwiZXZlbnRMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJ3Iiwib25jZVdyYXAiLCJ3cmFwcGVyIiwid3JhcHBlZEZ1bmMiLCJ3cmFwcGVyVGhpcyIsImJvdW5kIiwiRXZlbnRFbWl0dGVyIiwiX21heExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImZvdW5kSW5kZXgiLCJ1bndyYXBwZWRMaXN0ZW5lciIsIm9mZiIsImV2ZW50TmFtZXMiLCJsaXN0ZW5lcnMiLCJyYXciLCJsIiwicmF3TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsInJlbW92ZUFsbExpc3RlbmVycyIsIm5hbWVzIiwiYXNzZXJ0QXJndW1lbnRUeXBlIiwidHlwZW5hbWUiLCJzdGFuZGFyZGl6ZUFyY2giLCJvcmlnaW5hbCIsInByb2Nlc3MkMSIsImFib3J0IiwiYXJjaCIsImFyY2hpdGVjdHVyZSIsImFyZ3YiLCJjaGFubmVsIiwiY2hkaXIiLCJjb25maWciLCJjb25uZWN0ZWQiLCJjcHVVc2FnZSIsInVzZXIiLCJzeXN0ZW0iLCJjd2QiLCJfX2Rpcm5hbWUiLCJhc3NldHMiLCJqc29uIiwicmVhZEFzc2V0IiwiZGVwbG95RGF0YSIsImRlYnVnZ2VyUG9ydCIsImRpc2Nvbm5lY3QiLCJkbG9wZW4iLCJ3YXJuaW5nIiwiY3RvciIsImRldGFpbCIsImlzRGVwcmVjYXRpb24iLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsImxvYWRFbnZKc29uIiwianNvbkZpbGUiLCJyZWFkIiwidGV4dCIsImVudiIsImV4ZWNBcmd2IiwiZXhlY1BhdGgiLCJleGl0IiwiZXhpdENvZGUiLCJwaWQiLCJwbGF0Zm9ybSIsInBwaWQiLCJpc1RUWSIsImNodW5rIiwiY2FsbGJhY2siLCJ0aXRsZSIsInRyYWNlRGVwcmVjYXRpb24iLCJ1bWFzayIsInVwdGltZSIsImRpZmZNcyIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm1vZHVsZXMiLCJ2OCIsImpzYyIsIldBUk5JTkdfUFJFRklYIiwidW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrIiwic2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJldmVudCIsImJhY2t0cmFjZSIsImZpbGVOYW1lIiwic291cmNlTmFtZSIsImNvbHVtbk51bWJlciIsImxpbmVPZmZzZXQiLCJDYWxsYmFja1dpdGhBcmdzIiwiZnVuYyIsInJ1biIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsInNldFRpbWVvdXQiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJpc0Fic29sdXRlIiwiaXNQb3NpeCIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJmcm9tSW5kZXgiLCJoYWRUcmFpbGluZyIsImV4dG5hbWUiLCJlbmRJbmRleCIsImxhc3RJbmRleFdpbjMyU2VwYXJhdG9yIiwiY2hhciIsImJhc2VuYW1lIiwiZXh0IiwibGFzdENoYXJDb2RlIiwibm9ybWFsaXplIiwiaXNXaW5kb3dzIiwiaGFkTGVhZGluZyIsImlzVU5DIiwicGFydHMiLCJzZWdtZW50Iiwibm9ybWFsaXplZCIsImFzc2VydFNlZ21lbnQiLCJwYXRocyIsInJlc29sdmVkIiwiaGl0Um9vdCIsInJlbGF0aXZlIiwidG8iLCJ1cENvdW50IiwicmVtYWluaW5nUGF0aCIsInJvb3QiLCJiYXNlTGVuZ3RoIiwidG9TdWJ0cmFjdCIsImZpcnN0Q2hhckNvZGUiLCJ0aGlyZENoYXJDb2RlIiwicGF0aE9iamVjdCIsInRvTmFtZXNwYWNlZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJXaW4zMlBhdGgiLCJzZXAiLCJkZWxpbWl0ZXIiLCJQb3NpeFBhdGgiLCJ3aW4zMiIsInBvc2l4IiwiUG9zaXhDb25zdGFudHMiLCJVVl9VRFBfUkVVU0VBRERSIiwiZXJybm8iLCJFMkJJRyIsIkVBQ0NFUyIsIkVBRERSSU5VU0UiLCJFQUREUk5PVEFWQUlMIiwiRUFGTk9TVVBQT1JUIiwiRUFHQUlOIiwiRUFMUkVBRFkiLCJFQkFERiIsIkVCQURNU0ciLCJFQlVTWSIsIkVDQU5DRUxFRCIsIkVDSElMRCIsIkVDT05OQUJPUlRFRCIsIkVDT05OUkVGVVNFRCIsIkVDT05OUkVTRVQiLCJFREVBRExLIiwiRURFU1RBRERSUkVRIiwiRURPTSIsIkVEUVVPVCIsIkVFWElTVCIsIkVGQVVMVCIsIkVGQklHIiwiRUhPU1RVTlJFQUNIIiwiRUlEUk0iLCJFSUxTRVEiLCJFSU5QUk9HUkVTUyIsIkVJTlRSIiwiRUlOVkFMIiwiRUlPIiwiRUlTQ09OTiIsIkVJU0RJUiIsIkVMT09QIiwiRU1GSUxFIiwiRU1MSU5LIiwiRU1TR1NJWkUiLCJFTVVMVElIT1AiLCJFTkFNRVRPT0xPTkciLCJFTkVURE9XTiIsIkVORVRSRVNFVCIsIkVORVRVTlJFQUNIIiwiRU5GSUxFIiwiRU5PQlVGUyIsIkVOT0RBVEEiLCJFTk9ERVYiLCJFTk9FTlQiLCJFTk9FWEVDIiwiRU5PTENLIiwiRU5PTElOSyIsIkVOT01FTSIsIkVOT01TRyIsIkVOT1BST1RPT1BUIiwiRU5PU1BDIiwiRU5PU1IiLCJFTk9TVFIiLCJFTk9TWVMiLCJFTk9UQ09OTiIsIkVOT1RESVIiLCJFTk9URU1QVFkiLCJFTk9UU09DSyIsIkVOT1RTVVAiLCJFTk9UVFkiLCJFTlhJTyIsIkVPUE5PVFNVUFAiLCJFT1ZFUkZMT1ciLCJFUEVSTSIsIkVQSVBFIiwiRVBST1RPIiwiRVBST1RPTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVSQU5HRSIsIkVST0ZTIiwiRVNQSVBFIiwiRVNSQ0giLCJFU1RBTEUiLCJFVElNRSIsIkVUSU1FRE9VVCIsIkVUWFRCU1kiLCJFV09VTERCTE9DSyIsIkVYREVWIiwic2lnbmFscyIsIlNJR0hVUCIsIlNJR0lOVCIsIlNJR1FVSVQiLCJTSUdJTEwiLCJTSUdUUkFQIiwiU0lHQUJSVCIsIlNJR0lPVCIsIlNJR0JVUyIsIlNJR0ZQRSIsIlNJR0tJTEwiLCJTSUdVU1IxIiwiU0lHU0VHViIsIlNJR1VTUjIiLCJTSUdQSVBFIiwiU0lHQUxSTSIsIlNJR1RFUk0iLCJTSUdDSExEIiwiU0lHQ09OVCIsIlNJR1NUT1AiLCJTSUdUU1RQIiwiU0lHVFRJTiIsIlNJR1RUT1UiLCJTSUdVUkciLCJTSUdYQ1BVIiwiU0lHWEZTWiIsIlNJR1ZUQUxSTSIsIlNJR1BST0YiLCJTSUdXSU5DSCIsIlNJR0lPIiwiU0lHSU5GTyIsIlNJR1NZUyIsInByaW9yaXR5IiwiUFJJT1JJVFlfTE9XIiwiUFJJT1JJVFlfQkVMT1dfTk9STUFMIiwiUFJJT1JJVFlfTk9STUFMIiwiUFJJT1JJVFlfQUJPVkVfTk9STUFMIiwiUFJJT1JJVFlfSElHSCIsIlBSSU9SSVRZX0hJR0hFU1QiLCJPUyIsIkVPTCIsImNwdXMiLCJwcm9jZXNzb3JDb3VudCIsImFycmF5IiwibW9kZWwiLCJzcGVlZCIsInRpbWVzIiwibmljZSIsInN5cyIsImlkbGUiLCJpcnEiLCJlbmRpYW5uZXNzIiwiZ2V0TmF0aXZlQnl0ZU9yZGVyIiwiTElUVExFX0VORElBTiIsImZyZWVtZW0iLCJhdmFpbGFibGVNZW1vcnkiLCJnZXRQcmlvcml0eSIsImhvbWVkaXIiLCJhcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnkiLCJob3N0bmFtZSIsImFkZHJlc3MiLCJsb2FkYXZnIiwibmV0d29ya0ludGVyZmFjZXMiLCJzZXRQcmlvcml0eSIsInRtcGRpciIsInRlbXBEaXJlY3RvcnkiLCJ0b3RhbG1lbSIsInRvdGFsTWVtb3J5IiwidXNlckluZm8iLCJ1aWQiLCJnaWQiLCJ1c2VybmFtZSIsInNoZWxsIiwidHR5IiwiaXNhdHR5IiwiUmVhZFN0cmVhbSIsIldyaXRlU3RyZWFtIiwiTU9OVEhTIiwidXRpbCIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1ByaW1pdGl2ZSIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJwcmludCIsInB1dHMiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9taXNpZnkiLCJ3cmFwcGVkIiwiY2FsbGJhY2tpZnkiLCJwcm9taXNlIiwid3JhcHBlZEVycm9yIiwicmVhc29uIiwiZGVwcmVjYXRlIiwibm9vcCIsImRlYnVnbG9nIiwiREVGQVVMVF9NRVNTQUdFUyIsImRlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwiZGVlcEVxdWFsIiwiZXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsIm5vdEVxdWFsIiwiQ09NUEFSRV9UWVBFIiwiU1RSSUNUTkVTUyIsIlN0cmljdCIsIkxvb3NlIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcGVyYXRvciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJvayIsInRocm93RXJyb3IiLCJjb21wYXJlTWFwcyIsInN0cmljdG5lc3MiLCJyZWZlcmVuY2VzIiwibG9vc2VDaGVja3MiLCJleHBlY3RlZEtleSIsImV4cGVjdGVkVmFsdWUiLCJmb3VuZCIsImNvbXBhcmVTZXRzIiwiYWN0dWFsVGFnIiwiZXhwZWN0ZWRUYWciLCJhY3R1YWxQcm90b3R5cGUiLCJleHBlY3RlZFByb3RvdHlwZSIsImNvbXBhcmlzb24iLCJmbGFncyIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJOT19FWENFUFRJT04iLCJleGVjdXRlIiwiaXNQcm9taXNlTGlrZSIsImV4ZWN1dGVQcm9taXNlIiwiZm5UeXBlIiwidGhyb3dzIiwiY2hlY2tFcnJvciIsInJlamVjdHMiLCJhc3luY0ZuIiwiZG9lc05vdFRocm93IiwiZG9lc05vdFJlamVjdCIsImlzUHJvdG90eXBlT2YiLCJpZkVycm9yIiwic3RyaWN0IiwiU3RyaW5nRGVjb2RlciIsIl9pbXBsIiwiVXRmOFN0cmluZ0RlY29kZXIiLCJVdGYxNlN0cmluZ0RlY29kZXIiLCJCYXNlNjRTdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlckltcGwiLCJieXRlQ291bnQiLCJjaGFyTGVuZ3RoIiwiTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwiLCJieXRlc1BlckNoYXIiLCJpbmNvbXBsZXRlIiwiX2NoZWNrSW5jb21wbGV0ZUJ5dGVzIiwiX2J1ZmZlciIsIl9pbmNvbXBsZXRlRW5kIiwiX2luY29tcGxldGVCdWZmZXJFbXB0aWVkIiwiYnl0ZXNDb3BpZWQiLCJpbmNvbXBsZXRlQ2hhckRhdGEiLCJieXRlc05lZWRlZCIsImluY29tcGxldGVDaGFySW5kZXgiLCJieXRlc1RvQ29weSIsImNoZWNrQ2hhckxlbmd0aEZvclVURjgiLCJtb2R1bG8iLCJieXRlIiwiU3RyaW5nRGVjb2RlciQxIiwicHJpbnRlZFdhcm5pbmdzIiwib25lVGltZVdhcm5pbmciLCJ1bnN1cHBvcnRlZE5vb3AiLCJtb2R1bGVOYW1lIiwiZnFuIiwiYXN5bmNVbnN1cHBvcnRlZE5vb3AiLCJtYXliZUNhbGxiYWNrIiwiQ09QWV9GSUxFX0NIVU5LX1NJWkUiLCJmaWxlRGVzY3JpcHRvcnMiLCJmaWxlRGVzY3JpcHRvckNvdW50IiwiRkxBR1NfVE9fVElfTU9ERSIsIk1PREVfQVBQRU5EIiwiTU9ERV9XUklURSIsInBlcm1pc3Npb25EZW5pZWQiLCJzeXNjYWxsIiwibWFrZUVycm9yIiwibm9TdWNoRmlsZSIsImZpbGVBbHJlYWR5RXhpc3RzIiwibm90QURpcmVjdG9yeSIsImRpcmVjdG9yeU5vdEVtcHR5IiwiaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSIsImZzIiwiT19SRE9OTFkiLCJPX1dST05MWSIsIk9fUkRXUiIsIlNfSUZNVCIsIlNfSUZSRUciLCJTX0lGRElSIiwiU19JRkNIUiIsIlNfSUZCTEsiLCJTX0lGSUZPIiwiU19JRkxOSyIsIlNfSUZTT0NLIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fTk9DVFRZIiwiT19UUlVOQyIsIk9fQVBQRU5EIiwiT19ESVJFQ1RPUlkiLCJPX05PRk9MTE9XIiwiT19TWU5DIiwiT19EU1lOQyIsIk9fU1lNTElOSyIsIk9fTk9OQkxPQ0siLCJTX0lSV1hVIiwiU19JUlVTUiIsIlNfSVdVU1IiLCJTX0lYVVNSIiwiU19JUldYRyIsIlNfSVJHUlAiLCJTX0lXR1JQIiwiU19JWEdSUCIsIlNfSVJXWE8iLCJTX0lST1RIIiwiU19JV09USCIsIlNfSVhPVEgiLCJGX09LIiwiUl9PSyIsIldfT0siLCJYX09LIiwiVVZfRlNfQ09QWUZJTEVfRVhDTCIsIkNPUFlGSUxFX0VYQ0wiLCJTdGF0cyIsIl9maWxlIiwiZGV2IiwiaW5vIiwibmxpbmsiLCJyZGV2IiwiYmxrc2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwiZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUiLCJjcmVhdGVkQXQiLCJtb2RpZmllZEF0IiwiY2VpbCIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNCbG9ja0RldmljZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1ib2xpY0xpbmsiLCJpc0ZJRk8iLCJpc1NvY2tldCIsImFjY2VzcyIsImFjY2Vzc1N5bmMiLCJmaWxlSGFuZGxlIiwiZXhlY3V0YWJsZSIsImFwcGVuZEZpbGUiLCJmaWxlIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImZsYWciLCJ3cml0ZUZpbGUiLCJhcHBlbmRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJjaG1vZCIsImNobW9kU3luYyIsImNob3duIiwiY2hvd25TeW5jIiwiZmQiLCJjbG9zZVN5bmMiLCJzdHJlYW1Gb3JEZXNjcmlwdG9yIiwiY29weUZpbGUiLCJzcmNGaWxlIiwic3JjU3RyZWFtIiwiZGVzdEZpbGUiLCJkZXN0U3RyZWFtIiwicGlwZSIsImNvcHlGaWxlU3luYyIsImV4aXN0c1N5bmMiLCJmY2htb2QiLCJmY2htb2RTeW5jIiwiZmNob3duIiwiZmNob3duU3luYyIsImZkYXRhc3luYyIsImZkYXRhc3luY1N5bmMiLCJmc3RhdCIsInN0YXRzIiwiZnN0YXRTeW5jIiwiX29wdGlvbnMiLCJwYXRoRm9yRmlsZURlc2NyaXB0b3IiLCJzdGF0U3luYyIsImxzdGF0Iiwic3RhdCIsImxzdGF0U3luYyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibWtkaXJTeW5jIiwidGlGaWxlIiwiY3JlYXRlRGlyZWN0b3J5IiwibWtkdGVtcCIsInRyeU1rZHRlbXAiLCJnZW5lcmF0ZWQiLCJyYW5kb21DaGFyYWN0ZXJzIiwibWtkdGVtcFN5bmMiLCJyZXRyeUNvdW50IiwiTUFYX1JFVFJJRVMiLCJmaWxlRGVzY3JpcHRvciIsIm9wZW5TeW5jIiwiX21vZGUiLCJjcmVhdGVGaWxlIiwicGFyZW50IiwidGlNb2RlIiwiY3JlYXRlRmlsZURlc2NyaXB0b3IiLCJ0aUZpbGVTdHJlYW0iLCJyZWFkT2JqIiwic3VjY2VzcyIsImJ5dGVzUHJvY2Vzc2VkIiwicmVhZFN5bmMiLCJfcG9zaXRpb24iLCJmaWxlU3RyZWFtIiwicmVhZGRpciIsInJlYWRkaXJTeW5jIiwid2l0aEZpbGVUeXBlcyIsImxpc3RpbmciLCJnZXREaXJlY3RvcnlMaXN0aW5nIiwicmVhZEZpbGVQb3N0T3BlbiIsImZpbGVTaXplIiwic291cmNlU3RyZWFtIiwicmVhZEFsbE9iaiIsInJlYWRGaWxlIiwid2FzRmlsZURlc2NyaXB0b3IiLCJoYW5kbGVCdWZmZXIiLCJlbmNvZGVCdWZmZXIiLCJyZWFkRmlsZVN5bmMiLCJyZWFscGF0aCIsInJlc3VsdEV4aXN0cyIsInBhcnRpYWxGaWxlUGF0aCIsInRyeVBhdGgiLCJwYXJ0aWFsRXhpc3RzIiwibmF0aXZlIiwicmVhbHBhdGhTeW5jIiwicmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJyZW5hbWVTeW5jIiwidGVtcFBhdGgiLCJtb3ZlIiwidW5saW5rIiwiX2VyciIsInRtcEZpbGUiLCJybWRpciIsInJtZGlyU3luYyIsImRlbGV0ZURpcmVjdG9yeSIsInN1YkZpbGVzIiwic3ltbGluayIsInN5bWxpbmtTeW5jIiwidHJ1bmNhdGUiLCJieXRlc1JlYWQiLCJ0cnVuY2F0ZVN5bmMiLCJ1bmxpbmtTeW5jIiwiZGVsZXRlRmlsZSIsInVud2F0Y2hGaWxlIiwidXRpbWVzIiwidXRpbWVzU3luYyIsIndhdGNoIiwid2F0Y2hGaWxlIiwiZmluaXNoIiwid3JpdGVTeW5jIiwid3JpdGVUaUZpbGVTdHJlYW0iLCJ3cml0ZU9iaiIsIndyaXRlQnVmZmVyIiwid3JpdGVTdHJpbmciLCJ3cml0ZUJ1ZmZlclN5bmMiLCJ3cml0ZVN0cmluZ1N5bmMiLCJGaWxlRGVzY3JpcHRvciIsInBpcGVWaWFXcml0ZVN0cmVhbSIsIndyaXRlU3RyZWFtIiwicG9pbnRlciIsImRlZmF1bHRzIiwib3B0aW9uc1R5cGUiLCJtZXJnZWQiLCJjYiIsIl9lbmNvZGluZyIsInJhbmRvbSIsIl9vcHRzIiwiUmVhZGFibGUiLCJyZWFkYWJsZSIsIl9yZWFkIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiX24iLCJXcml0YWJsZSIsImlzRHVwbGV4IiwiRHVwbGV4IiwiX3dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwiYWxsb3dIYWxmT3BlbiIsIndyaXRhYmxlTWV0aG9kcyIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsImZldGNoU2NyaXB0c0Zyb21Kc29uIiwiSlNPTl9GSUxFX05BTUUiLCJzZXR0aW5ncyIsInNjcmlwdHMiLCJmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5IiwicmVzb3VyY2VEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgiLCJuYXRpdmVQYXRoIiwiYm9vdHN0cmFwU2NyaXB0cyIsImxvYWRGcm9tIiwiZmlsZU5hbWVBcnJheSIsInNlYXJjaCIsImJvb3RzdHJhcFBhdGgiLCJsb2FkQXN5bmMiLCJmaW5pc2hlZCIsImxvYWRCb290c3RyYXBTY3JpcHRzIiwiYm9vdHN0cmFwSW5kZXgiLCJkb0xvYWQiLCJib290c3RyYXAiLCJvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkIiwiZmlyZUV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxTQUFTQSxpQkFBVCxDQUEyQkMsQ0FBM0IsRUFBOEI7QUFDN0IsTUFBSUEs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QUNtakMsUUFBRCxDQUF6QixDQUorQyxDQUlWO0FBQ3JDO0FBQ0E7QUFDQTs7O0FBR0EsWUFBSW9sQixTQUFTLENBQUMxUyxPQUFkLEVBQXVCO0FBQ3JCMFMsVUFBQUEsU0FBUyxDQUFDMVMsT0FBVixDQUFrQjJTLDRCQUFsQjtBQUNBO0FBQ0QsU0FiOEMsQ0FhN0M7OztBQUdGSCxRQUFBQSxjQUFjO0FBQ2YsT0FuQmUsQ0FtQmQ7OztBQUdGRixNQUFBQSxRQUFRO0FBQ1Q7O0FBRUQsYUFBU0ssNEJBQVQsR0FBd0M7QUFDdEM7QUFDQTtBQUNBSCxNQUFBQSxjQUFjO0FBQ2Roa0IsTUFBQUEsVUFBVSxDQUFDLE1BQU1pa0IsTUFBTSxFQUFiLEVBQWlCLENBQWpCLENBQVY7QUFDRDs7QUFFREEsSUFBQUEsTUFBTTtBQUNQLEdBdkQwQixDQXVEekI7QUFDRjs7O0FBR0FGLEVBQUFBLG9CQUFvQixDQUFDRCxRQUFELENBQXBCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBeG5ELEVBQUUsQ0FBQ2l0QixHQUFILENBQU9uQixJQUFQLENBQWEsR0FBRTlyQixFQUFFLENBQUNpeEIsR0FBSCxDQUFPcHNCLElBQUssSUFBRzdFLEVBQUUsQ0FBQ2l4QixHQUFILENBQU80USxPQUFRLHlCQUF3QixRQUFTLElBQUcsWUFBYSxHQUE5RixFLENBQW1HO0FBQ25HMGxCLFNBQVMsQ0FBQyxZQUFZO0FBQ3BCO0FBQ0E7QUFDQWxvRCxFQUFBQSxPQUFPLENBQUMsT0FBRCxDQUFQLENBSG9CLENBR0Y7QUFDbEI7QUFDQTs7O0FBR0FXLEVBQUFBLEVBQUUsQ0FBQ2l4QixHQUFILENBQU82MkIsU0FBUCxDQUFpQixTQUFqQjtBQUNELENBVFEsQ0FBVCIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuXHRpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuXHR2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGlmIChlKSB7XG5cdFx0T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlW2tdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0blsnZGVmYXVsdCddID0gZTtcblx0cmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIFRoaXMgc2NyaXB0IGlzIHVzZWQgdG8gbG9hZCBBQ0EgKEF4d2F5IENyYXNoIEFuYWx5dGljcykuXG4gKiBUaGlzIGFsbG93cyBBQ0EgdG8gYmUgdGhlIGZpcnN0IG1vZHVsZSB0byBsb2FkIG9uIHN0YXJ0dXAuXG4gKi9cblByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKHJlcXVpcmUoJ2NvbS5hcHBjZWxlcmF0b3IuYWNhJykpOyB9KS5jYXRjaCgoKSA9PiB7Ly8gTm8gbmVlZCB0byBub3RpZnkgb2YgQUNBIGxvYWQgZmFpbHVyZS5cbn0pO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlLXByb3BzICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCwgT1NfSU9TICovXG4vLyBBZGQgZ2xvYmFsIGNvbnN0YW50cy5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29tbW9uanNHbG9iYWwsIHtcbiAgJ09TX0FORFJPSUQnOiB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gICdPU19JT1MnOiB7XG4gICAgdmFsdWU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPU19WRVJTSU9OX01BSk9SOiB7XG4gICAgdmFsdWU6IFRpLlBsYXRmb3JtLnZlcnNpb25NYWpvcixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1NfVkVSU0lPTl9NSU5PUjoge1xuICAgIHZhbHVlOiBUaS5QbGF0Zm9ybS52ZXJzaW9uTWlub3IsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9TX1ZFUlNJT05fUEFUQ0g6IHtcbiAgICB2YWx1ZTogVGkuUGxhdGZvcm0udmVyc2lvblBhdGNoLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9XG59KTtcblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3Qga05vZGVNb2R1bGVzUkUgPSAvXiguKilbXFxcXC9dbm9kZV9tb2R1bGVzW1xcXFwvXS87XG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID0gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKTtcbmNvbnN0IGlzQnVmZmVyID0gU3ltYm9sLmZvcigndGl0YW5pdW0uYnVmZmVyLmlzQnVmZmVyJyk7XG5jb25zdCBjb2xvclJlZ0V4cCA9IC9cXHUwMDFiXFxbXFxkXFxkP20vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbG9ycyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNvbG9yUmVnRXhwLCAnJyk7XG59XG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgLy8gQW4gZXJyb3IgY291bGQgYmUgYW4gaW5zdGFuY2Ugb2YgRXJyb3Igd2hpbGUgbm90IGJlaW5nIGEgbmF0aXZlIGVycm9yXG4gIC8vIG9yIGNvdWxkIGJlIGZyb20gYSBkaWZmZXJlbnQgcmVhbG0gYW5kIG5vdCBiZSBpbnN0YW5jZSBvZiBFcnJvciBidXQgc3RpbGxcbiAgLy8gYmUgYSBuYXRpdmUgZXJyb3IuXG4gIHJldHVybiBpc05hdGl2ZUVycm9yKGUpIHx8IGUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmxldCBnZXRTdHJ1Y3R1cmVkU3RhY2s7XG5cbmNsYXNzIFN0YWNrVHJhY2VFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cblN0YWNrVHJhY2VFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IChlcnIsIHRyYWNlKSA9PiB0cmFjZTtcblxuU3RhY2tUcmFjZUVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEluZmluaXR5O1xuZnVuY3Rpb24gaXNJbnNpZGVOb2RlTW9kdWxlcygpIHtcbiAgaWYgKGdldFN0cnVjdHVyZWRTdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ2V0U3RydWN0dXJlZFN0YWNrID0gKCkgPT4gbmV3IFN0YWNrVHJhY2VFcnJvcigpLnN0YWNrO1xuICB9XG5cbiAgbGV0IHN0YWNrID0gZ2V0U3RydWN0dXJlZFN0YWNrKCk7IC8vIHN0YWNrIGlzIG9ubHkgYW4gYXJyYXkgb24gdjgsIHRyeSB0byBjb252ZXJ0IG1hbnVhbGx5IGlmIHN0cmluZ1xuXG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RhY2tGcmFtZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KC9cXG4vKTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgbGluZUluZm8gPSBsaW5lLm1hdGNoKC8oLiopQCguKik6KFxcZCspOihcXGQrKS8pO1xuXG4gICAgICBpZiAobGluZUluZm8pIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBsaW5lSW5mb1syXS5yZXBsYWNlKCdmaWxlOi8vJywgJycpO1xuICAgICAgICBzdGFja0ZyYW1lcy5wdXNoKHtcbiAgICAgICAgICBnZXRGaWxlTmFtZTogKCkgPT4gZmlsZW5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2sgPSBzdGFja0ZyYW1lcztcbiAgfSAvLyBJdGVyYXRlIG92ZXIgYWxsIHN0YWNrIGZyYW1lcyBhbmQgbG9vayBmb3IgdGhlIGZpcnN0IG9uZSBub3QgY29taW5nXG4gIC8vIGZyb20gaW5zaWRlIE5vZGUuanMgaXRzZWxmOlxuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhY2spKSB7XG4gICAgZm9yIChjb25zdCBmcmFtZSBvZiBzdGFjaykge1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBmcmFtZS5nZXRGaWxlTmFtZSgpOyAvLyBJZiBhIGZpbGVuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggLyBvciBjb250YWluIFxcLFxuICAgICAgLy8gaXQncyBsaWtlbHkgZnJvbSBOb2RlLmpzIGNvcmUuXG5cbiAgICAgIGlmICghL15cXC98XFxcXC8udGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrTm9kZU1vZHVsZXNSRS50ZXN0KGZpbGVuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBqb2luJDEob3V0cHV0LCBzZXBhcmF0b3IpIHtcbiAgbGV0IHN0ciA9ICcnO1xuXG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAvLyBJdCBpcyBmYXN0ZXIgbm90IHRvIHVzZSBhIHRlbXBsYXRlIHN0cmluZyBoZXJlXG4gICAgICBzdHIgKz0gb3V0cHV0W2ldO1xuICAgICAgc3RyICs9IHNlcGFyYXRvcjtcbiAgICB9XG5cbiAgICBzdHIgKz0gb3V0cHV0W2xhc3RJbmRleF07XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmNvbnN0IEFMTF9QUk9QRVJUSUVTJDIgPSAwO1xuY29uc3QgT05MWV9FTlVNRVJBQkxFJDIgPSAyO1xuY29uc3QgcHJvcGVydHlGaWx0ZXIgPSB7XG4gIEFMTF9QUk9QRVJUSUVTOiBBTExfUFJPUEVSVElFUyQyLFxuICBPTkxZX0VOVU1FUkFCTEU6IE9OTFlfRU5VTUVSQUJMRSQyXG59O1xuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKG9iaiwgZmlsdGVyKSB7XG4gIGNvbnN0IHByb3BzID0gW107XG4gIGNvbnN0IGtleXMgPSBmaWx0ZXIgPT09IE9OTFlfRU5VTUVSQUJMRSQyID8gT2JqZWN0LmtleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaXNBbGxEaWdpdHMoa2V5KSkge1xuICAgICAgcHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gaXNBbGxEaWdpdHMocykge1xuICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gcy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbmNvbnN0IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyA9IHVuY3VycnlUaGlzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBTeW1ib2wudG9TdHJpbmdUYWcpLmdldCk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvdG90eXBlKHZhbHVlLCBuYW1lKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBgW29iamVjdCAke25hbWV9XWA7XG59XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0FyZ3VtZW50c09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXJndW1lbnRzJyk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdBcnJheUJ1ZmZlcicpO1xufSAvLyBDYWNoZWQgdG8gbWFrZSBzdXJlIG5vIHVzZXJsYW5kIGNvZGUgY2FuIHRhbXBlciB3aXRoIGl0LlxuXG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldztcbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdBc3luY0Z1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0Jvb2xlYW4nKTtcbn1cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8IGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fCBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIC8vIHx8IGlzQmlnSW50T2JqZWN0KHZhbHVlKVxuICB8fCBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdEYXRhVmlldycpO1xufVxuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdEYXRlJyk7XG59IC8vIEB0b2RvIGlzRXh0ZXJuYWxcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdHZW5lcmF0b3JGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0dlbmVyYXRvcicpO1xufVxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdNYXAnKTtcbn1cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTWFwIEl0ZXJhdG9yJztcbn0gLy8gQHRvZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcblxuZnVuY3Rpb24gaXNOYXRpdmVFcnJvcih2YWx1ZSkge1xuICAvLyBpZiBub3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIGRlZmluaXRlbHkgbm90IGEgbmF0aXZlIGVycm9yXG4gIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWydFcnJvcicsICdFdmFsRXJyb3InLCAnUmFuZ2VFcnJvcicsICdSZWZlcmVuY2VFcnJvcicsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InXS5pbmNsdWRlcyh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdOdW1iZXInKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnUHJvbWlzZScpO1xufSAvLyBAdG9kbyBpc1Byb3h5XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdSZWdFeHAnKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdTZXQnKTtcbn1cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnU2V0IEl0ZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKCFnbG9iYWwuU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU2hhcmVkQXJyYXlCdWZmZXInKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdTdHJpbmcnKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdTeW1ib2wnKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICBjb25zdCBpc0J1aWx0SW5UeXBlZEFycmF5ID0gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0J1aWx0SW5UeXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWVbaXNCdWZmZXJdID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtNYXAnKTtcbn1cbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnV2Vha1NldCcpO1xufSAvLyBAdG9kbyBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGVcblxudmFyIHR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGlzQW55QXJyYXlCdWZmZXI6IGlzQW55QXJyYXlCdWZmZXIsXG5cdGlzQXJndW1lbnRzT2JqZWN0OiBpc0FyZ3VtZW50c09iamVjdCxcblx0aXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcblx0aXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuXHRpc0FzeW5jRnVuY3Rpb246IGlzQXN5bmNGdW5jdGlvbixcblx0aXNCaWdJbnQ2NEFycmF5OiBpc0JpZ0ludDY0QXJyYXksXG5cdGlzQmlnVWludDY0QXJyYXk6IGlzQmlnVWludDY0QXJyYXksXG5cdGlzQm9vbGVhbk9iamVjdDogaXNCb29sZWFuT2JqZWN0LFxuXHRpc0JveGVkUHJpbWl0aXZlOiBpc0JveGVkUHJpbWl0aXZlLFxuXHRpc0RhdGFWaWV3OiBpc0RhdGFWaWV3LFxuXHRpc0RhdGU6IGlzRGF0ZSxcblx0aXNGbG9hdDMyQXJyYXk6IGlzRmxvYXQzMkFycmF5LFxuXHRpc0Zsb2F0NjRBcnJheTogaXNGbG9hdDY0QXJyYXksXG5cdGlzR2VuZXJhdG9yRnVuY3Rpb246IGlzR2VuZXJhdG9yRnVuY3Rpb24sXG5cdGlzR2VuZXJhdG9yT2JqZWN0OiBpc0dlbmVyYXRvck9iamVjdCxcblx0aXNJbnQ4QXJyYXk6IGlzSW50OEFycmF5LFxuXHRpc0ludDE2QXJyYXk6IGlzSW50MTZBcnJheSxcblx0aXNJbnQzMkFycmF5OiBpc0ludDMyQXJyYXksXG5cdGlzTWFwOiBpc01hcCxcblx0aXNNYXBJdGVyYXRvcjogaXNNYXBJdGVyYXRvcixcblx0aXNOYXRpdmVFcnJvcjogaXNOYXRpdmVFcnJvcixcblx0aXNOdW1iZXJPYmplY3Q6IGlzTnVtYmVyT2JqZWN0LFxuXHRpc1Byb21pc2U6IGlzUHJvbWlzZSxcblx0aXNSZWdFeHA6IGlzUmVnRXhwLFxuXHRpc1NldDogaXNTZXQsXG5cdGlzU2V0SXRlcmF0b3I6IGlzU2V0SXRlcmF0b3IsXG5cdGlzU2hhcmVkQXJyYXlCdWZmZXI6IGlzU2hhcmVkQXJyYXlCdWZmZXIsXG5cdGlzU3RyaW5nT2JqZWN0OiBpc1N0cmluZ09iamVjdCxcblx0aXNTeW1ib2xPYmplY3Q6IGlzU3ltYm9sT2JqZWN0LFxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcblx0aXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG5cdGlzVWludDhDbGFtcGVkQXJyYXk6IGlzVWludDhDbGFtcGVkQXJyYXksXG5cdGlzVWludDE2QXJyYXk6IGlzVWludDE2QXJyYXksXG5cdGlzVWludDMyQXJyYXk6IGlzVWludDMyQXJyYXksXG5cdGlzV2Vha01hcDogaXNXZWFrTWFwLFxuXHRpc1dlYWtTZXQ6IGlzV2Vha1NldFxufSk7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmxldCBlcnJvcjtcblxuZnVuY3Rpb24gbGF6eUVycm9yKCkge1xuICBpZiAoIWVycm9yKSB7XG4gICAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgICAvLyBlcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuY29kZXMuRVJSX0lOVEVSTkFMX0FTU0VSVElPTjtcbiAgICBlcnJvciA9IGNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGFzc2VydCQxKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04obWVzc2FnZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gIGNvbnN0IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04gPSBsYXp5RXJyb3IoKTtcbiAgdGhyb3cgbmV3IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04obWVzc2FnZSk7XG59XG5cbmFzc2VydCQxLmZhaWwgPSBmYWlsO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBtZXNzYWdlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IGNvZGVzID0ge307IC8vIEB0b2RvIGltcGxlbWVudCB0aGlzIG9uY2UgbmVlZGVkXG5cbmNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige30gLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLlxuXG5cbmZ1bmN0aW9uIEUoc3ltLCB2YWwsIGRlZiwgLi4ub3RoZXJDbGFzc2VzKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgU3lzdGVtRXJyb3IgdGhhdCBmb3JtYXRzIHRoZSBlcnJvciBtZXNzYWdlIGRpZmZlcmVudGx5XG4gIC8vIFRoZSBTeXN0ZW1FcnJvcnMgb25seSBoYXZlIFN5c3RlbUVycm9yIGFzIHRoZWlyIGJhc2UgY2xhc3Nlcy5cbiAgbWVzc2FnZXMuc2V0KHN5bSwgdmFsKTtcblxuICBpZiAoZGVmID09PSBTeXN0ZW1FcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjb21wYXRpYmxlIFN5c3RlbUVycm9yIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVmID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGRlZiwgc3ltKTtcbiAgfVxuXG4gIGlmIChvdGhlckNsYXNzZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgb3RoZXJDbGFzc2VzLmZvckVhY2goY2xhenogPT4ge1xuICAgICAgZGVmW2NsYXp6Lm5hbWVdID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGNsYXp6LCBzeW0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29kZXNbc3ltXSA9IGRlZjtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlKGtleSwgYXJncywgdGhpcyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRDb2RlVG9OYW1lKHRoaXMsIHN1cGVyLm5hbWUsIGtleSk7XG4gICAgfVxuXG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIHNldCBjb2RlKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2tleX1dOiAke3RoaXMubWVzc2FnZX1gO1xuICAgIH1cblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGtleSwgYXJncywgc2VsZikge1xuICBjb25zdCBtc2cgPSBtZXNzYWdlcy5nZXQoa2V5KTtcbiAgLypcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0YXNzZXJ0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQnKTtcbiAgfVxuICAqL1xuXG4gIGlmICh0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzZXJ0JDEobXNnLmxlbmd0aCA8PSBhcmdzLmxlbmd0aCwgLy8gRGVmYXVsdCBvcHRpb25zIGRvIG5vdCBjb3VudC5cbiAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IGAgKyBgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmApO1xuICAgIHJldHVybiBtc2cuYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBjb25zdCBleHBlY3RlZExlbmd0aCA9IChtc2cubWF0Y2goLyVbZGZpam9Pc10vZykgfHwgW10pLmxlbmd0aDtcbiAgYXNzZXJ0JDEoZXhwZWN0ZWRMZW5ndGggPT09IGFyZ3MubGVuZ3RoLCBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IGAgKyBgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7ZXhwZWN0ZWRMZW5ndGh9KS5gKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbXNnO1xuICB9XG5cbiAgYXJncy51bnNoaWZ0KG1zZyk7XG4gIHJldHVybiBmb3JtYXQkMS5hcHBseShudWxsLCBhcmdzKTsgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgLy8gcmV0dXJuIGxhenlJbnRlcm5hbFV0aWxJbnNwZWN0KCkuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhZGRDb2RlVG9OYW1lKGVyciwgbmFtZSwgY29kZSkge1xuICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gIGVyci5uYW1lID0gYCR7bmFtZX0gWyR7Y29kZX1dYDsgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgLy8gQGZpeG1lOiBUaGlzIG9ubHkgd29ya3Mgb24gVjgvQW5kcm9pZCwgaU9TL0pTQyBoYXMgYSBkaWZmZXJlbnQgRXJyb3Igc3RydWN0dXJlLlxuICAvLyBzaG91bGQgd2UgdHJ5IHRvIG1ha2UgZXJyb3JzIGJlaGF2ZSB0aGUgc2FtZSBhY3Jvc3MgcGxhdGZvcm1zP1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgZXJyLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG5cbiAgaWYgKG5hbWUgPT09ICdTeXN0ZW1FcnJvcicpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlcnIubmFtZTtcbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLCAvLyBVc2luZyBhIGRlZmF1bHQgYXJndW1lbnQgaGVyZSBpcyBpbXBvcnRhbnQgc28gdGhlIGFyZ3VtZW50IGlzIG5vdCBjb3VudGVkXG4vLyB0b3dhcmRzIGBGdW5jdGlvbiNsZW5ndGhgLlxuKG5hbWUgPSB1bmRlZmluZWQpID0+IHtcbiAgaWYgKG5hbWUpIHtcbiAgICByZXR1cm4gYFwiJHtuYW1lfVwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gIH1cblxuICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnO1xufSwgUmFuZ2VFcnJvcik7XG5FKCdFUlJfSU5URVJOQUxfQVNTRVJUSU9OJywgbWVzc2FnZSA9PiB7XG4gIGNvbnN0IHN1ZmZpeCA9ICdUaGlzIGlzIGNhdXNlZCBieSBlaXRoZXIgYSBidWcgaW4gVGl0YW5pdW0gJyArICdvciBpbmNvcnJlY3QgdXNhZ2Ugb2YgVGl0YW5pdW0gaW50ZXJuYWxzLlxcbicgKyAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgd2l0aCB0aGlzIHN0YWNrIHRyYWNlIGF0ICcgKyAnaHR0cHM6Ly9qaXJhLmFwcGNlbGVyYXRvci5vcmdcXG4nO1xuICByZXR1cm4gbWVzc2FnZSA9PT0gdW5kZWZpbmVkID8gc3VmZml4IDogYCR7bWVzc2FnZX1cXG4ke3N1ZmZpeH1gO1xufSwgRXJyb3IpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuICBhc3NlcnQkMSh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdcXCduYW1lXFwnIG11c3QgYmUgYSBzdHJpbmcnKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICBsZXQgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBleHBlY3RlZC5zdGFydHNXaXRoKCdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICBsZXQgbXNnO1xuXG4gIGlmIChuYW1lLmVuZHNXaXRoKCcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBgVGhlICR7bmFtZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdHlwZSA9IG5hbWUuaW5jbHVkZXMoJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IGBUaGUgXCIke25hbWV9XCIgJHt0eXBlfSAke2RldGVybWluZXJ9ICR7b25lT2YoZXhwZWN0ZWQsICd0eXBlJyl9YDtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xubGV0IG1heFN0YWNrX0Vycm9yTmFtZTtcbmxldCBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgZXJyLm5hbWVgIGFuZCBgZXJyLm1lc3NhZ2VgIGFyZSBlcXVhbCB0byBlbmdpbmUtc3BlY2lmaWNcbiAqIHZhbHVlcyBpbmRpY2F0aW5nIG1heCBjYWxsIHN0YWNrIHNpemUgaGFzIGJlZW4gZXhjZWVkZWQuXG4gKiBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgaW4gVjguXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSB7XG4gIGlmIChtYXhTdGFja19FcnJvck1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBmdW5jdGlvbiBvdmVyZmxvd1N0YWNrKCkge1xuICAgICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJmbG93U3RhY2soKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtYXhTdGFja19FcnJvck1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICBtYXhTdGFja19FcnJvck5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVyci5uYW1lID09PSBtYXhTdGFja19FcnJvck5hbWUgJiYgZXJyLm1lc3NhZ2UgPT09IG1heFN0YWNrX0Vycm9yTWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGFzc2VydCQxKHR5cGVvZiB0aGluZyA9PT0gJ3N0cmluZycsICdgdGhpbmdgIGhhcyB0byBiZSBvZiB0eXBlIHN0cmluZycpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIGNvbnN0IGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBhc3NlcnQkMShsZW4gPiAwLCAnQXQgbGVhc3Qgb25lIGV4cGVjdGVkIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGkgPT4gU3RyaW5nKGkpKTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19IG9yICR7ZXhwZWN0ZWRbMV19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtTdHJpbmcoZXhwZWN0ZWQpfWA7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXkge31cbi8qKlxuICogbG9vcCBvdmVyIGlucHV0LCBldmVyeSAyIGNoYXJhY3RlcnMsIHBhcnNlIGFzIGFuIGludFxuICogYmFzaWNhbGx5IGVhY2ggdHdvIGNoYXJhY3RlcnMgYXJlIGEgXCJieXRlXCIgb3IgYW4gOC1iaXQgdWludFxuICogd2UgYXBwZW5kIHRoZW0gYWxsIHRvZ2V0aGVyIHRvIGZvcm0gYSBzaW5nbGUgYnVmZmVyIGhvbGRpbmcgYWxsIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBzdHJpbmcgd2UncmUgZW5jb2RpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7aW50ZWdlcltdfSBhcnJheSBvZiBlbmNvZGVkIGJ5dGVzXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGggLyAyO1xuICBjb25zdCBieXRlQXJyYXkgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xuICAgICAgLy8gZHJvcCBiYWQgaGV4IGNoYXJhY3RlcnNcbiAgICAgIGJ5dGVBcnJheS5wdXNoKG51bWVyaWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuY29uc3QgYXJyYXlJbmRleEhhbmRsZXIgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbnVtID0gTnVtYmVyKHByb3BLZXkpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICByZXR1cm4gZ2V0QWRqdXN0ZWRJbmRleCh0YXJnZXQsIG51bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBpc0J1ZmZlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcEtleSwgcmVjZWl2ZXIpO1xuICB9LFxuXG4gIHNldCh0YXJnZXQsIHByb3BLZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgcHJvcEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihwcm9wS2V5KTtcblxuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0YXJnZXQsIG51bSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9LFxuXG4gIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbnVtID0gTnVtYmVyKGtleSk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIC8vIGVuc3VyZSBpdCdzIGEgcG9zaXRpdmUgXCJzYWZlXCIgaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBidWZmZXJcbiAgICAgICAgcmV0dXJuIG51bSA+PSAwICYmIG51bSA8IHRhcmdldC5fdGlCdWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xuICB9XG5cbn07IC8vIFRoaXMgaXMgYSBzcGVjaWFsIEJ1ZmZlciB0aGF0IHdyYXBzIFRpLkJ1ZmZlclxuLy8gYXMgYSByZXN1bHQgaXQgaXMgKm11Y2gqIHNsb3dlciB0byByZWFkL3dyaXRlIHZhbHVlc1xuLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIGFjcm9zcyB0aGUgSlMvTmF0aXZlIGJvdW5kYXJ5IHBlci1ieXRlIVxuLy8gV2UgYWxzbyBuZWVkIHRvIHVzZSBhIFByb3h5IHRvIGhhbmRsZSBpbnRlcmNlcHRpbmcgc2V0L2dldCBvZiBpbmRpY2VzIHRvIHJlZGlyZWN0IHRvIHRoZSB1bmRlcmx5aW5nIFRpLkJ1ZmZlclxuXG5jbGFzcyBTbG93QnVmZmVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyLlxuICAgKlxuICAgKiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoaXMgbW9kdWxlIHRvZ2V0aGVyIHdpdGggYG5ld0J1ZmZlcmAgdG9cbiAgICogY3JlYXRlIGEgbmV3IEJ1ZmZlciBpbnN0YW5jZSB3cmFwcGluZyBhIFRpLkJ1ZmZlci5cbiAgICpcbiAgICogQWxzbyBzdXBwb3J0cyB0aGUgZGVwcmVjYXRlZCBCdWZmZXIoKSBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIHNhZmVcbiAgICogdG8gdXNlIG91dHNpZGUgb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpQnVmZmVyLCBzdGFydCA9IDAsIGxlbmd0aCA9IHRpQnVmZmVyLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYnl0ZU9mZnNldDoge1xuICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgIH0sXG4gICAgICBsZW5ndGg6IHtcbiAgICAgICAgdmFsdWU6IGxlbmd0aFxuICAgICAgfSxcbiAgICAgIF90aUJ1ZmZlcjoge1xuICAgICAgICB2YWx1ZTogdGlCdWZmZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgY3JlYXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UgaW5zaWRlIGEgUHJveHkgc28gd2UgY2FuIGhhbmRsZSBhcnJheSBpbmRleCBhY2Nlc3NcbiAgICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIHRoZSB1bmRlcmx5aW5nIGRhdGEvYnl0ZXNcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSB3cmFwcGVkIGluc2lkZSBhIFByb3h5XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21UaUJ1ZmZlcih0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNsb3dCdWZmZXIodGlCdWZmZXIsIHN0YXJ0LCBsZW5ndGgpLCBhcnJheUluZGV4SGFuZGxlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5ldy1idWZmZXJcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cblxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBUaS5VdGlscy5iYXNlNjRkZWNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgYmxvYlN0cmVhbSA9IFRpLlN0cmVhbS5jcmVhdGVTdHJlYW0oe1xuICAgICAgICBzb3VyY2U6IGJsb2IsXG4gICAgICAgIG1vZGU6IFRpLlN0cmVhbS5NT0RFX1JFQURcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYnVmZmVyID0gVGkuU3RyZWFtLnJlYWRBbGwoYmxvYlN0cmVhbSk7XG4gICAgICBibG9iU3RyZWFtLmNsb3NlKCk7XG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIoYnVmZmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICBjb25zdCBieXRlcyA9IHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpQnVmZmVyW2ldID0gYnl0ZXNbaV0gJiAweEZGOyAvLyBtYXNrIHRvIG9uZSBieXRlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcih0aUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdHlwZTogZ2V0VGlDb2RlY0NoYXJzZXQoZW5jb2RpbmcpXG4gICAgfSk7XG4gICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHRpQnVmZmVyKTtcbiAgfSAvLyBUaGlzIGlzIGEgbWV0aG9kIHdlIHNob3VsZCBnZXQgYnkgZXh0ZW5kaW5nIFVpbnQ4QXJyYXksIHNvIHJlYWxseSBzaG91bGQgb25seSBiZSBvdmVycmlkZW4gb24gYSBcIlNsb3dCdWZmZXJcIiB0aGF0IHdyYXBzIFRpLkJ1ZmZlclxuXG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAvLyBHZXQgdGhlIHNsaWNlIG9mIHRoZSBhcnJheSBmcm9tIGJ5dGVPZmZzZXQgdG8gbGVuZ3RoXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzKS5idWZmZXI7XG4gIH1cblxuICBfc2xpY2Uob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGhpcy5fdGlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIF9maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuXG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZhbGlkIGZpbGwgZGF0YScpO1xuICAgICAgfSAvLyBJZiB0aGUgYnVmZmVyIGxlbmd0aCA9PT0gMSwgd2UgY2FuIGp1c3QgZG8gdGhpcy5fdGlCdWZmZXIuZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQpO1xuXG5cbiAgICAgIGlmIChmaWxsQnVmTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwoYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gbXVsdGlwbGUgYnl0ZSBmaWxsIVxuXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIG9mZnNldDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZSAob24gYHRoaXNgLCBub3Qgb24gdGhlIGJ1ZmZlciB3ZSBqdXN0IGNyZWF0ZWQpP1xuICAgICAgICBjb25zdCBmaWxsQ2hhciA9IGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyW2kgJSBmaWxsQnVmTGVuZ3RoXTtcbiAgICAgICAgdGhpcy5fdGlCdWZmZXJbaSArIG9mZnNldF0gPSBmaWxsQ2hhcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgKG9yIGEgYnVmZmVyIHdpdGggYSBzaW5nbGUgYnl0ZSkgd2UgY2FuIHVzZSB0aUJ1ZmZlci5maWxsKCk7XG5cblxuICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfVxuXG4gIGdldEFkanVzdGVkSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpbmRleCk7XG4gIH1cblxuICBzZXRBZGp1c3RlZEluZGV4KGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gIH0gLy8gVGhpcyBpcyBhIG1ldGhvZCB3ZSBzaG91bGQgZ2V0IGJ5IGV4dGVuZGluZyBVaW50OEFycmF5LCBzbyByZWFsbHkgc2hvdWxkIG9ubHkgYmUgb3ZlcnJpZGVuIG9uIGEgXCJTbG93QnVmZmVyXCIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcblxuXG4gIHNldChzcmMsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCBudW1CeXRlcyA9IHNyYy5sZW5ndGg7IC8vIGNoZWNrIHNyYy5sZW5ndGggKyBvZmZzZXQgZG9lc24ndCBnbyBiZXlvbmQgb3VyIGxlbmd0aCFcbiAgICAvLyBGSVhNRTogUmUtZW5hYmxlXG4gICAgLy8gY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBudW1CeXRlcyk7XG4gICAgLy8gY29weSBzcmMgdmFsdWVzIGludG8gdGhpcyBidWZmZXIgc3RhcnRpbmcgYXQgb2Zmc2V0XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIG9mZnNldCwgc3JjW2ldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBtZXRob2QgZm9yIGludGVyYWN0aW5nIHdpdGggVGkgQVBJcyB0aGF0IHJlcXVpcmUgYSBUaS5CdWZmZXJcbiAgICogQHJldHVybnMge1RpLkJ1ZmZlcn0gdGhlIHVuZGVybHlpbmcgVGkuQnVmZmVyIGJhY2tpbmcgdGhpcyBCdWZmZXIgaW5zdGFuY2VcbiAgICovXG5cblxuICB0b1RpQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdGhpcy5fdGlCdWZmZXIubGVuZ3RoICYmIHRoaXMuYnl0ZU9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlci5jbG9uZSh0aGlzLmJ5dGVPZmZzZXQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSAvLyBXcmFwcGluZyBUaS5CdWZmZXI/XG5cblxuICBpZiAoYnVmLl90aUJ1ZmZlcikge1xuICAgIGlmIChpbmRleCA+PSBidWYuX3RpQnVmZmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmLl90aUJ1ZmZlcltpbmRleCArIGJ1Zi5ieXRlT2Zmc2V0XTtcbiAgfSAvLyBSYXcgVHlwZWRBcnJheS9BcnJheUJ1ZmZlclxuICAvLyBGSVhNRTogZG8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBieXRlT2Zmc2V0IGhlcmU/XG5cblxuICByZXR1cm4gYnVmW2luZGV4XTtcbn1cblxuZnVuY3Rpb24gc2V0QWRqdXN0ZWRJbmRleChidWYsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFdyYXBwaW5nIFRpLkJ1ZmZlcj9cblxuXG4gIGlmIChidWYuX3RpQnVmZmVyKSB7XG4gICAgaWYgKGluZGV4IDwgYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGJ1Zi5fdGlCdWZmZXJbaW5kZXggKyBidWYuYnl0ZU9mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gUmF3IFR5cGVkQXJyYXkvQXJyYXlCdWZmZXJcbiAgLy8gRklYTUU6IGRvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlP1xuXG5cbiAgYnVmW2luZGV4XSA9IHZhbHVlO1xufSAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI2J1ZmZlcl9idWZmZXJzX2FuZF9jaGFyYWN0ZXJfZW5jb2RpbmdzXG5cblxuY29uc3QgVElfQ09ERUNfTUFQID0gbmV3IE1hcCgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmLTgnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmOCcsIFRpLkNvZGVjLkNIQVJTRVRfVVRGOCk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGYtMTZsZScsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGYxNmxlJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3VjczInLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndWNzLTInLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgnbGF0aW4xJywgVGkuQ29kZWMuQ0hBUlNFVF9JU09fTEFUSU5fMSk7XG5USV9DT0RFQ19NQVAuc2V0KCdiaW5hcnknLCBUaS5Db2RlYy5DSEFSU0VUX0lTT19MQVRJTl8xKTtcblRJX0NPREVDX01BUC5zZXQoJ2FzY2lpJywgVGkuQ29kZWMuQ0hBUlNFVF9BU0NJSSk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBkZXNpcmVkIGVuY29kaW5nIG5hbWVcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaS5Db2RlYyBjb25zdGFudCB0aGF0IG1hcHMgdG8gdGhlIGVuY29kaW5nXG4gKi9cblxuZnVuY3Rpb24gZ2V0VGlDb2RlY0NoYXJzZXQoZW5jb2RpbmcpIHtcbiAgcmV0dXJuIFRJX0NPREVDX01BUC5nZXQoZW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgQnVmZmVyIHVzZXMgYSBUaS5CdWZmZXIgaW50ZXJuYWxseSB0byBiYWNrIGl0LlxuICogVGhpcyBpcyBsaWtsZXkgYW4gb3JkZXIgb2YgbWFnbml0dWRlIHNsb3dlciB0aGFuIHVzaW5nIGEgdmFyaWFudCB0aGF0IGV4dGVuZHMgVWludDhBcnJheSFcbiAqIEkgdGhpbmsgaWYgd2UncmUgbm90IGFscmVhZHkgd3JhcHBpbmcgYSBUaS5CdWZmZXIsIGl0IG1heSBiZSBiZXR0ZXIgdG8gaGF2ZSB0d28gaW1wbGVtZW50YXRpb25zXG4gKiBhbmQsIGxpa2UgYnJvd3NlcmlmeSwganVzdCBleHRlbmQgVWludDhBcnJheSBmb3IgYW55IEJ1ZmZlcnMgd2UgbmVlZCB0byByZWFkL3dyaXRlIGEgbG90XG4gKiBhbmQgdGhlbiBhZGQgYSBzaW1wbGUgY29udmVyc2lvbiBtZXRob2QgdG8gdHVybiBpdCBpbnRvIGEgVGkuQnVmZmVyIHdoZW4gbmVlZGVkLlxuICpcbiAqIFRoZSBUaS5CdWZmZXIgaW1wbCBoYXMgdG8gZ28gdGhyb3VnaCB0aGUgYmluZGluZyBsYXllciBmb3IgcmVhZGluZy93cml0aW5nIGV2ZXJ5IGJ5dGUuXG4gKiBJZiB3ZSBhbnRpY2lwYXRlIHRoZSBCdWZmZXIgc3RheWluZyBvbiB0aGUgSlMgc2lkZSwgSSdtIHdpbGxpbmcgdG8gYmV0IHRoYXQgdGhlIFVpbnQ4QXJyYXlcbiAqIHRoZSBKUyBlbmdpbmUgcHJvdmlkZXMgd291bGQgYmUgKndheSogZmFzdGVyLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0IGJvdGggVGkuQnVmZmVyIGFuZCBOb2RlJ3MgQnVmZmVyIHdlcmUgY3JlYXRlZCBiZWZvcmUgdGhlIEpTIGVuZ2luZXMgaGFkIHR5cGVkIGFycmF5c1xuICogKGFuZCBVaW50OEFycmF5IGluIHBhcnRpY3VsYXIpIGFzIGEgbWVhbnMgb2YgZW5jYXBzdWxhdGluZyBhIGJ5dGUgYXJyYXkuIFdlIHNob3VsZCBjb25zaWRlciBhY2NlcHRpbmdcbiAqIGEgVWludDhBcnJheSBpbiBhbnkgb2Ygb3VyIEFQSXMgdGhhdCB0YWtlIGEgVGkuQnVmZmVyIGFuZCBldmVudHVhbGx5IGRlcHJlY2F0aW5nL3JlbW92aW5nIFRpLkJ1ZmZlci5cbiAqL1xuY29uc3Qge1xuICBBTExfUFJPUEVSVElFUzogQUxMX1BST1BFUlRJRVMkMSxcbiAgT05MWV9FTlVNRVJBQkxFOiBPTkxZX0VOVU1FUkFCTEUkMVxufSA9IHByb3BlcnR5RmlsdGVyO1xuY29uc3QgVkFMSURfRU5DT0RJTkdTID0gWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdsYXRpbjEnLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnXTsgLy8gVXNlZCB0byBjaGVhdCBmb3IgcmVhZC93cml0ZXMgb2YgZG91Ymxlc1xuXG5jb25zdCBkb3VibGVBcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkoMSk7XG5jb25zdCB1aW50OERvdWJsZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZG91YmxlQXJyYXkuYnVmZmVyKTsgLy8gVXNlZCB0byBjaGVhdCB0byByZWFkL3dyaXRlIGZsb2F0c1xuXG5jb25zdCBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbmNvbnN0IHVpbnQ4RmxvYXRBcnJheSA9IG5ldyBVaW50OEFycmF5KGZsb2F0QXJyYXkuYnVmZmVyKTsgLy8gTm9kZS5qcyBkb2VzIHNvbWUgdmVyeSB3ZWlyZCBzdHVmZiBoZXJlXG5cbkZhc3RCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQnVmZmVyJDE7IC8vIG5ldyBGYXN0QnVmZmVyKCkgY2FsbHMgQnVmZmVyIGZ1bmN0aW9uP1xuXG5CdWZmZXIkMS5wcm90b3R5cGUgPSBGYXN0QnVmZmVyLnByb3RvdHlwZTsgLy8gVGhlbiBpdCBoaWphY2tzIEJ1ZmZlcidzIHByb3RvdHlwZSB0byBwb2ludCBhdCBGYXN0QnVmZmVyJ3M/IVxuLy8gRG9lcyB0aGlzIGVmZmVjdGl2ZWx5IG1lYW4gQnVmZmVyIGV4dGVuZHMgVWludDhBcnJheSwgYmVjYXVzZSBGYXN0QnVmZmVyIGRpZD8gVGhpcyBmYWlscyBmb3IgbWVcbi8vIEhvdyB0aGUgaGVsbCBjYW4gd2UgbWFrZSBpdCBoYXBweT8gV2UgcmVhbGx5IHdhbnQgdG8gZXh0ZW5kIFVpbnQ4QXJyYXkgaWYgd2UgY2FuXG4vLyBhZGRCdWZmZXJQcm90b3R5cGVNZXRob2RzKEJ1ZmZlci5wcm90b3R5cGUpOyAvLyBIZXJlJ3Mgd2hlcmUgaXQgaGFuZ3Mgc29tZSBvZiB0aGUgbWV0aG9kc1xuXG5CdWZmZXIkMS5wb29sU2l6ZSA9IDgxOTI7XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGludGVybmFsbHkgaW4gdGhpcyBtb2R1bGUgdG9nZXRoZXIgd2l0aCBgbmV3QnVmZmVyYCB0b1xuICogY3JlYXRlIGEgbmV3IEJ1ZmZlciBpbnN0YW5jZSB3cmFwcGluZyBhIFRpLkJ1ZmZlci5cbiAqXG4gKiBBbHNvIHN1cHBvcnRzIHRoZSBkZXByZWNhdGVkIEJ1ZmZlcigpIGNvbnN0cnVjdG9ycyB3aGljaCBhcmUgc2FmZVxuICogdG8gdXNlIG91dHNpZGUgb2YgdGhpcyBtb2R1bGUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfGludGVnZXJ8c3RyaW5nfFRpLkJ1ZmZlcn0gYXJnIHRoZSB1bmRlcmx5aW5nIGRhdGEvYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IGVuY29kaW5nT3JPZmZzZXQgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZywgb3Igc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciQxKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuYXBpTmFtZSAhPT0gJ1RpLkJ1ZmZlcicpIHtcbiAgICBzaG93RmxhZ2dlZERlcHJlY2F0aW9uKCk7XG5cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIFwic3RyaW5nXCIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQnVmZmVyJDEuYWxsb2MoYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyJDEuZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH0gLy8gVGhlIHNsb3cgY2FzZSAtIHdlJ3JlIHdyYXBwaW5nIGEgVGkuQnVmZmVyXG5cblxuICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJbXXxCdWZmZXJ8c3RyaW5nfSB2YWx1ZSB2YWx1ZSB3ZSdyZSB3cmFwcGluZ1xuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gZW5jb2RpbmdPck9mZnNldCBlbmNvZGluZyBvZiB0aGUgc3RyaW5nLCBvciBzdGFydCBvZmZzZXQgb2YgYXJyYXkvYnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZyb21CdWZmZXIodmFsdWUpO1xuICAgIH0gLy8gV2Ugd2FudCB0byBsaW1pdCB0aGUgdXNlIG9mIFNsb3dCdWZmZXJzIHRvIG9ubHkgd2hlbiB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlciwgaG9wZWZ1bGx5IVxuXG5cbiAgICBpZiAodmFsdWUuYXBpTmFtZSAmJiB2YWx1ZS5hcGlOYW1lID09PSAnVGkuQnVmZmVyJykge1xuICAgICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFwndmFsdWVcXCcgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZTogXFwnc3RyaW5nXFwnLCBcXCdBcnJheVxcJywgXFwnQnVmZmVyXFwnLCBcXCdUaS5CdWZmZXJcXCcnKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9iaiBBcnJheUJ1ZmZlciB0byB3cmFwXG4gKiBAcGFyYW0ge251bWJlcn0gW2J5dGVPZmZzZXQ9MF0gYnl0ZSBvZmZzdGUgdG8gYmVnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBsZW5ndGggdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb252ZXJ0IGJ5dGVPZmZzZXQgdG8gaW50ZWdlclxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0O1xuXG4gICAgaWYgKE51bWJlci5pc05hTihieXRlT2Zmc2V0KSkge1xuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuXG4gIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygnb2Zmc2V0Jyk7XG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSBtYXhMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udmVydCBsZW5ndGggdG8gbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcblxuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoJ2xlbmd0aCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byB3cmFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gY2hhcmFjdGVyIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gIH1cblxuICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIGNvbnN0IGJsb2IgPSBUaS5VdGlscy5iYXNlNjRkZWNvZGUodmFsdWUpO1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihibG9iLnRvQXJyYXlCdWZmZXIoKSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheShzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKSk7XG4gIH0gLy8gQ29udmVydCB0aGUgU2xvd0J1ZmZlciB0byBhIGZhc3QgYnVmZmVyIGJ5IGp1c3QgY29weWluZyBieXRlcyByZWN1cnNpdmVseSBoZXJlXG5cblxuICByZXR1cm4gZnJvbUJ1ZmZlcihTbG93QnVmZmVyLmZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcltdfFVpbnQ4QXJyYXl8YXJyYXl9IHZhbHVlIHZhbHVlcyB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFycmF5KHZhbHVlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7XG4gIH1cblxuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBJZGVhbGx5IHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHdlJ3JlIGNvcHlpbmcgYSBTbG93QnVmZmVyIGludG8gYSBuZXcgRmFzdEJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIGJ1ZmZlciB0byBjb3B5XG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlcih2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFsdWUuY29weShidWZmZXIsIDAsIDAsIGxlbmd0aCk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIkMSwgVWludDhBcnJheSk7IC8vIFdoYXQgaXMgdGhpcyBkb2luZz8hIE1ha2luZyBCdWZmZXIucHJvdG90eXBlIHBvaW50IGF0IFVpbnQ4QXJyYXkgbm93XG5cbi8qKlxuICogMCBpcyByZXR1cm5lZCBpZiB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgYnVmXG4gKiAxIGlzIHJldHVybmVkIGlmIHRhcmdldCBzaG91bGQgY29tZSBiZWZvcmUgYnVmIHdoZW4gc29ydGVkLlxuICogLTEgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IHNob3VsZCBjb21lIGFmdGVyIGJ1ZiB3aGVuIHNvcnRlZC5cbiAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXQgQnVmZmVyIHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gaW5kZXggdG8gc3RhcnQgaW4gdGFyZ2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0YXJnZXRFbmQ9dGFyZ2V0Lmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRhcmdldFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlU3RhcnQ9MF0gaW5kZXggdG8gc3RhcnQgaW4gdGhpcyBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRoaXMgQnVmZmVyXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9XG5cbiAgaWYgKHRhcmdldFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRTdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc291cmNlU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmICh0YXJnZXRFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldEVuZCA9IHRhcmdldC5sZW5ndGg7XG4gIH1cblxuICBpZiAoc291cmNlRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSAvLyBFUlJfT1VUX09GX1JBTkdFIGlzIHRocm93biBpZiB0YXJnZXRTdGFydCA8IDAsIHNvdXJjZVN0YXJ0IDwgMCwgdGFyZ2V0RW5kID4gdGFyZ2V0LmJ5dGVMZW5ndGgsIG9yIHNvdXJjZUVuZCA+IHNvdXJjZS5ieXRlTGVuZ3RoXG5cblxuICBpZiAodGFyZ2V0U3RhcnQgPCAwIHx8IHNvdXJjZVN0YXJ0IDwgMCB8fCB0YXJnZXRFbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHNvdXJjZUVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpOyAvLyBGSVhNRTogc2V0IFwiY29kZVwiIHRvIEVSUl9JTkRFWF9PVVRfT0ZfUkFOR0VcbiAgfSAvLyBVc2Ugc2xpY2VzIHRvIG1ha2UgdGhlIGxvb3AgZWFzaWVyXG5cblxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNsaWNlKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICBjb25zdCBzb3VyY2VMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICBjb25zdCBkZXN0ID0gdGFyZ2V0LnNsaWNlKHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQpO1xuICBjb25zdCBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHNvdXJjZUxlbmd0aCwgZGVzdExlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZGVzdC5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlLmdldEFkanVzdGVkSW5kZXgoaSk7XG5cbiAgICBpZiAodGFyZ2V0VmFsdWUgIT09IHNvdXJjZVZhbHVlKSB7XG4gICAgICAvLyBObyBtYXRjaCEgUmV0dXJuIDEgb3IgLTEgYmFzZWQgb24gd2hhdCBpcyBncmVhdGVyIVxuICAgICAgaWYgKHNvdXJjZVZhbHVlIDwgdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gLy8gc29ydCBiYXNlZCBvbiBsZW5ndGghXG5cblxuICBpZiAoc291cmNlTGVuZ3RoIDwgZGVzdExlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChzb3VyY2VMZW5ndGggPiBkZXN0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn07XG4vKipcbiAqIENvcGllcyBmcm9tIHRoaXMgdG8gdGFyZ2V0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IGRlc3RpbmF0aW9uIHdlJ3JlIGNvcHlpbmcgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gc3RhcnQgaW5kZXggdG8gY29weSBpbnRvIGluIGRlc3RpbmF0aW9uIEJ1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlU3RhcnQ9MF0gc3RhcnQgaW5kZXggdG8gY29weSBmcm9tIHdpdGhpbiBgdGhpc2BcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gZW5kIGluZGV4IHRvIGNvcHkgZnJvbSB3aXRoaW4gYHRoaXNgXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIGNvcGllZFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICBpZiAodGFyZ2V0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldFN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzb3VyY2VTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlU3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc291cmNlU3RhcnQgPT09IHNvdXJjZUVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBUT0RPOiBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cblxuXG4gIGxldCBsZW5ndGggPSBzb3VyY2VFbmQgLSBzb3VyY2VTdGFydDsgLy8gQ2FwIGxlbmd0aCB0byByZW1haW5pbmcgYnl0ZXMgaW4gdGFyZ2V0IVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydDtcblxuICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyByZW1haW5pbmc7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IC8vIERldGVybWluZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdlJ2xsIGNvcHksIGNvbnN0cmFpbiBieSBzb3VyY2UgYnVmZmVyIGxlbmd0aCBhcyB3ZWxsIGFzIHRhcmdldCAoYWJvdmUpXG5cblxuICBsZXQgbnVtQnl0ZXMgPSBsZW5ndGg7XG4gIGNvbnN0IHNvdXJjZUxlbiA9IHRoaXMubGVuZ3RoIC0gc291cmNlU3RhcnQ7XG5cbiAgaWYgKG51bUJ5dGVzID4gc291cmNlTGVuKSB7XG4gICAgbnVtQnl0ZXMgPSBzb3VyY2VMZW47XG4gIH0gLy8gVE9ETzogaGFuZGxlIG92ZXJsYXAgd2hlbiB0YXJnZXQgPT09IHRoaXMhXG4gIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gdGFrZSB0YXJnZXQgYnl0ZU9mZnNldCBpbnRvIGFjY291bnQgaGVyZT9cblxuXG4gIGxldCBzb3VyY2UgPSB0aGlzO1xuXG4gIGlmIChzb3VyY2VTdGFydCAhPT0gMCB8fCBzb3VyY2VFbmQgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHNvdXJjZVN0YXJ0LCBudW1CeXRlcyk7XG4gIH1cblxuICB0YXJnZXQuc2V0KHNvdXJjZSwgdGFyZ2V0U3RhcnQpO1xuICByZXR1cm4gbnVtQnl0ZXM7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGl0ZXJhdG9yIG9mIFtpbmRleCwgYnl0ZV0gcGFpcnMgZnJvbSB0aGUgY29udGVudHMgb2YgYnVmLlxuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG4vLyBUT0RPOiBJcyB0aGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBTbG93QnVmZmVyP1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBidWZmZXIgPSB0aGlzO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IGVudHJ5SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IFtuZXh0SW5kZXgsIGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KG5leHRJbmRleCldLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5SXRlcmF0b3I7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyQnVmZmVyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIob3RoZXJCdWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG5cbiAgaWYgKG90aGVyQnVmZmVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyQnVmZmVyKSA9PT0gMDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVSW50OEFycmF5fGludGVnZXJ9IHZhbHVlIFRoZSB2YWx1ZSB3aXRoIHdoaWNoIHRvIGZpbGwgYGJ1ZmAuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIGZpbGwgYGJ1ZmBcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gV2hlcmUgdG8gc3RvcCBmaWxsaW5nIGJ1ZiAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGVuY29kaW5nIGZvciBgdmFsdWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgY29uc3Qgb2Zmc2V0VHlwZSA9IHR5cGVvZiBvZmZzZXQ7XG5cbiAgaWYgKG9mZnNldFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gdmFsdWUgc3VwcGxpZWRcbiAgICBvZmZzZXQgPSAwO1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9IGVsc2UgaWYgKG9mZnNldFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgIC8vIHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICB0aGlzLl9maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSk7XG5jb25zdCBUeXBlZEFycmF5UHJvdG9fYnl0ZUxlbmd0aCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKS5nZXQ7XG5jb25zdCBUeXBlZEFycmF5RmlsbCA9IFR5cGVkQXJyYXlQcm90b3R5cGUuZmlsbDtcblxuQnVmZmVyJDEucHJvdG90eXBlLl9maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBPT0IgY2hlY2tcbiAgICBjb25zdCBieXRlTGVuID0gVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGguY2FsbCh0aGlzKTtcbiAgICBjb25zdCBmaWxsTGVuZ3RoID0gZW5kIC0gb2Zmc2V0O1xuXG4gICAgaWYgKG9mZnNldCA+IGVuZCB8fCBmaWxsTGVuZ3RoICsgb2Zmc2V0ID4gYnl0ZUxlbikge1xuICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpO1xuICAgIH1cblxuICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgdmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBidWZUb0ZpbGxXaXRoID0gU2xvd0J1ZmZlci5mcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuXG4gICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdmFsaWQgZmlsbCBkYXRhJyk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDEpIHtcbiAgICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gbXVsdGlwbGUgYnl0ZSBmaWxsIVxuXG5cbiAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZSAob24gYHRoaXNgLCBub3Qgb24gdGhlIGJ1ZmZlciB3ZSBqdXN0IGNyZWF0ZWQpP1xuICAgICAgY29uc3QgZmlsbENoYXIgPSBidWZUb0ZpbGxXaXRoLl90aUJ1ZmZlcltpICUgZmlsbEJ1Zkxlbmd0aF07XG4gICAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIG9mZnNldCwgZmlsbENoYXIpO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGludGVnZXJ9IHZhbHVlIFdoYXQgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbYnl0ZU9mZnNldD0wXSBXaGVyZSB0byBiZWdpbiBzZWFyY2hpbmcgaW4gYnVmLiBJZiBuZWdhdGl2ZSwgdGhlbiBvZmZzZXQgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBlbmQgb2YgYnVmXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gSWYgdmFsdWUgaXMgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgZm9yIGluIGJ1ZlxuICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZSBpbiBidWYsIG9yIC0xIGlmIGJ1ZiBkb2VzIG5vdCBjb250YWluIHZhbHVlLlxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGJ1ZmZlcj8gY2FuJ3QgZmluZCBhbnl0aGluZyFcbiAgICByZXR1cm4gLTE7XG4gIH0gLy8gaWYgYnl0ZU9mZnNldCBpcyB1bmRlZmluZWQsIG1ha2UgaXQgMFxuXG5cbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlmIGl0J3MgYSBzdHJpbmcsIHRoYXQncyBhY3R1YWxseSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSAvLyBpZiB3ZSBkb24ndCBoYXZlIGFuIGVuY29kaW5nIHlldCwgdXNlIHV0ZjhcblxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXNcbiAgICBieXRlT2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0O1xuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAvLyBzdGlsbCBuZWdhdGl2ZT8gc3RhcnQgYXQgMFxuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIGNhbid0IGZpbmQgcGFzdCBlbmQgb2YgYnVmZmVyIVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSAmPSAweEZGOyAvLyBjbGFtcCB0byAyNTVcbiAgICAvLyBUaGlzIGlzIGEgc2ltcGxlciBjYXNlLCB3ZSBoYXZlIGEgc2luZ2xlIGJ5dGUgd2UgbmVlZCB0byBzZWFyY2ggZm9yXG4gICAgLy8gc28ganVzdCBsb29wIHRocm91Z2ggYW5kIHRyeSB0byBmaW5kIGl0XG5cbiAgICByZXR1cm4gaW5kZXhPZih0aGlzLCB2YWx1ZSwgYnl0ZU9mZnNldCk7XG4gIH0gLy8gY29lcmNlIGEgc3RyaW5nIHRvIGEgQnVmZmVyXG5cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICB9IC8vIHZhbHVlIGlzIG5vdyBhIEJ1ZmZlci4uLlxuXG5cbiAgY29uc3QgbWF0Y2hMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBuZXZlciBmaW5kIGVtcHR5IHZhbHVlIVxuICB9XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID09PSAxKSB7XG4gICAgLy8gc2ltcGxlIGNhc2UsIG1hdGNoIG9uZSBieXRlIVxuICAgIHJldHVybiBpbmRleE9mKHRoaXMsIHZhbHVlWzBdLCBieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSBieXRlT2Zmc2V0O1xuICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID4gdGhpc0xlbmd0aCkge1xuICAgIHJldHVybiAtMTsgLy8gY2FuJ3QgbWF0Y2ggaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoaXMgQnVmZmVyIVxuICB9IC8vIEZJWE1FOiBDYW4gd2UgcmV3cml0ZSB0aGlzIGluIGEgbGVzcyBmdW5reSB3YXk/XG4gIC8vIEZJWE1FOiBDYW4gc3RvcCBlYXJsaWVyIGJhc2VkIG9uIG1hdGNoTGVuZ3RoIVxuXG5cbiAgZmlyc3RNYXRjaDogd2hpbGUgKGN1cnJlbnRJbmRleCA8IHRoaXNMZW5ndGgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgIC8vIG1hdGNoIGZpcnN0IGJ5dGUhXG4gICAgbGV0IGZpcnN0Qnl0ZU1hdGNoID0gaW5kZXhPZih0aGlzLCB2YWx1ZVswXSwgY3VycmVudEluZGV4KTtcblxuICAgIGlmIChmaXJzdEJ5dGVNYXRjaCA9PT0gLTEpIHtcbiAgICAgIC8vIGNvdWxkbid0IGV2ZW4gbWF0Y2ggdGhlIHZlcnkgZmlyc3QgYnl0ZSwgc28gbm8gbWF0Y2ggb3ZlcmFsbCFcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IC8vIG9rLCB3ZSBmb3VuZCB0aGUgZmlyc3QgYnl0ZSwgbm93IHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBuZXh0IGNvbnNlY3V0aXZlIGJ5dGVzIG1hdGNoIVxuXG5cbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8IG1hdGNoTGVuZ3RoOyB4KyspIHtcbiAgICAgIGlmIChmaXJzdEJ5dGVNYXRjaCArIHggPj0gdGhpc0xlbmd0aCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcblxuICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tmaXJzdEJ5dGVNYXRjaCArIHhdICE9PSB2YWx1ZVt4XSkge1xuICAgICAgICAvLyBkaWRuJ3QgbWF0Y2ghXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpcnN0Qnl0ZU1hdGNoICsgMTsgLy8gbW92ZSBwYXN0IG91ciBmaXJzdCBtYXRjaFxuXG4gICAgICAgIGNvbnRpbnVlIGZpcnN0TWF0Y2g7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbGFiZWxzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0Qnl0ZU1hdGNoOyAvLyB0aGUgcmVzdCBtYXRjaGVkLCBodXJyYXkhXG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBteUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBuZXh0SW5kZXgsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQ2NEFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDY0QXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhEb3VibGVBcnJheVs3XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzZdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs0XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQ2NEFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDY0QXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhEb3VibGVBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs2XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0XG4gKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDMyQXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBmbG9hdEFycmF5WzBdO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAqIEByZXR1cm5zIHtmbG9hdH0gUmVhZHMgYSAzMi1iaXQgZmxvYXQgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTsgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDMyQXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0MzJBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcblxuICB1aW50OEZsb2F0QXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQ4KG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgNCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xufTtcbi8qKlxuICogUmVhZHMgYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgYW5kIGludGVycHJldHMgdGhlIHJlc3VsdCBhcyBhIHR3bydzIGNvbXBsZW1lbnQgc2lnbmVkIHZhbHVlLiBTdXBwb3J0cyB1cCB0byA0OCBiaXRzIG9mIGFjY3VyYWN5LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCB1bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCBieXRlTGVuZ3RoKTtcbn07XG4vKipcbiAqIFJlYWRzIGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IGFuZCBpbnRlcnByZXRzIHRoZSByZXN1bHQgYXMgYSB0d28ncyBjb21wbGVtZW50IHNpZ25lZCB2YWx1ZS4gU3VwcG9ydHMgdXAgdG8gNDggYml0cyBvZiBhY2N1cmFjeS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIHJldHVybiB0aGlzW29mZnNldF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7IC8vIGZpcnN0IGJ5dGUgc2hpZnRlZCBhbmQgT1InZCB3aXRoIHNlY29uZCBieXRlXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTsgLy8gZmlyc3QgYnl0ZSBPUidkIHdpdGggc2Vjb25kIGJ5dGUgc2hpZnRlZFxuXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOyAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGZpcnN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxuICAvLyAoYmVjYXVzZSBiaXQtd2lzZSBvcGVyYXRvcnMgYXNzdW1lIGEgMzItYml0IG51bWJlcilcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDA7IC8vIHJhdGhlciB0aGFuIHNoaWZ0aW5nIGJ5IDw8IDI0LCBtdWx0aXBseSB0aGUgbGFzdCBieXRlIGFuZCBhZGQgaXQgaW4gc28gd2UgZG9uJ3QgcmV0YWluIHRoZSBcInNpZ24gYml0XCJcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7IC8vIHdlIHVzZSBhIG11bHRpcGxlciBmb3IgZWFjaCBieXRlXG4gIC8vIHdlJ3JlIGRvaW5nIHRoZSBzYW1lIGxvb3AgYXMgI3JlYWRVSW50TEUsIGp1c3QgYmFja3dhcmRzIVxuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICByZXN1bHQgKz0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwOyAvLyBtb3ZlIG11bHRpcGxpZXIgdG8gbmV4dCBieXRlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGxldCBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSB0aGlzLmdldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSkgKiBtdWx0aXBsaWVyO1xuICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7IC8vIG1vdmUgbXVsdGlwbGllciB0byBuZXh0IGJ5dGVcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBXaGVyZSB0aGUgbmV3IGBCdWZmZXJgIHdpbGwgc3RhcnQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmQ9dGhpcy5sZW5ndGhdIFdoZXJlIHRoZSBuZXcgQnVmZmVyIHdpbGwgZW5kIChub3QgaW5jbHVzaXZlKS4gRGVmYXVsdDogYGJ1Zi5sZW5ndGhgLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXNMZW5ndGggKyBzdGFydDtcblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIC8vIGlmIHRoaXMgaXMgc3RpbGwgbmVnYXRpdmUsIHVzZSAwICh0aGF0IG1hdGNoZXMgTm9kZSlcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoICsgZW5kO1xuICB9IC8vIFNwZWNpZnlpbmcgZW5kIGdyZWF0ZXIgdGhhbiBidWYubGVuZ3RoIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGF0IG9mIGVuZCBlcXVhbCB0byBidWYubGVuZ3RoLlxuXG5cbiAgaWYgKGVuZCA+IHRoaXNMZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICB9IC8vIFdoYXQgaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydD9cblxuXG4gIGxldCBsZW5ndGggPSBlbmQgLSBzdGFydDtcblxuICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICBsZW5ndGggPSAwOyAvLyByZXR1cm4gZW1wdHkgdmlldyBvZiBCdWZmZXIhIHJldGFpbiBieXRlIG9mZnNldCwgc2V0IGxlbmd0aCB0byAwXG4gIH0gLy8gV3JhcCB0aGUgc2FtZSBBcnJheUJ1ZmZlciBvYmplY3QgYnV0IHNwZWNpZnkgdGhlIHN0YXJ0L2VuZCB0byBcImNyb3BcIiB3aXRoXG5cblxuICByZXR1cm4gdGhpcy5fc2xpY2UodGhpcy5ieXRlT2Zmc2V0ICsgc3RhcnQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuX3NsaWNlID0gZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0aGlzLmJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kPXRoaXMubGVuZ3RoXSBXaGVyZSB0aGUgbmV3IEJ1ZmZlciB3aWxsIGVuZCAobm90IGluY2x1c2l2ZSkuIERlZmF1bHQ6IGBidWYubGVuZ3RoYC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuc3ViYXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiAyLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJyk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIGZpcnN0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgMzItYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIGNvbnN0IHRoaXJkID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAyKTtcbiAgICBjb25zdCBmb3VydGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDMpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpLCBmb3VydGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMSwgdGhpcmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMiwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDMsIGZpcnN0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgNjQtYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDguXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIGNvbnN0IHRoaXJkID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAyKTtcbiAgICBjb25zdCBmb3VydGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDMpO1xuICAgIGNvbnN0IGZpZnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA0KTtcbiAgICBjb25zdCBzaXh0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNSk7XG4gICAgY29uc3Qgc2V2ZW50aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNik7XG4gICAgY29uc3QgZWlnaHRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA3KTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgZWlnaHRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIHNldmVudGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMiwgc2l4dGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMywgZmlmdGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNCwgZm91cnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDUsIHRoaXJkKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDYsIHNlY29uZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA3LCBmaXJzdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHNsaWNlIHdvcmtpbmcgb24gXCJBcnJheS1saWtlXCIgb2JqZWN0cyAoanVzdCBsaWtlIGBhcmd1bWVudHNgKVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlI0FycmF5LWxpa2Vfb2JqZWN0c1xuICAgIGRhdGE6IFtdLnNsaWNlLmNhbGwodGhpcylcbiAgfTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gVGhlIGJ5dGUgb2Zmc2V0IHRvIHN0YXJ0IGRlY29kaW5nIGF0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFRoZSBieXRlIG9mZnNldCB0byBzdG9wIGRlY29kaW5nIGF0IChub3QgaW5jbHVzaXZlKS4gYGJ1Zi5sZW5ndGhgIGRlZmF1bHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgLy8gZmFzdCBjYXNlIG9mIG5vIGFyZ3NcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy50b1RpQnVmZmVyKCkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA+PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7IC8vIHN0YXJ0IGlzIHBhc3QgZW5kIG9mIGJ1ZmZlciwgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKGVuZCA+IGxlbmd0aCB8fCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJykge1xuICAgIC8vIG5vIGVuZCBzcGVjaWZpZWQsIG9yIHBhc3QgZW5kIG9mIGJ1ZmZlciwgdXNlIGxlbmd0aCBvZiBidWZmZXJcbiAgICBlbmQgPSBsZW5ndGg7XG4gIH0gLy8gZWxzZSBrZWVwIGVuZCBhcyBwYXNzZWQgaW5cblxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7IC8vIGlmIGVuZCBpcyBiZWZvcmUgc3RhcnQgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9IC8vIElmIHN0YXJ0ICE9PSAwIGFuZCBlbmQgIT09IGxlbmd0aCwgbWF5YmUgd2Ugc2hvdWxkIGRvIGEgQnVmZmVyLnN1YmFycmF5L3NsaWNlIG92ZXIgdGhlIHJhbmdlIGFuZCBjYWxsIHRvU3RyaW5nKCkgb24gdGhhdD9cblxuXG4gIGlmIChzdGFydCAhPT0gMCB8fCBlbmQgIT09IGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfSAvLyBiYXNlIGNhc2UsIHN0YXJ0IGlzIDAsIGVuZCBpcyBsZW5ndGhcblxuXG4gIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpOyAvLyBUaHJvdyBpZiBiYWQgZW5jb2RpbmchXG5cbiAgICBpZiAoIUJ1ZmZlciQxLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHRoaXMudG9UaUJ1ZmZlcigpLnRvU3RyaW5nKCk7IC8vIHdlIHJldHVybiB1dGYtOCBieSBkZWZhdWx0IG5hdGl2ZWx5XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIFRpLlV0aWxzLmJhc2U2NGVuY29kZSh0aGlzLnRvVGlCdWZmZXIoKS50b0Jsb2IoKSkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gdGhpcy5oZXhTbGljZSgwLCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnbGF0aW4xJyB8fCBlbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICBsZXQgbGF0aW4xU3RyaW5nID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgICBsYXRpbjFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldEFkanVzdGVkSW5kZXgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXRpbjFTdHJpbmc7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICBsZXQgYXNjaWkgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHdlIHN0b3JlIGJ5dGVzICg4LWJpdCksIGJ1dCBhc2NpaSBpcyA3LWJpdC4gTm9kZSBcIm1hc2tzXCIgdGhlIGxhc3QgYml0IG9mZiwgc28gbGV0J3MgZG8gdGhlIHNhbWVcbiAgICAgIGFzY2lpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHg3Rik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzY2lpO1xuICB9IC8vIFVDUzIvVVRGMTZcblxuXG4gIHJldHVybiB0aGlzLnVjczJTbGljZSgwLCBsZW5ndGgpO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmdldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXNbaW5kZXhdO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnNldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gIHJldHVybiB0aGlzW2luZGV4XSA9IHZhbHVlO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmhleFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGhleFN0ciA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgLy8gZWFjaCBvbmUgaXMgYSBcImJ5dGVcIlxuICAgIGxldCBoZXggPSAodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHhmZikudG9TdHJpbmcoMTYpO1xuICAgIGhleCA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgaGV4U3RyICs9IGhleDtcbiAgfVxuXG4gIHJldHVybiBoZXhTdHI7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUudWNzMlNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgLy8gdXRmLTE2L3Vjcy0yIGlzIDItYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgIGNvbnN0IGJ5dGUxID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkrKyk7XG4gICAgY29uc3QgYnl0ZTIgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSsrKTtcbiAgICBjb25zdCBjb2RlX3VuaXQgPSAoYnl0ZTIgPDwgOCkgKyBieXRlMTsgLy8gd2UgbWFzaCB0b2dldGhlciB0aGUgdHdvIGJ5dGVzXG5cbiAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZV91bml0KTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gbWV0aG9kIGZvciBpbnRlcmFjdGluZyB3aXRoIFRpIEFQSXMgdGhhdCByZXF1aXJlIGEgVGkuQnVmZmVyXG4gKiBAcmV0dXJucyB7VGkuQnVmZmVyfSB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXIgYmFja2luZyB0aGlzIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnRvVGlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHRpQnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICBsZW5ndGg6IHRoaXMubGVuZ3RoXG4gIH0pO1xuICBjb3B5QnVmZmVyKHRoaXMsIHRpQnVmZmVyLCAwLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aUJ1ZmZlcjtcbn07XG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBzcmMgc291cmNlIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBkZXN0IGRlc3RpbmF0aW9uIFRpLkJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHN0YXJ0IG9mZnNldCB3ZSdyZSBjb3B5aW5nIHRvIGluIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge2ludGVnZXJ9IGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgY29waWVkXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgZGVzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgY29uc3QgZGVzdExlbmd0aCA9IGRlc3QubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRlc3RJbmRleCA9IGkgKyBvZmZzZXQ7IC8vIGFyZSB3ZSB0cnlpbmcgdG8gd3JpdGUgcGFzdCBlbmQgb2YgZGVzdGluYXRpb24/IE9yIHJlYWQgcGFzdCBlbmQgb2Ygc291cmNlPyBTdG9wIVxuXG4gICAgaWYgKGRlc3RJbmRleCA+PSBkZXN0TGVuZ3RoIHx8IGkgPj0gc3JjTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXN0W2Rlc3RJbmRleF0gPSBzcmNbaV07XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBmb3IgYnVmIHZhbHVlcyAoYnl0ZXMpXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IE1vdmUgdG8gU2xvd0J1ZmZlcj9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBidWZmZXIgPSB0aGlzO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IG15SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KG5leHRJbmRleCksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG4vKipcbiAqIENhbGxlZCB3aGVuIGJ1ZmZlciBpcyB1c2VkIGluIGEgZm9yLi5vZiBsb29wLiBEZWxlZ2F0ZXMgdG8gI3ZhbHVlcygpXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IE1vdmUgdG8gU2xvd0J1ZmZlcj9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG59O1xuLyoqXG4gKiBXcml0ZXMgc3RyaW5nIHRvIGJ1ZiBhdCBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgaW4gZW5jb2RpbmcuXG4gKiBUaGUgbGVuZ3RoIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBJZiBidWYgZGlkIG5vdCBjb250YWluIGVub3VnaCBzcGFjZSB0b1xuICogZml0IHRoZSBlbnRpcmUgc3RyaW5nLCBvbmx5IHBhcnQgb2Ygc3RyaW5nIHdpbGwgYmUgd3JpdHRlbi4gSG93ZXZlciwgcGFydGlhbGx5IGVuY29kZWRcbiAqIGNoYXJhY3RlcnMgd2lsbCBub3QgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHdyaXRlIHRvIGBidWZgLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZSBzdHJpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD1idWYubGVuZ3RoIC0gb2Zmc2V0XSBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIHN0cmluZ1xuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIHdlIGNhcCBgbGVuZ3RoYCBhdCB0aGUgbGVuZ3RoIG9mIG91ciBidWZmZXJcbiAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcblxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JzsgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzIG9mIG91ciBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkvYnVmZmVyXG5cbiAgY29uc3Qgc3JjID0gZnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nKTsgLy8gRklYTUU6IENhbiB3ZSBsZXQgaXQga25vdyB0byBvbmx5IGNvbnZlcnQgYHJlbWFpbmluZ2AgYnl0ZXM/XG4gIC8vIHRoZW4gc3RpY2sgdGhhdCBpbnRvIG91ciBidWZmZXIgc3RhcnRpbmcgYXQgYG9mZnNldGAhXG5cbiAgcmV0dXJuIHNyYy5jb3B5KHRoaXMsIG9mZnNldCwgMCwgbGVuZ3RoKTtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0xMjgsIDEyNyk7XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICAvLyBqdXN0IHdyaXRlIGl0IG5vcm1hbGx5XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnZlcnQgZnJvbSBzaWduZWQgdG8gMidzIGNvbXBsZW1lbnQgYml0c1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIDB4RkYgKyB2YWx1ZSArIDEpOyAvLyBtYXggdmFsdWUsIHBsdXMgdGhlIG5lZ2F0aXZlIG51bWJlciwgYWRkIG9uZVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDgpOyAvLyBqdXN0IHNoaWZ0IG92ZXIgYSBieXRlXG5cbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhGRik7IC8vIG1hc2sgdG8gZmlyc3QgYnl0ZVxuXG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhGRik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlICYgMHhGRik7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4RkYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlID4+PiAyNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBtaW5NYXhCYXNlID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcblxuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdmFsdWUgPSBtaW5NYXhCYXNlICogMiArIHZhbHVlO1xuICB9XG5cbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNvbnN0IG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtbWluTWF4QmFzZSwgbWluTWF4QmFzZSAtIDEpO1xuXG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICB2YWx1ZSA9IG1pbk1heEJhc2UgKiAyICsgdmFsdWU7XG4gIH1cblxuICBsZXQgbXVsdGlwbGllciA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgMjU1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUpO1xuICByZXR1cm4gb2Zmc2V0ICsgMTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDY1NTM1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNDI5NDk2NzI5NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiAyNCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNDI5NDk2NzI5NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgPj4+IDI0KTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTsgLy8gVE9ETzogSW1wbGVtZW50IHJlbWFpbmluZyBpbnN0YW5jZSBtZXRob2RzOlxuLy8gYnVmLmxhc3RJbmRleE9mKHZhbHVlWywgYnl0ZU9mZnNldF1bLCBlbmNvZGluZ10pXG4vLyBidWYucmVhZEJpZ0ludDY0QkUoW29mZnNldF0pXG4vLyBidWYucmVhZEJpZ0ludDY0TEUoW29mZnNldF0pXG4vLyBidWYucmVhZEJpZ1VJbnQ2NEJFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdVSW50NjRMRShbb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ0ludDY0QkUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnSW50NjRMRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBidWYud3JpdGVCaWdVSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBidWYud3JpdGVCaWdVSW50NjRMRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBGSVhNRTogV2UgbmVlZCB0byBtaW5pbWl6ZSB1c2luZyBhIGJhY2tpbmcgVGkuQnVmZmVyIHdoZW5ldmVyIHBvc3NpYmxlLCBiZWNhdXNlXG4vLyBnb2luZyBiYWNrIGFuZCBmb3J0aCBhY3Jvc3MgdGhlIGJyaWRnZSBmb3IgZXZlcnkgYnl0ZSBpcyAqdmVyeSogZXhwZW5zaXZlXG4vLyBJZGVhbGx5IHdlIHNob3VsZCBoYXZlIGEgXCJTbG93QnVmZmVyXCIgdGhhdCBpcyB1c2VkIHdoZW4gd2UgZXhwbGljaXRseSB3cmFwIGEgVGkuQnVmZmVyXG4vLyBTbyB0aGF0IHdyaXRlcyBhcmUgcGFzc2VkIHRocm91Z2guIE90aGVyd2lzZSB3ZSBzaG91bGQgYXZvaWQgdXNpbmcgb25lIGF0IGFsbCBjb3N0c1xuLy8gaS5lLiB3aGVuIHdlIGRvIEJ1ZmZlci5jb25jYXQgYW5kIGFyZSBvbmx5IGRvaW5nIHJlYWRzIC0gd2h5IGRvIHdlIG5lZWQgYSBUaS5CdWZmZXI/XG4vLyBDYW4gd2UgaGF2ZSBUaS5CdWZmZXIgcmVhbGx5IGp1c3Qgd3JhcCBhIFVpbnQ4QXJyYXkgYW5kIGFkZCBpdCdzIG93biBtZXRob2RzP1xuXG5cbkJ1ZmZlciQxLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIobGVuZ3RoKTtcbn07XG5cbkJ1ZmZlciQxLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5hbGxvYyA9IGZ1bmN0aW9uIChsZW5ndGgsIGZpbGwgPSAwLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBidWYgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuXG4gIGlmIChmaWxsICE9PSAwKSB7XG4gICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fEFycmF5QnVmZmVyfFNoYXJlZEFycmF5QnVmZmVyfSBzdHJpbmcgb3JpZ2luYWwgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgd2hvc2UgYnl0ZSBsZW5ndGggd2UgbmVlZCB0byBncmFiXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoQnVmZmVyJDEuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7IC8vIHJldHVybiBCdWZmZXIncyBsZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7IC8vIFR5cGVkQXJyYXksIEFycmF5QnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlciwgRGF0YVZpZXdcbiAgfVxuXG4gIGxldCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xuXG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBsZW5ndGg7XG5cbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmMTYtbGUnOlxuICAgICAgcmV0dXJuIDIgKiBsZW5ndGg7XG5cbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIGxlbmd0aCAvIDI7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gU3VidHJhY3QgdXAgdG8gdHdvIHBhZGRpbmcgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nIVxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBzdHJpbmcuY2hhckF0KGxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGxlbmd0aCAqIDMgLyA0KTtcbiAgICAvLyBkcm9wIGZyYWN0aW9uYWwgdmFsdWVcbiAgfVxuXG4gIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xufTtcblxuQnVmZmVyJDEuY29tcGFyZSA9IGZ1bmN0aW9uIChidWYxLCBidWYyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIoYnVmMSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJidWYxXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9IC8vIFRPRE86IFdyYXAgVUludDhBcnJheSBhcmdzIGluIGJ1ZmZlcnM/XG5cblxuICByZXR1cm4gYnVmMS5jb21wYXJlKGJ1ZjIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXXxVSW50OEFycmF5W119IGxpc3QgbGlzdCBvZiBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbExlbmd0aF0gVG90YWwgbGVuZ3RoIG9mIHRoZSBCdWZmZXIgaW5zdGFuY2VzIGluIGxpc3Qgd2hlbiBjb25jYXRlbmF0ZWQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7IC8vIG9uZSBlbXB0eSBCdWZmZXIhXG4gIH0gLy8gYWxsb2NhdGUgb25lIEJ1ZmZlciBvZiBgdG90YWxMZW5ndGhgPyBDYXAgYXQgdG90YWxMZW5ndGg/XG5cblxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMDsgLy8gZ2VuZXJhdGUgdGhlIHRvdGFsIGxlbmd0aCBmcm9tIGVhY2ggYnVmZmVyJ3MgbGVuZ3RoP1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICBidWYuY29weShyZXN1bHQsIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBidWYubGVuZ3RoO1xuXG4gICAgaWYgKHBvc2l0aW9uID49IHRvdGFsTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHBvc3NpYmxlIGVuY29kaW5nIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuQnVmZmVyJDEuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBWQUxJRF9FTkNPRElOR1MuaW5jbHVkZXMoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSk7XG59O1xuLyoqXG4gKiBAcGFyYW0geyp9IG9iaiBwb3NzaWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuQnVmZmVyJDEuaXNCdWZmZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlciQxIHx8IG9ialtpc0J1ZmZlcl0gPT09IHRydWUpO1xufTtcblxubGV0IElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7IC8vIE92ZXJyaWRlIGhvdyBidWZmZXJzIGFyZSBwcmVzZW50ZWQgYnkgdXRpbC5pbnNwZWN0KCkuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IGZ1bmN0aW9uIChyZWN1cnNlVGltZXMsIGN0eCkge1xuICBjb25zdCBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgY29uc3QgYWN0dWFsTWF4ID0gTWF0aC5taW4obWF4LCB0aGlzLmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gbWF4O1xuICBsZXQgc3RyID0gdGhpcy5zbGljZSgwLCBhY3R1YWxNYXgpLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIHN0ciArPSBgIC4uLiAke3JlbWFpbmluZ30gbW9yZSBieXRlJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfSAvLyBJbnNwZWN0IHNwZWNpYWwgcHJvcGVydGllcyBhcyB3ZWxsLCBpZiBwb3NzaWJsZS5cblxuXG4gIGlmIChjdHgpIHtcbiAgICBsZXQgZXh0cmFzID0gZmFsc2U7XG4gICAgY29uc3QgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyQxIDogT05MWV9FTlVNRVJBQkxFJDE7XG4gICAgY29uc3Qgb2JqID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHRoaXMsIGZpbHRlcikucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgZXh0cmFzID0gdHJ1ZTtcbiAgICAgIG9ialtrZXldID0gdGhpc1trZXldO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH0gLy8gJ1tPYmplY3Q6IG51bGwgcHJvdG90eXBlXSB7Jy5sZW5ndGggPT09IDI2XG4gICAgICAvLyBUaGlzIGlzIGd1YXJkZWQgd2l0aCBhIHRlc3QuXG5cblxuICAgICAgc3RyICs9IGluc3BlY3Qob2JqLCB7IC4uLmN0eCxcbiAgICAgICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICBjb21wYWN0OiB0cnVlXG4gICAgICB9KS5zbGljZSgyNywgLTIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgPCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke3N0cn0+YDtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5pbnNwZWN0ID0gQnVmZmVyJDEucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdOyAvLyBIQUNLOiBBcnJheUJ1ZmZlci5pc1ZpZXcgcmV0dXJucyB0cnVlIGZvciBOb2RlIEJ1ZmZlciwgYnV0IGZhbHNlIGZvciB1cy4gVW50aWwgd2UgY2FuIGV4dGVuZCBVaW50OEFycmF5LCB3ZSBuZWVkIHRvIGhhY2sgdGhpcyBzbmlmZmluZyBtZXRob2RcblxuY29uc3QgQXJyYXlCdWZmZXJJc1ZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5cbkFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uICh0aGluZykge1xuICByZXR1cm4gQXJyYXlCdWZmZXJJc1ZpZXcodGhpbmcpIHx8IHRoaW5nIGluc3RhbmNlb2YgQnVmZmVyJDE7XG59O1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU2xvd0J1ZmZlci5wcm90b3R5cGUsIEJ1ZmZlciQxLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU2xvd0J1ZmZlciwgQnVmZmVyJDEpO1xudmFyIEJ1ZmZlck1vZHVsZSA9IHtcbiAgQnVmZmVyOiBCdWZmZXIkMSxcbiAgLy8gVE9ETzogSW1wbGVtZW50IHRyYW5zY29kZSgpIVxuICB0cmFuc2NvZGU6IChfc291cmNlLCBfZnJvbUVuY29kaW5nLCBfdG9FbmNvZGluZykgPT4ge30sXG4gIElOU1BFQ1RfTUFYX0JZVEVTOiA1MCxcbiAga01heExlbmd0aDogMjE0NzQ4MzY0NyxcbiAga1N0cmluZ01heExlbmd0aDogMTA3Mzc0MTc5OSxcbiAgY29uc3RhbnRzOiB7XG4gICAgTUFYX0xFTkdUSDogMjE0NzQ4MzY0NyxcbiAgICBNQVhfU1RSSU5HX0xFTkdUSDogMTA3Mzc0MTc5OVxuICB9XG59O1xuLyoqXG4gKiBTZWFyY2hlcyBhIEJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGEgc2luZ2xlIGJ5dGUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byBzZWFyY2hcbiAqIEBwYXJhbSB7aW50ZWdlcn0gc2luZ2xlQnl0ZSBieXRlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2Ugc2VhcmNoIGF0XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mKGJ1ZmZlciwgc2luZ2xlQnl0ZSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KGkpID09PSBzaW5nbGVCeXRlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSBhdm9pZHMgYml0d2lzZSBvcGVyYXRpb25zIGJlY2F1c2UgSlMgYXNzdW1lcyAzMi1iaXQgc2VxdWVuY2VzIGZvciB0aG9zZS5cbiAqIEl0J3MgcG9zc2libGUgd2UgbWF5IGJlIGFibGUgdG8gdXNlIHRoZW0gd2hlbiBieXRlTGVuZ3RoIDwgNCBpZiB0aGF0J3MgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdW5zaWduZWRWYWx1ZSB2YWx1ZSBiZWZvcmUgY29udmVydGluZyBiYWNrIHRvIHNpZ25lZFxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybnMge2ludGVnZXJ9IHRoZSBzaWduZWQgdmFsdWUgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgdW5zaWduZWQgdmFsdWUncyBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IGJpdExlbmd0aCA9IGJ5dGVMZW5ndGggKiA4O1xuICBjb25zdCBtYXhQb3NpdGl2ZVZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XG5cbiAgaWYgKHVuc2lnbmVkVmFsdWUgPCBtYXhQb3NpdGl2ZVZhbHVlKSB7XG4gICAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG4gIH1cblxuICBjb25zdCBtYXhVbnNpZ25lZFZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcbiAgdW5zaWduZWRWYWx1ZSAtPSBtYXhVbnNpZ25lZFZhbHVlO1xuICByZXR1cm4gdW5zaWduZWRWYWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB1dGYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuZnVuY3Rpb24gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gIC8vIEp1c3QgY29udmVydCB0byBhIFRpLkJ1ZmZlciBhbmQgbGV0IGl0IHRlbGwgdXMgdGhlIGxlbmd0aFxuICBjb25zdCBidWYgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgdHlwZTogVGkuQ29kZWMuQ0hBUlNFVF9VVEY4XG4gIH0pO1xuICBjb25zdCBsZW5ndGggPSBidWYubGVuZ3RoO1xuICBidWYucmVsZWFzZSgpOyAvLyByZWxlYXNlIHRoZSBidWZmZXIgc2luY2Ugd2UganVzdCBuZWVkZWQgdGhlIGxlbmd0aFxuXG4gIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgb2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyIHdlJ3JlIG9wZXJhdGluZyBvblxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdXNlciBzdXBwbGllZCBvZmZzZXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIGluIHJhbmdlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tPZmZzZXQoYnVmZmVyLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIGJ5dGVMZW5ndGg7XG5cbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gZW5kT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSB2YWx1ZSBvZiBcIm9mZnNldFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSA+PSAwIGFuZCA8PSAke2VuZE9mZnNldH0uIFJlY2VpdmVkICR7b2Zmc2V0fWApO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgdXNlci1zdXBwbGllZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtaW4gbWluaW11bSB2YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtYXggbWF4aW11bSB2YWxpZCB2YWx1ZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgdmFsdWUgb2YgXCJ2YWx1ZVwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSA+PSAke21pbn0gYW5kIDw9ICR7bWF4fS4gUmVjZWl2ZWQgJHt2YWx1ZX1gKTtcbiAgfVxufVxuXG5sZXQgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gZmFsc2U7XG5sZXQgbm9kZU1vZHVsZXNDaGVja0NvdW50ZXIgPSAwO1xuY29uc3QgYnVmZmVyV2FybmluZyA9ICdCdWZmZXIoKSBpcyBkZXByZWNhdGVkIGR1ZSB0byBzZWN1cml0eSBhbmQgdXNhYmlsaXR5ICcgKyAnaXNzdWVzLiBQbGVhc2UgdXNlIHRoZSBCdWZmZXIuYWxsb2MoKSwgJyArICdCdWZmZXIuYWxsb2NVbnNhZmUoKSwgb3IgQnVmZmVyLmZyb20oKSBtZXRob2RzIGluc3RlYWQuJztcblxuZnVuY3Rpb24gc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpIHtcbiAgaWYgKGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCB8fCArK25vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID4gMTAwMDAgfHwgaXNJbnNpZGVOb2RlTW9kdWxlcygpKSB7XG4gICAgLy8gV2UgZG9uJ3QgZW1pdCBhIHdhcm5pbmcsIGJlY2F1c2Ugd2UgZWl0aGVyOlxuICAgIC8vIC0gQWxyZWFkeSBkaWQgc28sIG9yXG4gICAgLy8gLSBBbHJlYWR5IGNoZWNrZWQgdG9vIG1hbnkgdGltZXMgd2hldGhlciBhIGNhbGwgaXMgY29taW5nXG4gICAgLy8gICBmcm9tIG5vZGVfbW9kdWxlcyBhbmQgd2FudCB0byBzdG9wIHNsb3dpbmcgZG93biB0aGluZ3MsIG9yXG4gICAgLy8gLSBUaGUgY29kZSBpcyBpbnNpZGUgYG5vZGVfbW9kdWxlc2AuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhidWZmZXJXYXJuaW5nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwMDUnKTtcbiAgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbn1cblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3Qge1xuICBBTExfUFJPUEVSVElFUyxcbiAgT05MWV9FTlVNRVJBQkxFXG59ID0gcHJvcGVydHlGaWx0ZXI7XG5jb25zdCBCb29sZWFuUHJvdG90eXBlID0gQm9vbGVhbi5wcm90b3R5cGU7XG5jb25zdCBEYXRlUHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG5jb25zdCBFcnJvclByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmNvbnN0IE51bWJlclByb3RvdHlwZSA9IE51bWJlci5wcm90b3R5cGU7XG5jb25zdCBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuY29uc3QgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbmNvbnN0IFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG5jb25zdCBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuY29uc3QgU3ltYm9sUHJvdG90eXBlID0gU3ltYm9sLnByb3RvdHlwZTtcbmNvbnN0IGlzSW9zID0gWydpcGFkJywgJ2lwaG9uZSddLmluY2x1ZGVzKFwiYW5kcm9pZFwiKTtcbmNvbnN0IHtcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEVcbn0gPSBjb2RlcztcbmNvbnN0IGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5jb25zdCBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xubGV0IGhleFNsaWNlID0gdW5jdXJyeVRoaXMoQnVmZmVyTW9kdWxlLkJ1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UpO1xuY29uc3QgYnVpbHRJbk9iamVjdHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGdsb2JhbCkuZmlsdGVyKGUgPT4gL14oW0EtWl1bYS16XSspKyQvLnRlc3QoZSkpKTtcbmNvbnN0IGluc3BlY3REZWZhdWx0T3B0aW9ucyA9IE9iamVjdC5zZWFsKHtcbiAgc2hvd0hpZGRlbjogZmFsc2UsXG4gIGRlcHRoOiAyLFxuICBjb2xvcnM6IGZhbHNlLFxuICBjdXN0b21JbnNwZWN0OiB0cnVlLFxuICBzaG93UHJveHk6IGZhbHNlLFxuICBtYXhBcnJheUxlbmd0aDogMTAwLFxuICBicmVha0xlbmd0aDogODAsXG4gIGNvbXBhY3Q6IDMsXG4gIHNvcnRlZDogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlXG59KTtcbmNvbnN0IGtPYmplY3RUeXBlID0gMDtcbmNvbnN0IGtBcnJheVR5cGUgPSAxO1xuY29uc3Qga0FycmF5RXh0cmFzVHlwZSA9IDI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyN1xceDVjXS87XG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciA9IC9bXFx4MDAtXFx4MWZcXHgyN1xceDVjXS9nO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlID0gL1tcXHgwMC1cXHgxZlxceDVjXS87XG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZSA9IC9bXFx4MDAtXFx4MWZcXHg1Y10vZztcbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5jb25zdCBrZXlTdHJSZWdFeHAgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLztcbmNvbnN0IG51bWJlclJlZ0V4cCA9IC9eKDB8WzEtOV1bMC05XSopJC87XG5jb25zdCBub2RlTW9kdWxlc1JlZ0V4cCA9IC9bL1xcXFxdbm9kZV9tb2R1bGVzWy9cXFxcXSguKz8pKD89Wy9cXFxcXSkvZztcbmNvbnN0IGtNaW5MaW5lTGVuZ3RoID0gMTY7IC8vIENvbnN0YW50cyB0byBtYXAgdGhlIGl0ZXJhdG9yIHN0YXRlLlxuXG5jb25zdCBrV2VhayA9IDA7XG5jb25zdCBrSXRlcmF0b3IgPSAxO1xuY29uc3Qga01hcEVudHJpZXMgPSAyOyAvLyBFc2NhcGVkIHNwZWNpYWwgY2hhcmFjdGVycy4gVXNlIGVtcHR5IHN0cmluZ3MgdG8gZmlsbCB1cCB1bnVzZWQgZW50cmllcy5cblxuLyogZXNsaW50LWRpc2FibGUgcXVvdGVzICovXG5cbmNvbnN0IG1ldGEgPSBbJ1xcXFx1MDAwMCcsICdcXFxcdTAwMDEnLCAnXFxcXHUwMDAyJywgJ1xcXFx1MDAwMycsICdcXFxcdTAwMDQnLCAnXFxcXHUwMDA1JywgJ1xcXFx1MDAwNicsICdcXFxcdTAwMDcnLCAnXFxcXGInLCAnXFxcXHQnLCAnXFxcXG4nLCAnXFxcXHUwMDBiJywgJ1xcXFxmJywgJ1xcXFxyJywgJ1xcXFx1MDAwZScsICdcXFxcdTAwMGYnLCAnXFxcXHUwMDEwJywgJ1xcXFx1MDAxMScsICdcXFxcdTAwMTInLCAnXFxcXHUwMDEzJywgJ1xcXFx1MDAxNCcsICdcXFxcdTAwMTUnLCAnXFxcXHUwMDE2JywgJ1xcXFx1MDAxNycsICdcXFxcdTAwMTgnLCAnXFxcXHUwMDE5JywgJ1xcXFx1MDAxYScsICdcXFxcdTAwMWInLCAnXFxcXHUwMDFjJywgJ1xcXFx1MDAxZCcsICdcXFxcdTAwMWUnLCAnXFxcXHUwMDFmJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsIFwiXFxcXCdcIiwgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdcXFxcXFxcXCddO1xuLyogZXNsaW50LWVuYWJsZSBxdW90ZXMgKi9cblxuZnVuY3Rpb24gZ2V0VXNlck9wdGlvbnMoY3R4KSB7XG4gIGNvbnN0IG9iaiA9IHtcbiAgICBzdHlsaXplOiBjdHguc3R5bGl6ZVxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluc3BlY3REZWZhdWx0T3B0aW9ucykpIHtcbiAgICBvYmpba2V5XSA9IGN0eFtrZXldO1xuICB9XG5cbiAgaWYgKGN0eC51c2VyT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiB7IC4uLm9iaixcbiAgICAuLi5jdHgudXNlck9wdGlvbnNcbiAgfTtcbn1cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGFueSBpbnB1dC4gVHJpZXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGB2YWx1ZWBcbiAqL1xuXG5cbmZ1bmN0aW9uIGluc3BlY3QodmFsdWUsIG9wdHMpIHtcbiAgLy8gRGVmYXVsdCBvcHRpb25zXG4gIGNvbnN0IGN0eCA9IHtcbiAgICBidWRnZXQ6IHt9LFxuICAgIGluZGVudGF0aW9uTHZsOiAwLFxuICAgIHNlZW46IFtdLFxuICAgIGN1cnJlbnREZXB0aDogMCxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvcixcbiAgICBzaG93SGlkZGVuOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd0hpZGRlbixcbiAgICBkZXB0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmRlcHRoLFxuICAgIGNvbG9yczogaW5zcGVjdERlZmF1bHRPcHRpb25zLmNvbG9ycyxcbiAgICBjdXN0b21JbnNwZWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY3VzdG9tSW5zcGVjdCxcbiAgICBzaG93UHJveHk6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zaG93UHJveHksXG4gICAgbWF4QXJyYXlMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBicmVha0xlbmd0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmJyZWFrTGVuZ3RoLFxuICAgIGNvbXBhY3Q6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb21wYWN0LFxuICAgIHNvcnRlZDogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNvcnRlZCxcbiAgICBnZXR0ZXJzOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuZ2V0dGVyc1xuICB9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIC8vIExlZ2FjeS4uLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gICAgICB9XG4gICAgfSAvLyBTZXQgdXNlci1zcGVjaWZpZWQgb3B0aW9uc1xuXG5cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdib29sZWFuJykge1xuICAgICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICAgIH0gZWxzZSBpZiAob3B0cykge1xuICAgICAgY29uc3Qgb3B0S2V5cyA9IE9iamVjdC5rZXlzKG9wdHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRLZXlzKSB7XG4gICAgICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBGaW5kIGEgc29sdXRpb24gd2hhdCB0byBkbyBhYm91dCBzdHlsaXplLiBFaXRoZXIgbWFrZVxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHB1YmxpYyBvciBhZGQgYSBuZXcgQVBJIHdpdGggYSBzaW1pbGFyIG9yIGJldHRlclxuICAgICAgICAvLyBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoaW5zcGVjdERlZmF1bHRPcHRpb25zLCBrZXkpIHx8IGtleSA9PT0gJ3N0eWxpemUnKSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4LnVzZXJPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIHBhc3MgdGhyb3VnaCB0aGUgYWN0dWFsIHVzZXIgaW5wdXQuXG4gICAgICAgICAgY3R4LnVzZXJPcHRpb25zID0gb3B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdHguY29sb3JzKSB7XG4gICAgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICB9XG5cbiAgaWYgKGN0eC5tYXhBcnJheUxlbmd0aCA9PT0gbnVsbCkge1xuICAgIGN0eC5tYXhBcnJheUxlbmd0aCA9IEluZmluaXR5O1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIDApO1xufVxuaW5zcGVjdC5jdXN0b20gPSBjdXN0b21JbnNwZWN0U3ltYm9sO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3BlY3QsICdkZWZhdWx0T3B0aW9ucycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBpbnNwZWN0RGVmYXVsdE9wdGlvbnM7XG4gIH0sXG5cbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGluc3BlY3REZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxufSk7IC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuXG5pbnNwZWN0LmNvbG9ycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBib2xkOiBbMSwgMjJdLFxuICBpdGFsaWM6IFszLCAyM10sXG4gIHVuZGVybGluZTogWzQsIDI0XSxcbiAgaW52ZXJzZTogWzcsIDI3XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmV5OiBbOTAsIDM5XSxcbiAgYmxhY2s6IFszMCwgMzldLFxuICBibHVlOiBbMzQsIDM5XSxcbiAgY3lhbjogWzM2LCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgbWFnZW50YTogWzM1LCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIHllbGxvdzogWzMzLCAzOV1cbn0pOyAvLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcblxuaW5zcGVjdC5zdHlsZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgc3BlY2lhbDogJ2N5YW4nLFxuICBudW1iZXI6ICd5ZWxsb3cnLFxuICBiaWdpbnQ6ICd5ZWxsb3cnLFxuICBib29sZWFuOiAneWVsbG93JyxcbiAgdW5kZWZpbmVkOiAnZ3JleScsXG4gIG51bGw6ICdib2xkJyxcbiAgc3RyaW5nOiAnZ3JlZW4nLFxuICBzeW1ib2w6ICdncmVlbicsXG4gIGRhdGU6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgcmVnZXhwOiAncmVkJyxcbiAgbW9kdWxlOiAndW5kZXJsaW5lJ1xufSk7XG5cbmZ1bmN0aW9uIGFkZFF1b3RlcyhzdHIsIHF1b3Rlcykge1xuICBpZiAocXVvdGVzID09PSAtMSkge1xuICAgIHJldHVybiBgXCIke3N0cn1cImA7XG4gIH1cblxuICBpZiAocXVvdGVzID09PSAtMikge1xuICAgIHJldHVybiBgXFxgJHtzdHJ9XFxgYDtcbiAgfVxuXG4gIHJldHVybiBgJyR7c3RyfSdgO1xufVxuXG5jb25zdCBlc2NhcGVGbiA9IHN0ciA9PiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTsgLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycywgc2luZ2xlIHF1b3RlcyBhbmQgdGhlIGJhY2tzbGFzaC5cbi8vIFRoaXMgaXMgc2ltaWxhciB0byBKU09OIHN0cmluZ2lmeSBlc2NhcGluZy5cblxuXG5mdW5jdGlvbiBzdHJFc2NhcGUoc3RyKSB7XG4gIGxldCBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwO1xuICBsZXQgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyO1xuICBsZXQgc2luZ2xlUXVvdGUgPSAzOTsgLy8gQ2hlY2sgZm9yIGRvdWJsZSBxdW90ZXMuIElmIG5vdCBwcmVzZW50LCBkbyBub3QgZXNjYXBlIHNpbmdsZSBxdW90ZXMgYW5kXG4gIC8vIGluc3RlYWQgd3JhcCB0aGUgdGV4dCBpbiBkb3VibGUgcXVvdGVzLiBJZiBkb3VibGUgcXVvdGVzIGV4aXN0LCBjaGVjayBmb3JcbiAgLy8gYmFja3RpY2tzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgdXNlIHRob3NlIGFzIGZhbGxiYWNrIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRvdWJsZSBxdW90ZXMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBxdW90ZXNcblxuICBpZiAoc3RyLmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgIC8vIFRoaXMgaW52YWxpZGF0ZXMgdGhlIGNoYXJDb2RlIGFuZCB0aGVyZWZvcmUgY2FuIG5vdCBiZSBtYXRjaGVkIGZvclxuICAgIC8vIGFueW1vcmUuXG4gICAgaWYgKCFzdHIuaW5jbHVkZXMoJ1wiJykpIHtcbiAgICAgIHNpbmdsZVF1b3RlID0gLTE7XG4gICAgfSBlbHNlIGlmICghc3RyLmluY2x1ZGVzKCdgJykgJiYgIXN0ci5pbmNsdWRlcygnJHsnKSkge1xuICAgICAgc2luZ2xlUXVvdGUgPSAtMjtcbiAgICB9XG5cbiAgICBpZiAoc2luZ2xlUXVvdGUgIT09IDM5KSB7XG4gICAgICBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlO1xuICAgICAgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlO1xuICAgIH1cbiAgfSAvLyBTb21lIG1hZ2ljIG51bWJlcnMgdGhhdCB3b3JrZWQgb3V0IGZpbmUgd2hpbGUgYmVuY2htYXJraW5nIHdpdGggdjggNi4wXG5cblxuICBpZiAoc3RyLmxlbmd0aCA8IDUwMDAgJiYgIWVzY2FwZVRlc3QudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGFkZFF1b3RlcyhzdHIsIHNpbmdsZVF1b3RlKTtcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZXNjYXBlRm4pO1xuICAgIHJldHVybiBhZGRRdW90ZXMoc3RyLCBzaW5nbGVRdW90ZSk7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGxldCBsYXN0ID0gMDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChwb2ludCA9PT0gc2luZ2xlUXVvdGUgfHwgcG9pbnQgPT09IDkyIHx8IHBvaW50IDwgMzIpIHtcbiAgICAgIGlmIChsYXN0ID09PSBpKSB7XG4gICAgICAgIHJlc3VsdCArPSBtZXRhW3BvaW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBgJHtzdHIuc2xpY2UobGFzdCwgaSl9JHttZXRhW3BvaW50XX1gO1xuICAgICAgfVxuXG4gICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3QgIT09IGxhc3RJbmRleCkge1xuICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdCk7XG4gIH1cblxuICByZXR1cm4gYWRkUXVvdGVzKHJlc3VsdCwgc2luZ2xlUXVvdGUpO1xufVxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIGNvbnN0IHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbG9yID0gaW5zcGVjdC5jb2xvcnNbc3R5bGVdO1xuICAgIHJldHVybiBgXFx1MDAxYlske2NvbG9yWzBdfW0ke3N0cn1cXHUwMDFiWyR7Y29sb3JbMV19bWA7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIpIHtcbiAgcmV0dXJuIHN0cjtcbn0gLy8gUmV0dXJuIGEgbmV3IGVtcHR5IGFycmF5IHRvIHB1c2ggaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGRlZmF1bHQgZm9ybWF0dGVyLlxuXG5cbmZ1bmN0aW9uIGdldEVtcHR5Rm9ybWF0QXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKG9iaiwgX2N0eCkge1xuICBsZXQgZmlyc3RQcm90bzsgLy8gY29uc3QgdG1wID0gb2JqO1xuXG4gIHdoaWxlIChvYmopIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosICdjb25zdHJ1Y3RvcicpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZXNjcmlwdG9yLnZhbHVlLm5hbWUgIT09ICcnKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZS5uYW1lO1xuICAgIH1cblxuICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuXG4gICAgaWYgKGZpcnN0UHJvdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlyc3RQcm90byA9IG9iajtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlyc3RQcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qXG4gICBAdG9kbyB0aGlzIGNhbGxzIGludG8gbmF0aXZlLCBjYW4gd2UgcmVwbGFjZSB0aGlzIHNvbWVob3c/XG4gIHJldHVybiBgJHtpbnRlcm5hbEdldENvbnN0cnVjdG9yTmFtZSh0bXApfSA8JHtpbnNwZWN0KGZpcnN0UHJvdG8sIHtcbiAgXHQuLi5jdHgsXG4gIFx0Y3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgfSl9PmA7XG4gICovXG5cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKSB7XG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGlmICh0YWcgIT09ICcnKSB7XG4gICAgICByZXR1cm4gYFske2ZhbGxiYWNrfTogbnVsbCBwcm90b3R5cGVdIFske3RhZ31dIGA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHtmYWxsYmFja306IG51bGwgcHJvdG90eXBlXSBgO1xuICB9XG5cbiAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuICAgIHJldHVybiBgJHtjb25zdHJ1Y3Rvcn0gWyR7dGFnfV0gYDtcbiAgfVxuXG4gIHJldHVybiBgJHtjb25zdHJ1Y3Rvcn0gYDtcbn0gLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuXG5cbmZ1bmN0aW9uIGdldEtleXModmFsdWUsIHNob3dIaWRkZW4pIHtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKTtcblxuICBpZiAoc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG5cbiAgICBpZiAoc3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIGtleXMucHVzaCguLi5zeW1ib2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBpZiBgdmFsdWVgIGlzIGEgTW9kdWxlIE5hbWVzcGFjZSBPYmplY3QgZnJvbSBhblxuICAgIC8vIHVuZXZhbHVhdGVkIG1vZHVsZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHR5cGVcbiAgICAvLyBjaGVjayBiZWNhdXNlIGl0J3MgZXhwZW5zaXZlLlxuICAgIC8vIFRPRE8oZGV2c25layk6IHRyYWNrIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWEyNjIvaXNzdWVzLzEyMDlcbiAgICAvLyBhbmQgbW9kaWZ5IHRoaXMgbG9naWMgYXMgbmVlZGVkLlxuICAgIHRyeSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gQGZpeG1lIGhvdyB0byBkdSBpc01vZHVsZU5hbWVzcGFjZU9iamVjdD9cblxuICAgICAgLypcbiAgICAgIGFzc2VydChpc05hdGl2ZUVycm9yKGVycikgJiYgZXJyLm5hbWUgPT09ICdSZWZlcmVuY2VFcnJvcicgJiZcbiAgICAgIFx0XHRcdCBpc01vZHVsZU5hbWVzcGFjZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgKi9cbiAgICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bWJvbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBrZXlzLnB1c2goLi4uc3ltYm9scy5maWx0ZXIoa2V5ID0+IHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbHVlLCBrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGdldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKSB7XG4gIGxldCBmYWxsYmFjayA9ICcnO1xuXG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGZhbGxiYWNrID0gJ09iamVjdCc7XG4gIH1cblxuICByZXR1cm4gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZFR5cGVkQ29uc3RydWN0b3IodmFsdWUpIHtcbiAgZm9yIChjb25zdCBbY2hlY2ssIGNsYXp6XSBvZiBbW2lzVWludDhBcnJheSwgVWludDhBcnJheV0sIFtpc1VpbnQ4Q2xhbXBlZEFycmF5LCBVaW50OENsYW1wZWRBcnJheV0sIFtpc1VpbnQxNkFycmF5LCBVaW50MTZBcnJheV0sIFtpc1VpbnQzMkFycmF5LCBVaW50MzJBcnJheV0sIFtpc0ludDhBcnJheSwgSW50OEFycmF5XSwgW2lzSW50MTZBcnJheSwgSW50MTZBcnJheV0sIFtpc0ludDMyQXJyYXksIEludDMyQXJyYXldLCBbaXNGbG9hdDMyQXJyYXksIEZsb2F0MzJBcnJheV0sIFtpc0Zsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5XV0pIHtcbiAgICBpZiAoY2hlY2sodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xheno7XG4gICAgfVxuICB9XG59XG5cbmxldCBsYXp5TnVsbFByb3RvdHlwZUNhY2hlOyAvLyBDcmVhdGVzIGEgc3ViY2xhc3MgYW5kIG5hbWVcbi8vIHRoZSBjb25zdHJ1Y3RvciBhcyBgJHtjbGF6en0gOiBudWxsIHByb3RvdHlwZWBcblxuZnVuY3Rpb24gY2xhenpXaXRoTnVsbFByb3RvdHlwZShjbGF6eiwgbmFtZSkge1xuICBpZiAobGF6eU51bGxQcm90b3R5cGVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGF6eU51bGxQcm90b3R5cGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYWNoZWRDbGFzcyA9IGxhenlOdWxsUHJvdG90eXBlQ2FjaGUuZ2V0KGNsYXp6KTtcblxuICAgIGlmIChjYWNoZWRDbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ2xhc3M7XG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTnVsbFByb3RvdHlwZSBleHRlbmRzIGNsYXp6IHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnVsbFByb3RvdHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IsICduYW1lJywge1xuICAgIHZhbHVlOiBgWyR7bmFtZX06IG51bGwgcHJvdG90eXBlXWBcbiAgfSk7XG4gIGxhenlOdWxsUHJvdG90eXBlQ2FjaGUuc2V0KGNsYXp6LCBOdWxsUHJvdG90eXBlKTtcbiAgcmV0dXJuIE51bGxQcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIG5vUHJvdG90eXBlSXRlcmF0b3IoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGxldCBuZXdWYWw7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGNvbnN0IGNsYXp6ID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShTZXQsICdTZXQnKTtcbiAgICBuZXdWYWwgPSBuZXcgY2xhenooU2V0UHJvdG90eXBlLnZhbHVlcyh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIGNvbnN0IGNsYXp6ID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShNYXAsICdNYXAnKTtcbiAgICBuZXdWYWwgPSBuZXcgY2xhenooTWFwUHJvdG90eXBlLmVudHJpZXModmFsdWUpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGNsYXp6ID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShBcnJheSwgJ0FycmF5Jyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KHZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZmluZFR5cGVkQ29uc3RydWN0b3IodmFsdWUpO1xuICAgIGNvbnN0IGNsYXp6ID0gY2xhenpXaXRoTnVsbFByb3RvdHlwZShjb25zdHJ1Y3RvciwgY29uc3RydWN0b3IubmFtZSk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KHZhbHVlKTtcbiAgfVxuXG4gIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5ld1ZhbCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpKTtcbiAgICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgbmV3VmFsLCByZWN1cnNlVGltZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSkge1xuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdFByaW1pdGl2ZShjdHguc3R5bGl6ZSwgdmFsdWUsIGN0eCk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9IC8vIE1lbW9yaXplIHRoZSBjb250ZXh0IGZvciBjdXN0b20gaW5zcGVjdGlvbiBvbiBwcm94aWVzLlxuXG5cbiAgY29uc3QgY29udGV4dCA9IHZhbHVlO1xuICAvKlxuICBAZml4bWUgY2hlY2sgZm9yIHByb3hpZXNcbiAgLy8gQWx3YXlzIGNoZWNrIGZvciBwcm94aWVzIHRvIHByZXZlbnQgc2lkZSBlZmZlY3RzIGFuZCB0byBwcmV2ZW50IHRyaWdnZXJpbmdcbiAgLy8gYW55IHByb3h5IGhhbmRsZXJzLlxuICBjb25zdCBwcm94eSA9IGdldFByb3h5RGV0YWlscyh2YWx1ZSk7XG4gIGlmIChwcm94eSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0aWYgKGN0eC5zaG93UHJveHkpIHtcbiAgXHRcdHJldHVybiBmb3JtYXRQcm94eShjdHgsIHByb3h5LCByZWN1cnNlVGltZXMpO1xuICBcdH1cbiAgXHR2YWx1ZSA9IHByb3h5WzBdO1xuICB9XG4gICovXG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0LlxuXG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCkge1xuICAgIGNvbnN0IG1heWJlQ3VzdG9tID0gdmFsdWVbY3VzdG9tSW5zcGVjdFN5bWJvbF07XG5cbiAgICBpZiAodHlwZW9mIG1heWJlQ3VzdG9tID09PSAnZnVuY3Rpb24nIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdHMgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsLlxuICAgICYmIG1heWJlQ3VzdG9tICE9PSBpbnNwZWN0IC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICYmICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgcmVjdXJzZVRpbWVzIGFyZSByZXBvcnRlZCBhcyBiZWZvcmUgd2hpbGUgdXNpbmdcbiAgICAgIC8vIGEgY291bnRlciBpbnRlcm5hbGx5LlxuICAgICAgY29uc3QgZGVwdGggPSBjdHguZGVwdGggPT09IG51bGwgPyBudWxsIDogY3R4LmRlcHRoIC0gcmVjdXJzZVRpbWVzO1xuICAgICAgY29uc3QgcmV0ID0gbWF5YmVDdXN0b20uY2FsbChjb250ZXh0LCBkZXB0aCwgZ2V0VXNlck9wdGlvbnMoY3R4KSk7IC8vIElmIHRoZSBjdXN0b20gaW5zcGVjdGlvbiBtZXRob2QgcmV0dXJuZWQgYHRoaXNgLCBkb24ndCBnbyBpbnRvXG4gICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24uXG5cbiAgICAgIGlmIChyZXQgIT09IGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKC9cXG4vZywgYFxcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBVc2luZyBhbiBhcnJheSBoZXJlIGlzIGFjdHVhbGx5IGJldHRlciBmb3IgdGhlIGF2ZXJhZ2UgY2FzZSB0aGFuIHVzaW5nXG4gIC8vIGEgU2V0LiBgc2VlbmAgd2lsbCBvbmx5IGNoZWNrIGZvciB0aGUgZGVwdGggYW5kIHdpbGwgbmV2ZXIgZ3JvdyB0b28gbGFyZ2UuXG5cblxuICBpZiAoY3R4LnNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgbGV0IGluZGV4ID0gMTtcblxuICAgIGlmIChjdHguY2lyY3VsYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmNpcmN1bGFyID0gbmV3IE1hcChbW3ZhbHVlLCBpbmRleF1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcblxuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuc2l6ZSArIDE7XG4gICAgICAgIGN0eC5jaXJjdWxhci5zZXQodmFsdWUsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3R4LnN0eWxpemUoYFtDaXJjdWxhciAqJHtpbmRleH1dYCwgJ3NwZWNpYWwnKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRSYXcoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB0eXBlZEFycmF5KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmF3KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSkge1xuICBsZXQga2V5cztcbiAgY29uc3QgY29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvck5hbWUodmFsdWUpO1xuICBsZXQgdGFnID0gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXTsgLy8gT25seSBsaXN0IHRoZSB0YWcgaW4gY2FzZSBpdCdzIG5vbi1lbnVtZXJhYmxlIC8gbm90IGFuIG93biBwcm9wZXJ0eS5cbiAgLy8gT3RoZXJ3aXNlIHdlJ2QgcHJpbnQgdGhpcyB0d2ljZS5cblxuICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycgfHwgdGFnICE9PSAnJyAmJiAoY3R4LnNob3dIaWRkZW4gPyBoYXNPd25Qcm9wZXJ0eSA6IHByb3BlcnR5SXNFbnVtZXJhYmxlKSh2YWx1ZSwgU3ltYm9sLnRvU3RyaW5nVGFnKSkge1xuICAgIHRhZyA9ICcnO1xuICB9XG5cbiAgbGV0IGJhc2UgPSAnJztcbiAgbGV0IGZvcm1hdHRlciA9IGdldEVtcHR5Rm9ybWF0QXJyYXk7XG4gIGxldCBicmFjZXM7XG4gIGxldCBub0l0ZXJhdG9yID0gdHJ1ZTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBmaWx0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IEFMTF9QUk9QRVJUSUVTIDogT05MWV9FTlVNRVJBQkxFO1xuICBsZXQgZXh0cmFzVHlwZSA9IGtPYmplY3RUeXBlOyAvLyBJdGVyYXRvcnMgYW5kIHRoZSByZXN0IGFyZSBzcGxpdCB0byByZWR1Y2UgY2hlY2tzLlxuXG4gIGlmICh2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgbm9JdGVyYXRvciA9IGZhbHNlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlLCBmaWx0ZXIpOyAvLyBPbmx5IHNldCB0aGUgY29uc3RydWN0b3IgZm9yIG5vbiBvcmRpbmFyeSAoXCJBcnJheSBbLi4uXVwiKSBhcnJheXMuXG5cbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnQXJyYXknKTtcbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXggPT09ICdBcnJheSAnID8gJycgOiBwcmVmaXh9W2AsICddJ107XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke2JyYWNlc1swXX1dYDtcbiAgICAgIH1cblxuICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRBcnJheTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnU2V0Jyk7XG5cbiAgICAgIGlmICh2YWx1ZS5zaXplID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9e31gO1xuICAgICAgfVxuXG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4fXtgLCAnfSddO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0U2V0O1xuICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdNYXAnKTtcblxuICAgICAgaWYgKHZhbHVlLnNpemUgPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH17fWA7XG4gICAgICB9XG5cbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9e2AsICd9J107XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRNYXA7XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlLCBmaWx0ZXIpO1xuICAgICAgY29uc3QgcHJlZml4ID0gY29uc3RydWN0b3IgIT09IG51bGwgPyBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZykgOiBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmluZFR5cGVkQ29uc3RydWN0b3IodmFsdWUpLm5hbWUpO1xuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH1bYCwgJ10nXTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCAmJiAhY3R4LnNob3dIaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIGAke2JyYWNlc1swXX1dYDtcbiAgICAgIH1cblxuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0VHlwZWRBcnJheTtcbiAgICAgIGV4dHJhc1R5cGUgPSBrQXJyYXlFeHRyYXNUeXBlO1xuICAgIH0gZWxzZSBpZiAoaXNNYXBJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnTWFwJywgdGFnKTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnU2V0JywgdGFnKTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBub0l0ZXJhdG9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9JdGVyYXRvcikge1xuICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gJ09iamVjdCcpIHtcbiAgICAgIGlmIChpc0FyZ3VtZW50c09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgYnJhY2VzWzBdID0gJ1tBcmd1bWVudHNdIHsnO1xuICAgICAgfSBlbHNlIGlmICh0YWcgIT09ICcnKSB7XG4gICAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnT2JqZWN0Jyl9e2A7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiYXNlID0gZ2V0RnVuY3Rpb25CYXNlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZWdleHBcbiAgICAgIGNvbnN0IHJlZ0V4cCA9IGNvbnN0cnVjdG9yICE9PSBudWxsID8gdmFsdWUgOiBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgIGJhc2UgPSBSZWdFeHBQcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWdFeHApO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdSZWdFeHAnKTtcblxuICAgICAgaWYgKHByZWZpeCAhPT0gJ1JlZ0V4cCAnKSB7XG4gICAgICAgIGJhc2UgPSBgJHtwcmVmaXh9JHtiYXNlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCByZWN1cnNlVGltZXMgPiBjdHguZGVwdGggJiYgY3R4LmRlcHRoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAncmVnZXhwJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICAgIGJhc2UgPSBOdW1iZXIuaXNOYU4oRGF0ZVByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsdWUpKSA/IERhdGVQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiBEYXRlUHJvdG90eXBlLnRvSVNPU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdEYXRlJyk7XG5cbiAgICAgIGlmIChwcmVmaXggIT09ICdEYXRlICcpIHtcbiAgICAgICAgYmFzZSA9IGAke3ByZWZpeH0ke2Jhc2V9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAnZGF0ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSBmb3JtYXRFcnJvcih2YWx1ZSwgY29uc3RydWN0b3IsIHRhZywgY3R4KTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfSBlbHNlIGlmIChpc0lvcykge1xuICAgICAgICBjb25zdCBuYXRpdmVFcnJvclByb3BzID0gWydsaW5lJywgJ2NvbHVtbicsICdzb3VyY2VVUkwnXTtcblxuICAgICAgICBpZiAoa2V5cy5ldmVyeShrZXkgPT4gbmF0aXZlRXJyb3JQcm9wcy5pbmNsdWRlcyhrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBBcnJheUJ1ZmZlciBhbmQgU2hhcmVkQXJyYXlCdWZmZXIuXG4gICAgICAvLyBDYW4ndCBkbyB0aGUgc2FtZSBmb3IgRGF0YVZpZXcgYmVjYXVzZSBpdCBoYXMgYSBub24tcHJpbWl0aXZlXG4gICAgICAvLyAuYnVmZmVyIHByb3BlcnR5IHRoYXQgd2UgbmVlZCB0byByZWN1cnNlIGZvci5cbiAgICAgIGNvbnN0IGFycmF5VHlwZSA9IGlzQXJyYXlCdWZmZXIodmFsdWUpID8gJ0FycmF5QnVmZmVyJyA6ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgYXJyYXlUeXBlKTtcblxuICAgICAgaWYgKHR5cGVkQXJyYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRBcnJheUJ1ZmZlcjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH17IGJ5dGVMZW5ndGg6ICR7Zm9ybWF0TnVtYmVyKGN0eC5zdHlsaXplLCB2YWx1ZS5ieXRlTGVuZ3RoKX0gfWA7XG4gICAgICB9XG5cbiAgICAgIGJyYWNlc1swXSA9IGAke3ByZWZpeH17YDtcbiAgICAgIGtleXMudW5zaGlmdCgnYnl0ZUxlbmd0aCcpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRhVmlldyh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnRGF0YVZpZXcnKX17YDsgLy8gLmJ1ZmZlciBnb2VzIGxhc3QsIGl0J3Mgbm90IGEgcHJpbWl0aXZlIGxpa2UgdGhlIG90aGVycy5cblxuICAgICAga2V5cy51bnNoaWZ0KCdieXRlTGVuZ3RoJywgJ2J5dGVPZmZzZXQnLCAnYnVmZmVyJyk7XG4gICAgfSBlbHNlIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1Byb21pc2UnKX17YDtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdFByb21pc2U7XG4gICAgfSBlbHNlIGlmIChpc1dlYWtTZXQodmFsdWUpKSB7XG4gICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1dlYWtTZXQnKX17YDtcbiAgICAgIGZvcm1hdHRlciA9IGN0eC5zaG93SGlkZGVuID8gZm9ybWF0V2Vha1NldCA6IGZvcm1hdFdlYWtDb2xsZWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNXZWFrTWFwKHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdXZWFrTWFwJyl9e2A7XG4gICAgICBmb3JtYXR0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IGZvcm1hdFdlYWtNYXAgOiBmb3JtYXRXZWFrQ29sbGVjdGlvbjtcbiAgICAgIC8qXG4gICAgICAgKiBAZml4bWUgaG93IHRvIGRvIGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0P1xuICAgICAgfSBlbHNlIGlmIChpc01vZHVsZU5hbWVzcGFjZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIFx0YnJhY2VzWzBdID0gYFske3RhZ31dIHtgO1xuICAgICAgXHRmb3JtYXR0ZXIgPSBmb3JtYXROYW1lc3BhY2VPYmplY3Q7XG4gICAgICAqL1xuICAgIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSBnZXRCb3hlZEJhc2UodmFsdWUsIGN0eCwga2V5cywgY29uc3RydWN0b3IsIHRhZyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGlucHV0IHByb3RvdHlwZSBnb3QgbWFuaXB1bGF0ZWQuIFNwZWNpYWwgaGFuZGxlIHRoZXNlLiBXZSBoYXZlIHRvXG4gICAgICAvLyByZWJ1aWxkIHRoZSBpbmZvcm1hdGlvbiBzbyB3ZSBhcmUgYWJsZSB0byBkaXNwbGF5IGV2ZXJ5dGhpbmcuXG4gICAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lhbEl0ZXJhdG9yID0gbm9Qcm90b3R5cGVJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpO1xuXG4gICAgICAgIGlmIChzcGVjaWFsSXRlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc3BlY2lhbEl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnTWFwJywgdGFnKTtcbiAgICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdTZXQnLCB0YWcpO1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjsgLy8gSGFuZGxlIG90aGVyIHJlZ3VsYXIgb2JqZWN0cyBhZ2Fpbi5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBgJHtnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyl9e31gO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpfXtgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPiBjdHguZGVwdGggJiYgY3R4LmRlcHRoICE9PSBudWxsKSB7XG4gICAgbGV0IGNvbnN0cnVjdG9yTmFtZSA9IGdldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKS5zbGljZSgwLCAtMSk7XG5cbiAgICBpZiAoY29uc3RydWN0b3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0cnVjdG9yTmFtZSA9IGBbJHtjb25zdHJ1Y3Rvck5hbWV9XWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGNvbnN0cnVjdG9yTmFtZSwgJ3NwZWNpYWwnKTtcbiAgfVxuXG4gIHJlY3Vyc2VUaW1lcyArPSAxO1xuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcbiAgY3R4LmN1cnJlbnREZXB0aCA9IHJlY3Vyc2VUaW1lcztcbiAgbGV0IG91dHB1dDtcbiAgY29uc3QgaW5kZW50YXRpb25MdmwgPSBjdHguaW5kZW50YXRpb25Mdmw7XG5cbiAgdHJ5IHtcbiAgICBvdXRwdXQgPSBmb3JtYXR0ZXIoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXlzLCBicmFjZXMpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5c1tpXSwgZXh0cmFzVHlwZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpLnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCk7XG4gIH1cblxuICBpZiAoY3R4LmNpcmN1bGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBpbmRleCA9IGN0eC5jaXJjdWxhci5nZXQodmFsdWUpO1xuXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IGN0eC5zdHlsaXplKGA8cmVmICoke2luZGV4fT5gLCAnc3BlY2lhbCcpOyAvLyBBZGQgcmVmZXJlbmNlIGFsd2F5cyB0byB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIG91dHB1dC5cblxuICAgICAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlKSB7XG4gICAgICAgIGJhc2UgPSBiYXNlID09PSAnJyA/IHJlZmVyZW5jZSA6IGAke3JlZmVyZW5jZX0gJHtiYXNlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFjZXNbMF0gPSBgJHtyZWZlcmVuY2V9ICR7YnJhY2VzWzBdfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgaWYgKGN0eC5zb3J0ZWQpIHtcbiAgICBjb25zdCBjb21wYXJhdG9yID0gY3R4LnNvcnRlZCA9PT0gdHJ1ZSA/IHVuZGVmaW5lZCA6IGN0eC5zb3J0ZWQ7XG5cbiAgICBpZiAoZXh0cmFzVHlwZSA9PT0ga09iamVjdFR5cGUpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBvdXRwdXQuc2xpY2Uob3V0cHV0Lmxlbmd0aCAtIGtleXMubGVuZ3RoKS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgb3V0cHV0LnNwbGljZShvdXRwdXQubGVuZ3RoIC0ga2V5cy5sZW5ndGgsIGtleXMubGVuZ3RoLCAuLi5zb3J0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlcyA9IHJlZHVjZVRvU2luZ2xlU3RyaW5nKGN0eCwgb3V0cHV0LCBiYXNlLCBicmFjZXMsIGV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcywgdmFsdWUpO1xuICBjb25zdCBidWRnZXQgPSBjdHguYnVkZ2V0W2N0eC5pbmRlbnRhdGlvbkx2bF0gfHwgMDtcbiAgY29uc3QgbmV3TGVuZ3RoID0gYnVkZ2V0ICsgcmVzLmxlbmd0aDtcbiAgY3R4LmJ1ZGdldFtjdHguaW5kZW50YXRpb25MdmxdID0gbmV3TGVuZ3RoOyAvLyBJZiBhbnkgaW5kZW50YXRpb25MdmwgZXhjZWVkcyB0aGlzIGxpbWl0LCBsaW1pdCBmdXJ0aGVyIGluc3BlY3RpbmcgdG8gdGhlXG4gIC8vIG1pbmltdW0uIE90aGVyd2lzZSB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobSBtaWdodCBjb250aW51ZSBpbnNwZWN0aW5nIHRoZVxuICAvLyBvYmplY3QgZXZlbiB0aG91Z2ggdGhlIG1heGltdW0gc3RyaW5nIHNpemUgKH4yICoqIDI4IG9uIDMyIGJpdCBzeXN0ZW1zIGFuZFxuICAvLyB+MiAqKiAzMCBvbiA2NCBiaXQgc3lzdGVtcykgZXhjZWVkZWQuIFRoZSBhY3R1YWwgb3V0cHV0IGlzIG5vdCBsaW1pdGVkIGF0XG4gIC8vIGV4YWN0bHkgMiAqKiAyNyBidXQgYSBiaXQgaGlnaGVyLiBUaGlzIGRlcGVuZHMgb24gdGhlIG9iamVjdCBzaGFwZS5cbiAgLy8gVGhpcyBsaW1pdCBhbHNvIG1ha2VzIHN1cmUgdGhhdCBodWdlIG9iamVjdHMgZG9uJ3QgYmxvY2sgdGhlIGV2ZW50IGxvb3BcbiAgLy8gc2lnbmlmaWNhbnRseS5cblxuICBpZiAobmV3TGVuZ3RoID4gMiAqKiAyNykge1xuICAgIGN0eC5kZXB0aCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JCcmFjZXModHlwZSwgdGFnKSB7XG4gIGlmICh0YWcgIT09IGAke3R5cGV9IEl0ZXJhdG9yYCkge1xuICAgIGlmICh0YWcgIT09ICcnKSB7XG4gICAgICB0YWcgKz0gJ10gWyc7XG4gICAgfVxuXG4gICAgdGFnICs9IGAke3R5cGV9IEl0ZXJhdG9yYDtcbiAgfVxuXG4gIHJldHVybiBbYFske3RhZ31dIHtgLCAnfSddO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hlZEJhc2UodmFsdWUsIGN0eCwga2V5cywgY29uc3RydWN0b3IsIHRhZykge1xuICBsZXQgZm47XG4gIGxldCB0eXBlO1xuXG4gIGlmIChpc051bWJlck9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IE51bWJlclByb3RvdHlwZTtcbiAgICB0eXBlID0gJ051bWJlcic7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdPYmplY3QodmFsdWUpKSB7XG4gICAgZm4gPSBTdHJpbmdQcm90b3R5cGU7XG4gICAgdHlwZSA9ICdTdHJpbmcnOyAvLyBGb3IgYm94ZWQgU3RyaW5ncywgd2UgaGF2ZSB0byByZW1vdmUgdGhlIDAtbiBpbmRleGVkIGVudHJpZXMsXG4gICAgLy8gc2luY2UgdGhleSBqdXN0IG5vaXN5IHVwIHRoZSBvdXRwdXQgYW5kIGFyZSByZWR1bmRhbnRcbiAgICAvLyBNYWtlIGJveGVkIHByaW1pdGl2ZSBTdHJpbmdzIGxvb2sgbGlrZSBzdWNoXG5cbiAgICBrZXlzLnNwbGljZSgwLCB2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IEJvb2xlYW5Qcm90b3R5cGU7XG4gICAgdHlwZSA9ICdCb29sZWFuJztcbiAgfSBlbHNlIHtcbiAgICBmbiA9IFN5bWJvbFByb3RvdHlwZTtcbiAgICB0eXBlID0gJ1N5bWJvbCc7XG4gIH1cblxuICBsZXQgYmFzZSA9IGBbJHt0eXBlfWA7XG5cbiAgaWYgKHR5cGUgIT09IGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICBiYXNlICs9ICcgKG51bGwgcHJvdG90eXBlKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgKz0gYCAoJHtjb25zdHJ1Y3Rvcn0pYDtcbiAgICB9XG4gIH1cblxuICBiYXNlICs9IGA6ICR7Zm9ybWF0UHJpbWl0aXZlKHN0eWxpemVOb0NvbG9yLCBmbi52YWx1ZU9mKHZhbHVlKSwgY3R4KX1dYDtcblxuICBpZiAodGFnICE9PSAnJyAmJiB0YWcgIT09IGNvbnN0cnVjdG9yKSB7XG4gICAgYmFzZSArPSBgIFske3RhZ31dYDtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCAhPT0gMCB8fCBjdHguc3R5bGl6ZSA9PT0gc3R5bGl6ZU5vQ29sb3IpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCB0eXBlLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcbiAgbGV0IHR5cGUgPSAnRnVuY3Rpb24nO1xuXG4gIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHR5cGUgPSBgR2VuZXJhdG9yJHt0eXBlfWA7XG4gIH1cblxuICBpZiAoaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHR5cGUgPSBgQXN5bmMke3R5cGV9YDtcbiAgfVxuXG4gIGxldCBiYXNlID0gYFske3R5cGV9YDtcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBiYXNlICs9ICcgKG51bGwgcHJvdG90eXBlKSc7XG4gIH1cblxuICBpZiAodmFsdWUubmFtZSA9PT0gJycpIHtcbiAgICBiYXNlICs9ICcgKGFub255bW91cyknO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgKz0gYDogJHt2YWx1ZS5uYW1lfWA7XG4gIH1cblxuICBiYXNlICs9ICddJztcblxuICBpZiAoY29uc3RydWN0b3IgIT09IHR5cGUgJiYgY29uc3RydWN0b3IgIT09IG51bGwpIHtcbiAgICBiYXNlICs9IGAgJHtjb25zdHJ1Y3Rvcn1gO1xuICB9XG5cbiAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuICAgIGJhc2UgKz0gYCBbJHt0YWd9XWA7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyLCBjb25zdHJ1Y3RvciwgdGFnLCBjdHgpIHtcbiAgbGV0IHN0YWNrID0gZXJyLnN0YWNrIHx8IEVycm9yUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKTsgLy8gdHJ5IHRvIG5vcm1hbGl6ZSBKYXZhU2NyaXB0Q29yZSBzdGFjayB0byBtYXRjaCB2OFxuXG4gIGlmIChpc0lvcykge1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIHN0YWNrID0gYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWA7XG5cbiAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2sgKz0gbGluZXMubWFwKHN0YWNrTGluZSA9PiB7XG4gICAgICAgIGNvbnN0IGF0U3ltYm9sSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignQCcpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzdGFja0xpbmUuc2xpY2UoYXRTeW1ib2xJbmRleCArIDEpO1xuICAgICAgICBjb25zdCBzb3VyY2VQYXR0ZXJuID0gLyguKik6KFxcZCspOihcXGQrKS87XG4gICAgICAgIGxldCBzeW1ib2xOYW1lID0gJ3Vua25vd24nO1xuXG4gICAgICAgIGlmIChhdFN5bWJvbEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN5bWJvbE5hbWUgPSBzdGFja0xpbmUuc2xpY2UoMCwgYXRTeW1ib2xJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3VyY2VNYXRjaCA9IHNvdXJjZS5tYXRjaChzb3VyY2VQYXR0ZXJuKTtcblxuICAgICAgICBpZiAoc291cmNlTWF0Y2gpIHtcbiAgICAgICAgICBsZXQgZmlsZVBhdGggPSBzb3VyY2VNYXRjaFsxXTtcbiAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gc291cmNlTWF0Y2hbMl07XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gc291cmNlTWF0Y2hbM107XG5cbiAgICAgICAgICBpZiAoZmlsZVBhdGguc3RhcnRzV2l0aCgnZmlsZTonKSkge1xuICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5yZXBsYWNlKGBmaWxlOi8vJHtUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeX1gLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGBcXG4gICAgYXQgJHtzeW1ib2xOYW1lfSAoJHtmaWxlUGF0aH06JHtsaW5lTnVtYmVyfToke2NvbHVtbn0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYFxcbiAgICBhdCAke3N5bWJvbE5hbWV9ICgke3NvdXJjZX0pYDtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9IC8vIEEgc3RhY2sgdHJhY2UgbWF5IGNvbnRhaW4gYXJiaXRyYXJ5IGRhdGEuIE9ubHkgbWFuaXB1bGF0ZSB0aGUgb3V0cHV0XG4gIC8vIGZvciBcInJlZ3VsYXIgZXJyb3JzXCIgKGVycm9ycyB0aGF0IFwibG9vayBub3JtYWxcIikgZm9yIG5vdy5cblxuXG4gIGNvbnN0IG5hbWUgPSBlcnIubmFtZSB8fCAnRXJyb3InO1xuICBsZXQgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsIHx8IG5hbWUuZW5kc1dpdGgoJ0Vycm9yJykgJiYgc3RhY2suc3RhcnRzV2l0aChuYW1lKSAmJiAoc3RhY2subGVuZ3RoID09PSBsZW4gfHwgc3RhY2tbbGVuXSA9PT0gJzonIHx8IHN0YWNrW2xlbl0gPT09ICdcXG4nKSkge1xuICAgIGxldCBmYWxsYmFjayA9ICdFcnJvcic7XG5cbiAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhY2subWF0Y2goL14oW0EtWl1bYS16XyBBLVowLTlbXFxdKCktXSspKD86OnxcXG4gezR9YXQpLykgfHwgc3RhY2subWF0Y2goL14oW2Etel9BLVowLTktXSpFcnJvcikkLyk7XG4gICAgICBmYWxsYmFjayA9IHN0YXJ0ICYmIHN0YXJ0WzFdIHx8ICcnO1xuICAgICAgbGVuID0gZmFsbGJhY2subGVuZ3RoO1xuICAgICAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCAnRXJyb3InO1xuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjaykuc2xpY2UoMCwgLTEpO1xuXG4gICAgaWYgKG5hbWUgIT09IHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeC5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgc3RhY2sgPSBgJHtwcmVmaXh9OiAke3N0YWNrfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sgPSBgJHtwcmVmaXh9JHtzdGFjay5zbGljZShsZW4pfWA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrID0gYCR7cHJlZml4fSBbJHtuYW1lfV0ke3N0YWNrLnNsaWNlKGxlbil9YDtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSWdub3JlIHRoZSBlcnJvciBtZXNzYWdlIGlmIGl0J3MgY29udGFpbmVkIGluIHRoZSBzdGFjay5cblxuXG4gIGxldCBwb3MgPSBlcnIubWVzc2FnZSAmJiBzdGFjay5pbmRleE9mKGVyci5tZXNzYWdlKSB8fCAtMTtcblxuICBpZiAocG9zICE9PSAtMSkge1xuICAgIHBvcyArPSBlcnIubWVzc2FnZS5sZW5ndGg7XG4gIH0gLy8gV3JhcCB0aGUgZXJyb3IgaW4gYnJhY2tldHMgaW4gY2FzZSBpdCBoYXMgbm8gc3RhY2sgdHJhY2UuXG5cblxuICBsZXQgc3RhY2tTdGFydCA9IHN0YWNrLmluZGV4T2YoJ1xcbiAgICBhdCcsIHBvcyk7XG5cbiAgaWYgKHN0YWNrU3RhcnQgPT09IC0xKSB7XG4gICAgc3RhY2sgPSBgWyR7c3RhY2t9XWA7XG4gIH0gZWxzZSBpZiAoY3R4LmNvbG9ycykge1xuICAgIC8vIEhpZ2hsaWdodCB1c2VybGFuZCBjb2RlIGFuZCBub2RlIG1vZHVsZXMuXG4gICAgbGV0IG5ld1N0YWNrID0gc3RhY2suc2xpY2UoMCwgc3RhY2tTdGFydCk7XG4gICAgY29uc3QgbGluZXMgPSBzdGFjay5zbGljZShzdGFja1N0YXJ0ICsgMSkuc3BsaXQoJ1xcbicpO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAvLyBUaGlzIGFkZHMgdW5kZXJzY29yZXMgdG8gYWxsIG5vZGVfbW9kdWxlcyB0byBxdWlja2x5IGlkZW50aWZ5IHRoZW0uXG4gICAgICBsZXQgbm9kZU1vZHVsZTtcbiAgICAgIG5ld1N0YWNrICs9ICdcXG4nO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIHdoaWxlIChub2RlTW9kdWxlID0gbm9kZU1vZHVsZXNSZWdFeHAuZXhlYyhsaW5lKSkge1xuICAgICAgICAvLyAnL25vZGVfbW9kdWxlcy8nLmxlbmd0aCA9PT0gMTRcbiAgICAgICAgbmV3U3RhY2sgKz0gbGluZS5zbGljZShwb3MsIG5vZGVNb2R1bGUuaW5kZXggKyAxNCk7XG4gICAgICAgIG5ld1N0YWNrICs9IGN0eC5zdHlsaXplKG5vZGVNb2R1bGVbMV0sICdtb2R1bGUnKTtcbiAgICAgICAgcG9zID0gbm9kZU1vZHVsZS5pbmRleCArIG5vZGVNb2R1bGVbMF0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGFjayArPSBwb3MgPT09IDAgPyBsaW5lIDogbGluZS5zbGljZShwb3MpO1xuICAgIH1cblxuICAgIHN0YWNrID0gbmV3U3RhY2s7XG4gIH0gLy8gVGhlIG1lc3NhZ2UgYW5kIHRoZSBzdGFjayBoYXZlIHRvIGJlIGluZGVudGVkIGFzIHdlbGwhXG5cblxuICBpZiAoY3R4LmluZGVudGF0aW9uTHZsICE9PSAwKSB7XG4gICAgY29uc3QgaW5kZW50YXRpb24gPSAnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCk7XG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9cXG4vZywgYFxcbiR7aW5kZW50YXRpb259YCk7XG4gIH1cblxuICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByb21pc2UoY3R4LCBfdmFsdWUsIF9yZWN1cnNlVGltZXMpIHtcbiAgLy8gTm9kZSBjYWxscyBpbnRvIG5hdGl2ZSB0byBnZXQgcHJvbWlzZSBkZXRhaWxzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBbY3R4LnN0eWxpemUoJzx1bmtub3duPicsICdzcGVjaWFsJyldO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwgdHlwZSkge1xuICBsZXQgbmFtZSwgc3RyO1xuICBsZXQgZXh0cmEgPSAnICc7XG4gIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHtcbiAgICB2YWx1ZTogdmFsdWVba2V5XSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG5cbiAgaWYgKGRlc2MudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRpZmYgPSB0eXBlICE9PSBrT2JqZWN0VHlwZSB8fCBjdHguY29tcGFjdCAhPT0gdHJ1ZSA/IDIgOiAzO1xuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSBkaWZmO1xuICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzKTtcblxuICAgIGlmIChkaWZmID09PSAzKSB7XG4gICAgICBjb25zdCBsZW4gPSBjdHguY29sb3JzID8gcmVtb3ZlQ29sb3JzKHN0cikubGVuZ3RoIDogc3RyLmxlbmd0aDtcblxuICAgICAgaWYgKGN0eC5icmVha0xlbmd0aCA8IGxlbikge1xuICAgICAgICBleHRyYSA9IGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSBkaWZmO1xuICB9IGVsc2UgaWYgKGRlc2MuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsYWJlbCA9IGRlc2Muc2V0ICE9PSB1bmRlZmluZWQgPyAnR2V0dGVyL1NldHRlcicgOiAnR2V0dGVyJztcbiAgICBjb25zdCBzID0gY3R4LnN0eWxpemU7XG4gICAgY29uc3Qgc3AgPSAnc3BlY2lhbCc7XG5cbiAgICBpZiAoY3R4LmdldHRlcnMgJiYgKGN0eC5nZXR0ZXJzID09PSB0cnVlIHx8IGN0eC5nZXR0ZXJzID09PSAnZ2V0JyAmJiBkZXNjLnNldCA9PT0gdW5kZWZpbmVkIHx8IGN0eC5nZXR0ZXJzID09PSAnc2V0JyAmJiBkZXNjLnNldCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG1wID0gdmFsdWVba2V5XTtcbiAgICAgICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgICAgICAgaWYgKHRtcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7cygnbnVsbCcsICdudWxsJyl9JHtzKCddJywgc3ApfWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRtcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH1dYCwgc3ApfSAke2Zvcm1hdFZhbHVlKGN0eCwgdG1wLCByZWN1cnNlVGltZXMpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKHMsIHRtcCwgY3R4KTtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke3ByaW1pdGl2ZX0ke3MoJ10nLCBzcCl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPEluc3BlY3Rpb24gdGhyZXcgKCR7ZXJyLm1lc3NhZ2V9KT5gO1xuICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke21lc3NhZ2V9JHtzKCddJywgc3ApfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKGBbJHtsYWJlbH1dYCwgc3ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZXNjLnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IGtBcnJheVR5cGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgY29uc3QgdG1wID0ga2V5LnRvU3RyaW5nKCkucmVwbGFjZShzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciwgZXNjYXBlRm4pO1xuICAgIG5hbWUgPSBgWyR7Y3R4LnN0eWxpemUodG1wLCAnc3ltYm9sJyl9XWA7XG4gIH0gZWxzZSBpZiAoZGVzYy5lbnVtZXJhYmxlID09PSBmYWxzZSkge1xuICAgIG5hbWUgPSBgWyR7a2V5LnJlcGxhY2Uoc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIsIGVzY2FwZUZuKX1dYDtcbiAgfSBlbHNlIGlmIChrZXlTdHJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgbmFtZSA9IGN0eC5zdHlsaXplKGtleSwgJ25hbWUnKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gY3R4LnN0eWxpemUoc3RyRXNjYXBlKGtleSksICdzdHJpbmcnKTtcbiAgfVxuXG4gIHJldHVybiBgJHtuYW1lfToke2V4dHJhfSR7c3RyfWA7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXJyYXlFbGVtZW50cyhjdHgsIG91dHB1dCwgdmFsdWUpIHtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgbGV0IG1heExlbmd0aCA9IDA7XG4gIGxldCBpID0gMDtcbiAgbGV0IG91dHB1dExlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cbiAgaWYgKGN0eC5tYXhBcnJheUxlbmd0aCA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIFwiLi4uIG4gbW9yZSBpdGVtc1wiIHBhcnQgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICBvdXRwdXRMZW5ndGgtLTtcbiAgfVxuXG4gIGNvbnN0IHNlcGFyYXRvclNwYWNlID0gMjsgLy8gQWRkIDEgZm9yIHRoZSBzcGFjZSBhbmQgMSBmb3IgdGhlIHNlcGFyYXRvci5cblxuICBjb25zdCBkYXRhTGVuID0gbmV3IEFycmF5KG91dHB1dExlbmd0aCk7IC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBvdXRwdXQgZW50cmllcyBhbmQgdGhlIGluZGl2aWR1YWwgbWF4XG4gIC8vIGVudHJpZXMgbGVuZ3RoIG9mIGFsbCBvdXRwdXQgZW50cmllcy4gV2UgaGF2ZSB0byByZW1vdmUgY29sb3JzIGZpcnN0LFxuICAvLyBvdGhlcndpc2UgdGhlIGxlbmd0aCB3b3VsZCBub3QgYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cblxuICBmb3IgKDsgaSA8IG91dHB1dExlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGVuID0gY3R4LmNvbG9ycyA/IHJlbW92ZUNvbG9ycyhvdXRwdXRbaV0pLmxlbmd0aCA6IG91dHB1dFtpXS5sZW5ndGg7XG4gICAgZGF0YUxlbltpXSA9IGxlbjtcbiAgICB0b3RhbExlbmd0aCArPSBsZW4gKyBzZXBhcmF0b3JTcGFjZTtcblxuICAgIGlmIChtYXhMZW5ndGggPCBsZW4pIHtcbiAgICAgIG1heExlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH0gLy8gQWRkIHR3byB0byBgbWF4TGVuZ3RoYCBhcyB3ZSBhZGQgYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgcGx1cyBhIGNvbW1hXG4gIC8vIGluLWJldHdlZW4gdHdvIGVudHJpZXMuXG5cblxuICBjb25zdCBhY3R1YWxNYXggPSBtYXhMZW5ndGggKyBzZXBhcmF0b3JTcGFjZTsgLy8gQ2hlY2sgaWYgYXQgbGVhc3QgdGhyZWUgZW50cmllcyBmaXQgbmV4dCB0byBlYWNoIG90aGVyIGFuZCBwcmV2ZW50IGdyb3VwaW5nXG4gIC8vIG9mIGFycmF5cyB0aGF0IGNvbnRhaW5zIGVudHJpZXMgb2YgdmVyeSBkaWZmZXJlbnQgbGVuZ3RoIChpLmUuLCBpZiBhIHNpbmdsZVxuICAvLyBlbnRyeSBpcyBsb25nZXIgdGhhbiAxLzUgb2YgYWxsIG90aGVyIGVudHJpZXMgY29tYmluZWQpLiBPdGhlcndpc2UgdGhlXG4gIC8vIHNwYWNlIGluLWJldHdlZW4gc21hbGwgZW50cmllcyB3b3VsZCBiZSBlbm9ybW91cy5cblxuICBpZiAoYWN0dWFsTWF4ICogMyArIGN0eC5pbmRlbnRhdGlvbkx2bCA8IGN0eC5icmVha0xlbmd0aCAmJiAodG90YWxMZW5ndGggLyBhY3R1YWxNYXggPiA1IHx8IG1heExlbmd0aCA8PSA2KSkge1xuICAgIGNvbnN0IGFwcHJveENoYXJIZWlnaHRzID0gMi41O1xuICAgIGNvbnN0IGF2ZXJhZ2VCaWFzID0gTWF0aC5zcXJ0KGFjdHVhbE1heCAtIHRvdGFsTGVuZ3RoIC8gb3V0cHV0Lmxlbmd0aCk7XG4gICAgY29uc3QgYmlhc2VkTWF4ID0gTWF0aC5tYXgoYWN0dWFsTWF4IC0gMyAtIGF2ZXJhZ2VCaWFzLCAxKTsgLy8gRHluYW1pY2FsbHkgY2hlY2sgaG93IG1hbnkgY29sdW1ucyBzZWVtIHBvc3NpYmxlLlxuXG4gICAgY29uc3QgY29sdW1ucyA9IE1hdGgubWluKCAvLyBJZGVhbGx5IGEgc3F1YXJlIHNob3VsZCBiZSBkcmF3bi4gV2UgZXhwZWN0IGEgY2hhcmFjdGVyIHRvIGJlIGFib3V0IDIuNVxuICAgIC8vIHRpbWVzIGFzIGhpZ2ggYXMgd2lkZS4gVGhpcyBpcyB0aGUgYXJlYSBmb3JtdWxhIHRvIGNhbGN1bGF0ZSBhIHNxdWFyZVxuICAgIC8vIHdoaWNoIGNvbnRhaW5zIG4gcmVjdGFuZ2xlcyBvZiBzaXplIGBhY3R1YWxNYXggKiBhcHByb3hDaGFySGVpZ2h0c2AuXG4gICAgLy8gRGl2aWRlIHRoYXQgYnkgYGFjdHVhbE1heGAgdG8gcmVjZWl2ZSB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAvLyBUaGUgYWRkZWQgYmlhcyBpbmNyZWFzZXMgdGhlIGNvbHVtbnMgZm9yIHNob3J0IGVudHJpZXMuXG4gICAgTWF0aC5yb3VuZChNYXRoLnNxcnQoYXBwcm94Q2hhckhlaWdodHMgKiBiaWFzZWRNYXggKiBvdXRwdXRMZW5ndGgpIC8gYmlhc2VkTWF4KSwgLy8gRG8gbm90IGV4Y2VlZCB0aGUgYnJlYWtMZW5ndGguXG4gICAgTWF0aC5mbG9vcigoY3R4LmJyZWFrTGVuZ3RoIC0gY3R4LmluZGVudGF0aW9uTHZsKSAvIGFjdHVhbE1heCksIC8vIExpbWl0IGFycmF5IGdyb3VwaW5nIGZvciBzbWFsbCBgY29tcGFjdGAgbW9kZXMgYXMgdGhlIHVzZXIgcmVxdWVzdGVkXG4gICAgLy8gbWluaW1hbCBncm91cGluZy5cbiAgICBjdHguY29tcGFjdCAqIDQsIC8vIExpbWl0IHRoZSBjb2x1bW5zIHRvIGEgbWF4aW11bSBvZiBmaWZ0ZWVuLlxuICAgIDE1KTsgLy8gUmV0dXJuIHdpdGggdGhlIG9yaWdpbmFsIG91dHB1dCBpZiBubyBncm91cGluZyBzaG91bGQgaGFwcGVuLlxuXG4gICAgaWYgKGNvbHVtbnMgPD0gMSkge1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBjb25zdCB0bXAgPSBbXTtcbiAgICBjb25zdCBtYXhMaW5lTGVuZ3RoID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgbGV0IGxpbmVNYXhMZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IG91dHB1dC5sZW5ndGg7IGogKz0gY29sdW1ucykge1xuICAgICAgICBpZiAoZGF0YUxlbltqXSA+IGxpbmVNYXhMZW5ndGgpIHtcbiAgICAgICAgICBsaW5lTWF4TGVuZ3RoID0gZGF0YUxlbltqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lTWF4TGVuZ3RoICs9IHNlcGFyYXRvclNwYWNlO1xuICAgICAgbWF4TGluZUxlbmd0aFtpXSA9IGxpbmVNYXhMZW5ndGg7XG4gICAgfVxuXG4gICAgbGV0IG9yZGVyID0gJ3BhZFN0YXJ0JztcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yZGVyID0gJ3BhZEVuZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEVhY2ggaXRlcmF0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgbGluZSBvZiBncm91cGVkIGVudHJpZXMuXG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoOyBpICs9IGNvbHVtbnMpIHtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmVzIG1heSBjb250YWluIGxlc3MgZW50cmllcyB0aGFuIGNvbHVtbnMuXG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihpICsgY29sdW1ucywgb3V0cHV0TGVuZ3RoKTtcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGxldCBqID0gaTtcblxuICAgICAgZm9yICg7IGogPCBtYXggLSAxOyBqKyspIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGV4dHJhIGNvbG9yIHBhZGRpbmcgaW4gY2FzZSBpdCdzIGFjdGl2ZS4gVGhpcyBoYXMgdG8gYmVcbiAgICAgICAgLy8gZG9uZSBsaW5lIGJ5IGxpbmUgYXMgc29tZSBsaW5lcyBtaWdodCBjb250YWluIG1vcmUgY29sb3JzIHRoYW5cbiAgICAgICAgLy8gb3RoZXJzLlxuICAgICAgICBjb25zdCBwYWRkaW5nID0gbWF4TGluZUxlbmd0aFtqIC0gaV0gKyBvdXRwdXRbal0ubGVuZ3RoIC0gZGF0YUxlbltqXTtcbiAgICAgICAgc3RyICs9IGAke291dHB1dFtqXX0sIGBbb3JkZXJdKHBhZGRpbmcsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlciA9PT0gJ3BhZFN0YXJ0Jykge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gbWF4TGluZUxlbmd0aFtqIC0gaV0gKyBvdXRwdXRbal0ubGVuZ3RoIC0gZGF0YUxlbltqXSAtIHNlcGFyYXRvclNwYWNlO1xuICAgICAgICBzdHIgKz0gb3V0cHV0W2pdLnBhZFN0YXJ0KHBhZGRpbmcsICcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gb3V0cHV0W2pdO1xuICAgICAgfVxuXG4gICAgICB0bXAucHVzaChzdHIpO1xuICAgIH1cblxuICAgIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICB0bXAucHVzaChvdXRwdXRbb3V0cHV0TGVuZ3RoXSk7XG4gICAgfVxuXG4gICAgb3V0cHV0ID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCkge1xuICBpZiAoaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSkge1xuICAgIGN0eC5zZWVuLnBvcCgpO1xuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCA9IGluZGVudGF0aW9uTHZsO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShgWyR7Y29uc3RydWN0b3JOYW1lfTogSW5zcGVjdGlvbiBpbnRlcnJ1cHRlZCAncHJlbWF0dXJlbHkuIE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkLl1gLCAnc3BlY2lhbCcpO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBmb3JtYXROdW1iZXIoZm4sIHZhbHVlKSB7XG4gIC8vIEZvcm1hdCAtMCBhcyAnLTAnLiBDaGVja2luZyBgdmFsdWUgPT09IC0wYCB3b24ndCBkaXN0aW5ndWlzaCAwIGZyb20gLTAuXG4gIHJldHVybiBmbihPYmplY3QuaXModmFsdWUsIC0wKSA/ICctMCcgOiBgJHt2YWx1ZX1gLCAnbnVtYmVyJyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEJpZ0ludChmbiwgdmFsdWUpIHtcbiAgcmV0dXJuIGZuKGAke3ZhbHVlfW5gLCAnYmlnaW50Jyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShmbiwgdmFsdWUsIGN0eCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSAmJiB2YWx1ZS5sZW5ndGggPiBrTWluTGluZUxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGggLSBjdHguaW5kZW50YXRpb25MdmwgLSA0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3BsaXQoL1xcbi8pLm1hcChsaW5lID0+IGZuKHN0ckVzY2FwZShsaW5lKSwgJ3N0cmluZycpKS5qb2luKGAgK1xcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwgKyAyKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oc3RyRXNjYXBlKHZhbHVlKSwgJ3N0cmluZycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKGZuLCB2YWx1ZSk7XG4gIH1cbiAgLypcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgXHRyZXR1cm4gZm9ybWF0QmlnSW50KGZuLCB2YWx1ZSk7XG4gIH1cbiAgKi9cblxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBmbihgJHt2YWx1ZX1gLCAnYm9vbGVhbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZm4oJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgfSAvLyBlczYgc3ltYm9sIHByaW1pdGl2ZVxuXG5cbiAgcmV0dXJuIGZuKFN5bWJvbFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3N5bWJvbCcpO1xufSAvLyBUaGUgYXJyYXkgaXMgc3BhcnNlIGFuZC9vciBoYXMgZXh0cmEga2V5c1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFNwZWNpYWxBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIG1heExlbmd0aCwgb3V0cHV0LCBpKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIGxldCBpbmRleCA9IGk7XG5cbiAgZm9yICg7IGkgPCBrZXlzLmxlbmd0aCAmJiBvdXRwdXQubGVuZ3RoIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHRtcCA9ICtrZXk7IC8vIEFycmF5cyBjYW4gb25seSBoYXZlIHVwIHRvIDJeMzIgLSAxIGVudHJpZXNcblxuICAgIGlmICh0bXAgPiAyICoqIDMyIC0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGAke2luZGV4fWAgIT09IGtleSkge1xuICAgICAgaWYgKCFudW1iZXJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbXB0eUl0ZW1zID0gdG1wIC0gaW5kZXg7XG4gICAgICBjb25zdCBlbmRpbmcgPSBlbXB0eUl0ZW1zID4gMSA/ICdzJyA6ICcnO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGA8JHtlbXB0eUl0ZW1zfSBlbXB0eSBpdGVtJHtlbmRpbmd9PmA7XG4gICAgICBvdXRwdXQucHVzaChjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuICAgICAgaW5kZXggPSB0bXA7XG5cbiAgICAgIGlmIChvdXRwdXQubGVuZ3RoID09PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXksIGtBcnJheVR5cGUpKTtcbiAgICBpbmRleCsrO1xuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gaW5kZXg7XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggIT09IG1heExlbmd0aCkge1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBjb25zdCBlbmRpbmcgPSByZW1haW5pbmcgPiAxID8gJ3MnIDogJyc7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYDwke3JlbWFpbmluZ30gZW1wdHkgaXRlbSR7ZW5kaW5nfT5gO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXlCdWZmZXIoY3R4LCB2YWx1ZSkge1xuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChoZXhTbGljZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0aGV4U2xpY2UgPSB1bmN1cnJ5VGhpcyhyZXF1aXJlKCcuLi8uLi9idWZmZXInKS5kZWZhdWx0LkJ1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UpO1xuICB9XG4gICovXG5cbiAgbGV0IHN0ciA9IGhleFNsaWNlKGJ1ZmZlciwgMCwgTWF0aC5taW4oY3R4Lm1heEFycmF5TGVuZ3RoLCBidWZmZXIubGVuZ3RoKSkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1ZmZlci5sZW5ndGggLSBjdHgubWF4QXJyYXlMZW5ndGg7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBzdHIgKz0gYCAuLi4gJHtyZW1haW5pbmd9IG1vcmUgYnl0ZSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG4gIH1cblxuICByZXR1cm4gW2Ake2N0eC5zdHlsaXplKCdbVWludDhDb250ZW50c10nLCAnc3BlY2lhbCcpfTogPCR7c3RyfT5gXTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGNvbnN0IHZhbExlbiA9IHZhbHVlLmxlbmd0aDtcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgdmFsTGVuKTtcbiAgY29uc3QgcmVtYWluaW5nID0gdmFsTGVuIC0gbGVuO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gU3BlY2lhbCBoYW5kbGUgc3BhcnNlIGFycmF5cy5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbHVlLCBpKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFNwZWNpYWxBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGxlbiwgb3V0cHV0LCBpKTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGksIGtBcnJheVR5cGUpKTtcbiAgfVxuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWx1ZS5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSB2YWx1ZS5sZW5ndGggLSBtYXhMZW5ndGg7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICBjb25zdCBlbGVtZW50Rm9ybWF0dGVyID0gdmFsdWUubGVuZ3RoID4gMCAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInID8gZm9ybWF0TnVtYmVyIDogZm9ybWF0QmlnSW50O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyArK2kpIHtcbiAgICBvdXRwdXRbaV0gPSBlbGVtZW50Rm9ybWF0dGVyKGN0eC5zdHlsaXplLCB2YWx1ZVtpXSk7XG4gIH1cblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dFttYXhMZW5ndGhdID0gYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfVxuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG4gICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ0JZVEVTX1BFUl9FTEVNRU5UJywgJ2xlbmd0aCcsICdieXRlTGVuZ3RoJywgJ2J5dGVPZmZzZXQnLCAnYnVmZmVyJ10pIHtcbiAgICAgIGNvbnN0IHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzLCB0cnVlKTtcbiAgICAgIG91dHB1dC5wdXNoKGBbJHtrZXl9XTogJHtzdHJ9YCk7XG4gICAgfVxuXG4gICAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZXQoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBvdXRwdXQucHVzaChmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcykpO1xuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7IC8vIFdpdGggYHNob3dIaWRkZW5gLCBgbGVuZ3RoYCB3aWxsIGRpc3BsYXkgYXMgYSBoaWRkZW4gcHJvcGVydHkgZm9yXG4gIC8vIGFycmF5cy4gRm9yIGNvbnNpc3RlbmN5J3Mgc2FrZSwgZG8gdGhlIHNhbWUgZm9yIGBzaXplYCwgZXZlbiB0aG91Z2ggdGhpc1xuICAvLyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIG91dHB1dC5wdXNoKGBbc2l6ZV06ICR7Y3R4LnN0eWxpemUoYCR7dmFsdWUuc2l6ZX1gLCAnbnVtYmVyJyl9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNYXAoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgIG91dHB1dC5wdXNoKGAke2Zvcm1hdFZhbHVlKGN0eCwgaywgcmVjdXJzZVRpbWVzKX0gPT4gJHtmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcyl9YCk7XG4gIH1cblxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjsgLy8gU2VlIGNvbW1lbnQgaW4gZm9ybWF0U2V0XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgb3V0cHV0LnB1c2goYFtzaXplXTogJHtjdHguc3R5bGl6ZShgJHt2YWx1ZS5zaXplfWAsICdudW1iZXInKX1gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywgc3RhdGUpIHtcbiAgY29uc3QgbWF4QXJyYXlMZW5ndGggPSBNYXRoLm1heChjdHgubWF4QXJyYXlMZW5ndGgsIDApO1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1pbihtYXhBcnJheUxlbmd0aCwgZW50cmllcy5sZW5ndGgpO1xuICBsZXQgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbaV0gPSBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbaV0sIHJlY3Vyc2VUaW1lcyk7XG4gIH1cblxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcblxuICBpZiAoc3RhdGUgPT09IGtXZWFrICYmICFjdHguc29ydGVkKSB7XG4gICAgLy8gU29ydCBhbGwgZW50cmllcyB0byBoYXZlIGEgaGFsZndheSByZWxpYWJsZSBvdXRwdXQgKGlmIG1vcmUgZW50cmllcyB0aGFuXG4gICAgLy8gcmV0cmlldmVkIG9uZXMgZXhpc3QsIHdlIGNhbiBub3QgcmVsaWFibHkgcmV0dXJuIHRoZSBzYW1lIG91dHB1dCkgaWYgdGhlXG4gICAgLy8gb3V0cHV0IGlzIG5vdCBzb3J0ZWQgYW55d2F5LlxuICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KCk7XG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSBlbnRyaWVzLmxlbmd0aCAtIG1heExlbmd0aDtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWFwSXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBzdGF0ZSkge1xuICBjb25zdCBtYXhBcnJheUxlbmd0aCA9IE1hdGgubWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7IC8vIEVudHJpZXMgZXhpc3QgYXMgW2tleTEsIHZhbDEsIGtleTIsIHZhbDIsIC4uLl1cblxuICBjb25zdCBsZW4gPSBlbnRyaWVzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IHJlbWFpbmluZyA9IGxlbiAtIG1heEFycmF5TGVuZ3RoO1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1pbihtYXhBcnJheUxlbmd0aCwgbGVuKTtcbiAgbGV0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICBsZXQgaSA9IDA7XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGlmIChzdGF0ZSA9PT0ga1dlYWspIHtcbiAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3MgPSBpICogMjtcbiAgICAgIG91dHB1dFtpXSA9IGAke2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3NdLCByZWN1cnNlVGltZXMpfWAgKyBgID0+ICR7Zm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3BvcyArIDFdLCByZWN1cnNlVGltZXMpfWA7XG4gICAgfSAvLyBTb3J0IGFsbCBlbnRyaWVzIHRvIGhhdmUgYSBoYWxmd2F5IHJlbGlhYmxlIG91dHB1dCAoaWYgbW9yZSBlbnRyaWVzIHRoYW5cbiAgICAvLyByZXRyaWV2ZWQgb25lcyBleGlzdCwgd2UgY2FuIG5vdCByZWxpYWJseSByZXR1cm4gdGhlIHNhbWUgb3V0cHV0KSBpZiB0aGVcbiAgICAvLyBvdXRwdXQgaXMgbm90IHNvcnRlZCBhbnl3YXkuXG5cblxuICAgIGlmICghY3R4LnNvcnRlZCkge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9zID0gaSAqIDI7XG4gICAgICBjb25zdCByZXMgPSBbZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3Bvc10sIHJlY3Vyc2VUaW1lcyksIGZvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3MgKyAxXSwgcmVjdXJzZVRpbWVzKV07XG4gICAgICBvdXRwdXRbaV0gPSByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIHJlcywgJycsIFsnWycsICddJ10sIGtBcnJheUV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlYWtDb2xsZWN0aW9uKGN0eCkge1xuICByZXR1cm4gW2N0eC5zdHlsaXplKCc8aXRlbXMgdW5rbm93bj4nLCAnc3BlY2lhbCcpXTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vha1NldChjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBhIHByZXZpZXcgb2YgYWN0dWFsIHZhbHVlcyB3aGljaCB3ZSBjYW4ndCBkb1xuICByZXR1cm4gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vha01hcChjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBhIHByZXZpZXcgb2YgYWN0dWFsIHZhbHVlcyB3aGljaCB3ZSBjYW4ndCBkb1xuICByZXR1cm4gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SXRlcmF0b3IoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBfa2V5cywgYnJhY2VzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgbGV0IGlzS2V5VmFsdWUgPSBmYWxzZTtcbiAgbGV0IHJlc3VsdCA9IHZhbHVlLm5leHQoKTtcblxuICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgY3VycmVudEVudHJ5ID0gcmVzdWx0LnZhbHVlO1xuICAgIGVudHJpZXMucHVzaChjdXJyZW50RW50cnkpO1xuXG4gICAgaWYgKGN1cnJlbnRFbnRyeVswXSAhPT0gY3VycmVudEVudHJ5WzFdKSB7XG4gICAgICBpc0tleVZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSB2YWx1ZS5uZXh0KCk7XG4gIH1cblxuICBpZiAoaXNLZXlWYWx1ZSkge1xuICAgIC8vIE1hcmsgZW50cnkgaXRlcmF0b3JzIGFzIHN1Y2guXG4gICAgYnJhY2VzWzBdID0gYnJhY2VzWzBdLnJlcGxhY2UoLyBJdGVyYXRvcl0geyQvLCAnIEVudHJpZXNdIHsnKTtcbiAgICByZXR1cm4gZm9ybWF0TWFwSXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBrTWFwRW50cmllcyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBrSXRlcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBpc0JlbG93QnJlYWtMZW5ndGgoY3R4LCBvdXRwdXQsIHN0YXJ0LCBiYXNlKSB7XG4gIC8vIEVhY2ggZW50cnkgaXMgc2VwYXJhdGVkIGJ5IGF0IGxlYXN0IGEgY29tbWEuIFRodXMsIHdlIHN0YXJ0IHdpdGggYSB0b3RhbFxuICAvLyBsZW5ndGggb2YgYXQgbGVhc3QgYG91dHB1dC5sZW5ndGhgLiBJbiBhZGRpdGlvbiwgc29tZSBjYXNlcyBoYXZlIGFcbiAgLy8gd2hpdGVzcGFjZSBpbi1iZXR3ZWVuIGVhY2ggb3RoZXIgdGhhdCBpcyBhZGRlZCB0byB0aGUgdG90YWwgYXMgd2VsbC5cbiAgbGV0IHRvdGFsTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aCArIHN0YXJ0O1xuXG4gIGlmICh0b3RhbExlbmd0aCArIG91dHB1dC5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjdHguY29sb3JzKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSByZW1vdmVDb2xvcnMob3V0cHV0W2ldKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IG91dHB1dFtpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRvdGFsTGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIERvIG5vdCBsaW5lIHVwIHByb3BlcnRpZXMgb24gdGhlIHNhbWUgbGluZSBpZiBgYmFzZWAgY29udGFpbnMgbGluZSBicmVha3MuXG5cblxuICByZXR1cm4gYmFzZSA9PT0gJycgfHwgIWJhc2UuaW5jbHVkZXMoJ1xcbicpO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhjdHgsIG91dHB1dCwgYmFzZSwgYnJhY2VzLCBleHRyYXNUeXBlLCByZWN1cnNlVGltZXMsIHZhbHVlKSB7XG4gIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgY3R4LmNvbXBhY3QgPT09ICdudW1iZXInICYmIGN0eC5jb21wYWN0ID49IDEpIHtcbiAgICAgIC8vIE1lbW9yaXplIHRoZSBvcmlnaW5hbCBvdXRwdXQgbGVuZ3RoLiBJbiBjYXNlIHRoZSB0aGUgb3V0cHV0IGlzIGdyb3VwZWQsXG4gICAgICAvLyBwcmV2ZW50IGxpbmluZyB1cCB0aGUgZW50cmllcyBvbiBhIHNpbmdsZSBsaW5lLlxuICAgICAgY29uc3QgZW50cmllcyA9IG91dHB1dC5sZW5ndGg7IC8vIEdyb3VwIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyIGlmIHRoZSBhcnJheSBjb250YWlucyBhdCBsZWFzdCBzaXhcbiAgICAgIC8vIHNlcGFyYXRlIGVudHJpZXMuXG5cbiAgICAgIGlmIChleHRyYXNUeXBlID09PSBrQXJyYXlFeHRyYXNUeXBlICYmIGVudHJpZXMgPiA2KSB7XG4gICAgICAgIG91dHB1dCA9IGdyb3VwQXJyYXlFbGVtZW50cyhjdHgsIG91dHB1dCwgdmFsdWUpO1xuICAgICAgfSAvLyBgY3R4LmN1cnJlbnREZXB0aGAgaXMgc2V0IHRvIHRoZSBtb3N0IGlubmVyIGRlcHRoIG9mIHRoZSBjdXJyZW50bHlcbiAgICAgIC8vIGluc3BlY3RlZCBvYmplY3QgcGFydCB3aGlsZSBgcmVjdXJzZVRpbWVzYCBpcyB0aGUgYWN0dWFsIGN1cnJlbnQgZGVwdGhcbiAgICAgIC8vIHRoYXQgaXMgaW5zcGVjdGVkLlxuICAgICAgLy9cbiAgICAgIC8vIEV4YW1wbGU6XG4gICAgICAvL1xuICAgICAgLy8gY29uc3QgYSA9IHsgZmlyc3Q6IFsgMSwgMiwgMyBdLCBzZWNvbmQ6IHsgaW5uZXI6IFsgMSwgMiwgMyBdIH0gfVxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBkZWVwZXN0IGRlcHRoIG9mIGBhYCBpcyAyIChhLnNlY29uZC5pbm5lcikgYW5kIGBhLmZpcnN0YCBoYXMgYSBtYXhcbiAgICAgIC8vIGRlcHRoIG9mIDEuXG4gICAgICAvL1xuICAgICAgLy8gQ29uc29saWRhdGUgYWxsIGVudHJpZXMgb2YgdGhlIGxvY2FsIG1vc3QgaW5uZXIgZGVwdGggdXAgdG9cbiAgICAgIC8vIGBjdHguY29tcGFjdGAsIGFzIGxvbmcgYXMgdGhlIHByb3BlcnRpZXMgYXJlIHNtYWxsZXIgdGhhblxuICAgICAgLy8gYGN0eC5icmVha0xlbmd0aGAuXG5cblxuICAgICAgaWYgKGN0eC5jdXJyZW50RGVwdGggLSByZWN1cnNlVGltZXMgPCBjdHguY29tcGFjdCAmJiBlbnRyaWVzID09PSBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIC8vIExpbmUgdXAgYWxsIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZSBpbiBjYXNlIHRoZSBlbnRyaWVzIGRvIG5vdFxuICAgICAgICAvLyBleGNlZWQgYGJyZWFrTGVuZ3RoYC4gQWRkIDEwIGFzIGNvbnN0YW50IHRvIHN0YXJ0IG5leHQgdG8gYWxsIG90aGVyXG4gICAgICAgIC8vIGZhY3RvcnMgdGhhdCBtYXkgcmVkdWNlIGBicmVha0xlbmd0aGAuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gb3V0cHV0Lmxlbmd0aCArIGN0eC5pbmRlbnRhdGlvbkx2bCArIGJyYWNlc1swXS5sZW5ndGggKyBiYXNlLmxlbmd0aCArIDEwO1xuXG4gICAgICAgIGlmIChpc0JlbG93QnJlYWtMZW5ndGgoY3R4LCBvdXRwdXQsIHN0YXJ0LCBiYXNlKSkge1xuICAgICAgICAgIHJldHVybiBgJHtiYXNlID8gYCR7YmFzZX0gYCA6ICcnfSR7YnJhY2VzWzBdfSAke2pvaW4kMShvdXRwdXQsICcsICcpfSAke2JyYWNlc1sxXX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBMaW5lIHVwIGVhY2ggZW50cnkgb24gYW4gaW5kaXZpZHVhbCBsaW5lLlxuXG5cbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gO1xuICAgIHJldHVybiBgJHtiYXNlID8gYCR7YmFzZX0gYCA6ICcnfSR7YnJhY2VzWzBdfSR7aW5kZW50YXRpb259ICBgICsgYCR7am9pbiQxKG91dHB1dCwgYCwke2luZGVudGF0aW9ufSAgYCl9JHtpbmRlbnRhdGlvbn0ke2JyYWNlc1sxXX1gO1xuICB9IC8vIExpbmUgdXAgYWxsIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZSBpbiBjYXNlIHRoZSBlbnRyaWVzIGRvIG5vdCBleGNlZWRcbiAgLy8gYGJyZWFrTGVuZ3RoYC5cblxuXG4gIGlmIChpc0JlbG93QnJlYWtMZW5ndGgoY3R4LCBvdXRwdXQsIDAsIGJhc2UpKSB7XG4gICAgcmV0dXJuIGAke2JyYWNlc1swXX0ke2Jhc2UgPyBgICR7YmFzZX1gIDogJyd9ICR7am9pbiQxKG91dHB1dCwgJywgJyl9IGAgKyBicmFjZXNbMV07XG4gIH1cblxuICBjb25zdCBpbmRlbnRhdGlvbiA9ICcgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKTsgLy8gSWYgdGhlIG9wZW5pbmcgXCJicmFjZVwiIGlzIHRvbyBsYXJnZSwgbGlrZSBpbiB0aGUgY2FzZSBvZiBcIlNldCB7XCIsXG4gIC8vIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgb24gdGhlIG5leHQgbGluZSBvciB0aGVcbiAgLy8gaXRlbXMgd2lsbCBub3QgbGluZSB1cCBjb3JyZWN0bHkuXG5cbiAgY29uc3QgbG4gPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID8gJyAnIDogYCR7YmFzZSA/IGAgJHtiYXNlfWAgOiAnJ31cXG4ke2luZGVudGF0aW9ufSAgYDsgLy8gTGluZSB1cCBlYWNoIGVudHJ5IG9uIGFuIGluZGl2aWR1YWwgbGluZS5cblxuICByZXR1cm4gYCR7YnJhY2VzWzBdfSR7bG59JHtqb2luJDEob3V0cHV0LCBgLFxcbiR7aW5kZW50YXRpb259ICBgKX0gJHticmFjZXNbMV19YDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0JDEoLi4uYXJncykge1xuICByZXR1cm4gZm9ybWF0V2l0aE9wdGlvbnModW5kZWZpbmVkLCAuLi5hcmdzKTtcbn1cblxuY29uc3QgZmlyc3RFcnJvckxpbmUgPSBlcnJvciA9PiBlcnJvci5tZXNzYWdlLnNwbGl0KCdcXG4nKVswXTtcblxubGV0IENJUkNVTEFSX0VSUk9SX01FU1NBR0U7XG5cbmZ1bmN0aW9uIHRyeVN0cmluZ2lmeShhcmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gUG9wdWxhdGUgdGhlIGNpcmN1bGFyIGVycm9yIG1lc3NhZ2UgbGF6aWx5XG4gICAgaWYgKCFDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhID0ge307XG4gICAgICAgIGEuYSA9IGE7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFID0gZmlyc3RFcnJvckxpbmUoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiBmaXJzdEVycm9yTGluZShlcnIpID09PSBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxufVxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG5cblxuZnVuY3Rpb24gZm9ybWF0V2l0aE9wdGlvbnMoaW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICBsZXQgYSA9IDA7XG4gIGxldCBzdHIgPSAnJztcbiAgbGV0IGpvaW4gPSAnJztcblxuICBpZiAodHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cblxuICAgIGxldCB0ZW1wU3RyO1xuICAgIGxldCBsYXN0UG9zID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoZmlyc3QuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgLy8gJyUnXG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gZmlyc3QuY2hhckNvZGVBdCgrK2kpO1xuXG4gICAgICAgIGlmIChhICsgMSAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgICAgLy8gJ3MnXG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBBcmcgPSBhcmdzWysrYV07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wQXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHRlbXBBcmcpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcEFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wQXJnfW5gO1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnN0cjtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEFyZyAhPT0gJ29iamVjdCcgfHwgdGVtcEFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgdGVtcEFyZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaGFzT3duUHJvcGVydHkodGVtcEFyZywgJ3RvU3RyaW5nJykgLy8gQSBkaXJlY3Qgb3duIHByb3BlcnR5IG9uIHRoZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUgaW5cbiAgICAgICAgICAgICAgICAvLyBjYXNlIHRoZSBjb25zdHJ1Y3RvciBpcyBub3QgYW4gYnVpbHQtaW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHx8IChjb25zdHIgPSB0ZW1wQXJnLmNvbnN0cnVjdG9yKSAmJiAhYnVpbHRJbk9iamVjdHMuaGFzKGNvbnN0ci5uYW1lKSAmJiBjb25zdHIucHJvdG90eXBlICYmIGhhc093blByb3BlcnR5KGNvbnN0ci5wcm90b3R5cGUsICd0b1N0cmluZycpKSkge1xuICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IFN0cmluZyh0ZW1wQXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGluc3BlY3QodGVtcEFyZywgeyAuLi5pbnNwZWN0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdDogMyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6IDBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgLy8gJ2onXG4gICAgICAgICAgICAgIHRlbXBTdHIgPSB0cnlTdHJpbmdpZnkoYXJnc1srK2FdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAvLyAnZCdcbiAgICAgICAgICAgICAgY29uc3QgdGVtcE51bSA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wTnVtfW5gO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBOdW0gPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIE51bWJlcih0ZW1wTnVtKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICAgICAgLy8gJ08nXG4gICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwgaW5zcGVjdE9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgICAgIC8vICdvJ1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9IGluc3BlY3QoYXJnc1srK2FdLCB7IC4uLmluc3BlY3RPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgc2hvd0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHNob3dQcm94eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGRlcHRoOiA0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAxMDU6XG4gICAgICAgICAgICAgIC8vICdpJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wSW50ZWdlciA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wSW50ZWdlciA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcEludGVnZXJ9bmA7XG4gICAgICAgICAgICAgIH0gZWxzZSAqL1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHBhcnNlSW50KHRlbXBJbnRlZ2VyKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICAgIC8vICdmJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wRmxvYXQgPSBhcmdzWysrYV07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wRmxvYXQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHBhcnNlRmxvYXQodGVtcEZsb2F0KSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgLy8gJyUnXG4gICAgICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGNoYXJhY3RlciBpcyBub3QgYSBjb3JyZWN0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0UG9zICE9PSBpIC0gMSkge1xuICAgICAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MsIGkgLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHIgKz0gdGVtcFN0cjtcbiAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09IDM3KSB7XG4gICAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0UG9zICE9PSAwKSB7XG4gICAgICBhKys7XG4gICAgICBqb2luID0gJyAnO1xuXG4gICAgICBpZiAobGFzdFBvcyA8IGZpcnN0Lmxlbmd0aCkge1xuICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGEgPCBhcmdzLmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1thXTtcbiAgICBzdHIgKz0gam9pbjtcbiAgICBzdHIgKz0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyA/IGluc3BlY3QodmFsdWUsIGluc3BlY3RPcHRpb25zKSA6IHZhbHVlO1xuICAgIGpvaW4gPSAnICc7XG4gICAgYSsrO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbmZ1bmN0aW9uIGxvZ1RpbWUoc2VsZiwgbGFiZWwsIGxvZ0RhdGEpIHtcbiAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuXG4gIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYuX3RpbWVzLmdldChsYWJlbCk7XG5cbiAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBMYWJlbCBcIiR7bGFiZWx9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAobG9nRGF0YSkge1xuICAgIHNlbGYubG9nKGAke2xhYmVsfTogJHtkdXJhdGlvbn1tc2AsIC4uLmxvZ0RhdGEpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYubG9nKGAke2xhYmVsfTogJHtkdXJhdGlvbn1tc2ApO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBrQ29sb3JJbnNwZWN0T3B0aW9ucyA9IHtcbiAgY29sb3JzOiB0cnVlXG59O1xuY29uc3Qga05vQ29sb3JJbnNwZWN0T3B0aW9ucyA9IHt9O1xubGV0IHRhYmxlV2FybmVkOyAvLyBib29sZWFuIGZsYWcgZm9yIG9uZS10aW1lIHdhcm5pbmcgYWJvdXQgY29uc29sZS50YWJsZSBub3QgYmVpbmcgaW1wbGVtZW50ZWRcbi8vIE1ha2UgYSBmdW5jdGlvbiB0aGF0IGNhbiBzZXJ2ZSBhcyB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIGBzdHJlYW0ud3JpdGUoKWAuXG5cbmZ1bmN0aW9uIGNyZWF0ZVdyaXRlRXJyb3JIYW5kbGVyKHN0cmVhbSkge1xuICByZXR1cm4gZXJyID0+IHtcbiAgICAvLyBUaGlzIGNvbmRpdGlvbmFsIGV2YWx1YXRlcyB0byB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgIC8vIHRoYXQgd2FzIG5vdCBhbHJlYWR5IGVtaXR0ZWQgKHdoaWNoIGhhcHBlbnMgd2hlbiB0aGUgX3dyaXRlIGNhbGxiYWNrXG4gICAgLy8gaXMgaW52b2tlZCBhc3luY2hyb25vdXNseSkuXG4gICAgaWYgKGVyciAhPT0gbnVsbCAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCBpdCB3aWxsIGJlIGVtaXR0ZWQgb24gYHN0cmVhbWAgYXNcbiAgICAgIC8vIGFuIGBlcnJvcmAgZXZlbnQuIEFkZGluZyBhIGBvbmNlYCBsaXN0ZW5lciB3aWxsIGtlZXAgdGhhdCBlcnJvclxuICAgICAgLy8gZnJvbSBiZWNvbWluZyBhbiB1bmNhdWdodCBleGNlcHRpb24sIGJ1dCBzaW5jZSB0aGUgaGFuZGxlciBpc1xuICAgICAgLy8gcmVtb3ZlZCBhZnRlciB0aGUgZXZlbnQsIG5vbi1jb25zb2xlLiogd3JpdGVzIHdvbid0IGJlIGFmZmVjdGVkLlxuICAgICAgLy8gd2UgYXJlIG9ubHkgYWRkaW5nIG5vb3AgaWYgdGhlcmUgaXMgbm8gb25lIGVsc2UgbGlzdGVuaW5nIGZvciAnZXJyb3InXG4gICAgICBpZiAoc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgbm9vcCQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIENvbnNvbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzdGRlcnIsIGlnbm9yZUVycm9ycykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBpTmFtZSA9PT0gJ1RpLkFQSScpIHtcbiAgICAgIC8vIFBhc3NpbmcgaW4gVGkuQVBJIG1vZHVsZSB3aGVyZSB3ZSByZXRhaW4gbG9nIGxldmVsc1xuICAgICAgdGhpcy5fYXBpTW9kdWxlID0gb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS5KUyBzdHJlYW1zXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm8gYXJncywgb3IgZmlyc3QgYXJnIGlzIGEgc3RyZWFtXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3Rkb3V0OiBvcHRpb25zLFxuICAgICAgICAgIHN0ZGVycixcbiAgICAgICAgICBpZ25vcmVFcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3Rkb3V0ID0gb3B0aW9ucy5zdGRvdXQ7IC8vIFRPRE86IGVuZm9yY2UgaGFzIHdyaXRlIGZ1bmN0aW9uP1xuXG4gICAgICB0aGlzLl9zdGRlcnIgPSBvcHRpb25zLnN0ZGVyciB8fCB0aGlzLl9zdGRvdXQ7XG4gICAgICB0aGlzLl9pZ25vcmVFcnJvcnMgPSBvcHRpb25zLmlnbm9yZUVycm9ycyAhPT0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLl9pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhpcy5fc3Rkb3V0RXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3Rkb3V0KTtcbiAgICAgICAgdGhpcy5fc3RkZXJyRXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3RkZXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29sb3JNb2RlID0gb3B0aW9ucy5jb2xvck1vZGUgfHwgJ2F1dG8nOyAvLyBUT0RPOiBlbmZvcmNlIGJvb2xlYW4gb3IgJ2F1dG8nXG5cbiAgICAgIHRoaXMuX2luc3BlY3RPcHRpb25zID0gb3B0aW9ucy5pbnNwZWN0T3B0aW9uczsgLy8gVE9ETzogZW5mb3JjZSB1bmRlZmluZWQgb3IgdHlwZW9mICdvYmplY3QnXG4gICAgfVxuXG4gICAgdGhpcy5fdGltZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY291bnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2dyb3VwSW5kZW50ID0gJyc7XG4gIH1cblxuICBfd3JpdGVUb0NvbnNvbGUobGV2ZWwsIHN0cmluZykge1xuICAgIGlmICh0aGlzLl9ncm91cEluZGVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXG4vZywgYFxcbiR7dGhpcy5fZ3JvdXBJbmRlbnR9YCk7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHRoaXMuX2dyb3VwSW5kZW50ICsgc3RyaW5nO1xuICAgIH0gLy8gU3VwcG9ydCB3cmFwcGluZyBUaS5BUEkgKHdoaWNoIHJldGFpbnMgbG9nIGxldmVsKVxuXG5cbiAgICBpZiAodGhpcy5fYXBpTW9kdWxlKSB7XG4gICAgICB0aGlzLl9hcGlNb2R1bGVbbGV2ZWxdKHN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgTm9kZS5KUyBzdHJlYW1zIGxpa2Ugc3Rkb3V0L3N0ZGVyciB3aGljaCBkb24ndCBoYXZlIGxvZyBsZXZlbHNcbiAgICAgIGNvbnN0IHVzZVN0ZEVyciA9IGxldmVsID09PSAnd2FybicgfHwgbGV2ZWwgPT09ICdlcnJvcicgfHwgbGV2ZWwgPT09ICd0cmFjZSc7XG4gICAgICBjb25zdCBzdHJlYW0gPSB1c2VTdGRFcnIgPyB0aGlzLl9zdGRlcnIgOiB0aGlzLl9zdGRvdXQ7XG5cbiAgICAgIGlmICh0aGlzLl9pZ25vcmVFcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ud3JpdGUoc3RyaW5nKTtcbiAgICAgIH0gLy8gVGhlcmUgbWF5IGJlIGFuIGVycm9yIG9jY3VycmluZyBzeW5jaHJvbm91c2x5IChlLmcuIGZvciBmaWxlcyBvciBUVFlzXG4gICAgICAvLyBvbiBQT1NJWCBzeXN0ZW1zKSBvciBhc3luY2hyb25vdXNseSAoZS5nLiBwaXBlcyBvbiBQT1NJWCBzeXN0ZW1zKSwgc29cbiAgICAgIC8vIGhhbmRsZSBib3RoIHNpdHVhdGlvbnMuXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQWRkIGFuZCBsYXRlciByZW1vdmUgYSBub29wIGVycm9yIGhhbmRsZXIgdG8gY2F0Y2ggc3luY2hyb25vdXMgZXJyb3JzLlxuICAgICAgICBpZiAoc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub29wJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gdXNlU3RkRXJyID8gdGhpcy5fc3RkZXJyRXJyb3JIYW5kbGVyIDogdGhpcy5fc3Rkb3V0RXJyb3JIYW5kbGVyO1xuICAgICAgICBzdHJlYW0ud3JpdGUoc3RyaW5nLCBlcnJvckhhbmRsZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDb25zb2xlIGlzIGEgZGVidWdnaW5nIHV0aWxpdHksIHNvIGl0IHN3YWxsb3dpbmcgZXJyb3JzIGlzIG5vdCBkZXNpcmFibGVcbiAgICAgICAgLy8gZXZlbiBpbiBlZGdlIGNhc2VzIHN1Y2ggYXMgbG93IHN0YWNrIHNwYWNlLlxuICAgICAgICBpZiAoaXNTdGFja092ZXJmbG93RXJyb3IoZSkpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IC8vIFNvcnJ5LCB0aGVyZSdzIG5vIHByb3BlciB3YXkgdG8gcGFzcyBhbG9uZyB0aGUgZXJyb3IgaGVyZS5cblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyICYmIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBub29wJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluZm8oLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdpbmZvJywgZm9ybWF0V2l0aE9wdGlvbnMoa0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuXG4gIHdhcm4oLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCd3YXJuJywgZm9ybWF0V2l0aE9wdGlvbnMoa05vQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG5cbiAgZXJyb3IoLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdlcnJvcicsIGZvcm1hdFdpdGhPcHRpb25zKGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuXG4gIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnZGVidWcnLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG5cbiAgdHJhY2UoLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCd0cmFjZScsIGZvcm1hdFdpdGhPcHRpb25zKGtDb2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cblxuICBjbGVhcigpIHt9IC8vIG5vLW9wXG5cblxuICBncm91cCguLi5kYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5sb2coLi4uZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ3JvdXBJbmRlbnQgKz0gJyAgJztcbiAgfVxuXG4gIGdyb3VwRW5kKCkge1xuICAgIHRoaXMuX2dyb3VwSW5kZW50ID0gdGhpcy5fZ3JvdXBJbmRlbnQuc2xpY2UoMCwgdGhpcy5fZ3JvdXBJbmRlbnQubGVuZ3RoIC0gMik7XG4gIH1cblxuICBkaXIob2JqLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2luZm8nLCBpbnNwZWN0KG9iaiwge1xuICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSkpO1xuICB9XG5cbiAgYXNzZXJ0KHZhbHVlLCAuLi5hcmdzKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgYXJnc1swXSA9IGBBc3NlcnRpb24gZmFpbGVkJHthcmdzLmxlbmd0aCA9PT0gMCA/ICcnIDogYDogJHthcmdzWzBdfWB9YDtcbiAgICAgIHRoaXMud2FybiguLi5hcmdzKTsgLy8gVGhlIGFyZ3VtZW50cyB3aWxsIGJlIGZvcm1hdHRlZCBpbiB3YXJuKCkgYWdhaW5cbiAgICB9XG4gIH1cblxuICBjb3VudChsYWJlbCA9ICdkZWZhdWx0Jykge1xuICAgIC8vIEVuc3VyZXMgdGhhdCBsYWJlbCBpcyBhIHN0cmluZywgYW5kIG9ubHkgdGhpbmdzIHRoYXQgY2FuIGJlXG4gICAgLy8gY29lcmNlZCB0byBzdHJpbmdzLiBlLmcuIFN5bWJvbCBpcyBub3QgYWxsb3dlZFxuICAgIGxhYmVsID0gYCR7bGFiZWx9YDtcblxuICAgIGxldCBjb3VudCA9IHRoaXMuX2NvdW50cy5nZXQobGFiZWwpO1xuXG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQrKztcbiAgICB9XG5cbiAgICB0aGlzLl9jb3VudHMuc2V0KGxhYmVsLCBjb3VudCk7XG5cbiAgICB0aGlzLmxvZyhgJHtsYWJlbH06ICR7Y291bnR9YCk7XG4gIH1cblxuICBjb3VudFJlc2V0KGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgaWYgKCF0aGlzLl9jb3VudHMuaGFzKGxhYmVsKSkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgQ291bnQgZm9yICcke2xhYmVsfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb3VudHMuZGVsZXRlKGAke2xhYmVsfWApO1xuICB9XG5cbiAgdGltZShsYWJlbCA9ICdkZWZhdWx0Jykge1xuICAgIGxhYmVsID0gYCR7bGFiZWx9YDtcblxuICAgIGlmICh0aGlzLl90aW1lcy5oYXMobGFiZWwpKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBMYWJlbCAke2xhYmVsfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdGltZXMuc2V0KGxhYmVsLCBEYXRlLm5vdygpKTtcbiAgfVxuXG4gIHRpbWVFbmQobGFiZWwgPSAnZGVmYXVsdCcpIHtcbiAgICBjb25zdCB3YXJuZWQgPSBsb2dUaW1lKHRoaXMsIGxhYmVsKTtcblxuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB0aGlzLl90aW1lcy5kZWxldGUobGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIHRpbWVMb2cobGFiZWwgPSAnZGVmYXVsdCcsIC4uLmxvZ0RhdGEpIHtcbiAgICBsb2dUaW1lKHRoaXMsIGxhYmVsLCBsb2dEYXRhKTtcbiAgfSAvLyBUT0RPOiBpbXBsZW1lbnQgY29uc29sZS50YWJsZSgpXG5cblxuICB0YWJsZSgpIHtcbiAgICBpZiAoIXRhYmxlV2FybmVkKSB7XG4gICAgICB0YWJsZVdhcm5lZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdcImNvbnNvbGUudGFibGVcIiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFRpdGFuaXVtIScpO1xuICAgIH1cbiAgfVxuXG59XG5cbkNvbnNvbGUucHJvdG90eXBlLmxvZyA9IENvbnNvbGUucHJvdG90eXBlLmluZm87IC8vIFRyZWF0IGxvZyBhcyBhbGlhcyB0byBpbmZvXG5cbkNvbnNvbGUucHJvdG90eXBlLmRpcnhtbCA9IENvbnNvbGUucHJvdG90eXBlLmxvZzsgLy8gVHJlYXQgZGlyeG1sIGFzIGFsaWFzIHRvIGxvZ1xuXG5Db25zb2xlLnByb3RvdHlwZS5ncm91cENvbGxhcHNlZCA9IENvbnNvbGUucHJvdG90eXBlLmdyb3VwO1xuY29uc3QgZ2xvYmFsQ29uc29sZSA9IG5ldyBDb25zb2xlKFRpLkFQSSk7XG5nbG9iYWxDb25zb2xlLkNvbnNvbGUgPSBDb25zb2xlO1xuZ2xvYmFsLmNvbnNvbGUgPSBnbG9iYWxDb25zb2xlO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cbntcbiAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVEYXRlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBJbnRsLkRhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCBvbGRPcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvbGRPcHRpb25zIHx8ICFvbGRPcHRpb25zLmRhdGVTdHlsZSAmJiAhb2xkT3B0aW9ucy5tb250aCAmJiAhb2xkT3B0aW9ucy5kYXkgJiYgIW9sZE9wdGlvbnMueWVhcikge1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICB5ZWFyOiAnbnVtZXJpYydcbiAgICAgIH07XG4gICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzLmxvY2FsZSwgcHJvcGVydGllcy5vcHRpb25zKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICBEYXRlLnByb3RvdHlwZS50b0xvY2FsZVRpbWVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IEludGwuRGF0ZVRpbWVGb3JtYXQuX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IG9sZE9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9sZE9wdGlvbnMgfHwgIW9sZE9wdGlvbnMudGltZVN0eWxlICYmICFvbGRPcHRpb25zLmhvdXIgJiYgIW9sZE9wdGlvbnMubWludXRlICYmICFvbGRPcHRpb25zLnNlY29uZCkge1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICB9O1xuICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb2xkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcy5sb2NhbGUsIHByb3BlcnRpZXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IEludGwuRGF0ZVRpbWVGb3JtYXQuX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IG9sZE9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnM7XG4gICAgbGV0IGhhc09wdGlvbiA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZE9wdGlvbnMpIHtcbiAgICAgIGhhc09wdGlvbiA9ICEhb2xkT3B0aW9ucy5kYXRlU3R5bGUgfHwgISFvbGRPcHRpb25zLnRpbWVTdHlsZSB8fCAhIW9sZE9wdGlvbnMud2Vla2RheSB8fCAhIW9sZE9wdGlvbnMubW9udGggfHwgISFvbGRPcHRpb25zLmRheSB8fCAhIW9sZE9wdGlvbnMueWVhciB8fCAhIW9sZE9wdGlvbnMuaG91ciB8fCAhIW9sZE9wdGlvbnMubWludXRlIHx8ICEhb2xkT3B0aW9ucy5zZWNvbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNPcHRpb24pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9sZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHByb3BlcnRpZXMubG9jYWxlLCBwcm9wZXJ0aWVzLm9wdGlvbnMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLy8gQWRkIGEgdG9KU09OKCkgbWV0aG9kIHRvIGFsbCBFcnJvciBvYmplY3RzIG5lZWRlZCB0byBvdXRwdXQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcy5cbi8vIFRoZSBKU09OLnN0cmluZ2lmeSgpIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kIGlmIGl0IGV4aXN0cyB0byBwcm92aWRlIGN1c3RvbSBvdXRwdXQuXG4vLyBOb3Rlczpcbi8vIC0gSW4gVjgsIGFsbCBFcnJvciBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZS4gV2UgbmVlZCB0aGlzIG9yIGVsc2Ugc3RyaW5naWZ5KCkgd2lsbCByZXR1cm4gXCJ7fVwiLlxuLy8gLSBJbiBKYXZhU2NyaXB0Q29yZSwgb25seSB0aGUgXCJzdGFja1wiIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlLiBXZSB3YW50IHRvIHJldmVhbCB0aGlzLlxuaWYgKHR5cGVvZiBFcnJvci5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG4gIEVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm9wZXJ0aWVzW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFwiY3JlYXRpb25cIiBwcm9wZXJ0aWVzIGRpY3Rpb25hcnkgZm9yIFRpdGFuaXVtJ3MgQ29sbGF0b3IsIERhdGVUaW1lRm9ybWF0LCBhbmQgTnVtYmVyRm9ybWF0IHByb3hpZXNcbiAqIGZyb20gdGhlIGdpdmVuIEludGwgdHlwZSdzIGNvbnN0cnVjdG9yIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0W119IGFyZ3NcbiAqIFRoZSBhcmd1bWVudHMgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGludG8gSW50bCBDb2xsYXRvciwgRGF0ZVRpbWVGb3JtYXQsIG9yIE51bWJlckZvcm1hdCB0eXBlJ3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBwb3J0ZWRGb3JtYXRMb2NhbGVzRnVuY3Rpb24gUmVmZXJlbmNlIHRvIGEgc3VwcG9ydGVkTG9jYWxlc09mKCkgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBwcm9wZXJ0aWVzIGRpY3Rpb25hcnkgdG8gYmUgcGFzc2VkIGludG8gYSBUaXRhbml1bSBwcm94eSdzIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJncywgc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcblxuICBpZiAoYXJncy5sZW5ndGggPj0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3BlcnRpZXMubG9jYWxlID0gYXJnc1swXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSBzdXBwb3J0ZWRGb3JtYXRMb2NhbGVzRnVuY3Rpb24oYXJnc1swXSk7XG5cbiAgICAgIGlmIChzdXBwb3J0ZWRMb2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvcGVydGllcy5sb2NhbGUgPSBzdXBwb3J0ZWRMb2NhbGVzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCA+PSAyICYmIHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0Jykge1xuICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IGFyZ3NbMV07XG4gIH1cblxuICByZXR1cm4gcHJvcGVydGllcztcbn0gLy8gQWRkIFwiSW50bFwiIEFQSXMgbWlzc2luZyBvbiBBbmRyb2lkLlxuXG5cbntcbiAgLy8gU2V0IHVwIGFuIFwiSW50bC5Db2xsYXRvclwiIHR5cGUgd2hpY2ggd3JhcHMgb3VyIHVuZG9jdW1lbnRlZCBcIlRpLkxvY2FsZS5Db2xsYXRvclwiIHByb3h5LlxuICBmdW5jdGlvbiBUaUNvbGxhdG9yKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZENvbGxhdG9yTG9jYWxlcyk7XG4gICAgY29uc3QgY29sbGF0b3IgPSBuZXcgVGkuTG9jYWxlLkNvbGxhdG9yKHByb3BlcnRpZXMpO1xuICAgIGNvbGxhdG9yLmNvbXBhcmUgPSBjb2xsYXRvci5jb21wYXJlLmJpbmQoY29sbGF0b3IpO1xuICAgIHJldHVybiBjb2xsYXRvcjtcbiAgfVxuXG4gIFRpQ29sbGF0b3Iuc3VwcG9ydGVkTG9jYWxlc09mID0gVGkuTG9jYWxlLmdldFN1cHBvcnRlZENvbGxhdG9yTG9jYWxlczsgLy8gU2V0IHVwIGFuIFwiSW50bC5EYXRlVGltZUZvcm1hdFwiIHR5cGUgd2hpY2ggd3JhcHMgb3VyIHVuZG9jdW1lbnRlZCBcIlRpLkxvY2FsZS5EYXRlVGltZUZvcm1hdFwiIHByb3h5LlxuXG4gIGZ1bmN0aW9uIFRpRGF0ZVRpbWVGb3JtYXQoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzLCBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkRGF0ZVRpbWVGb3JtYXRMb2NhbGVzKTtcbiAgICByZXR1cm4gbmV3IFRpLkxvY2FsZS5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIFRpRGF0ZVRpbWVGb3JtYXQuX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20gPSBhcmdzID0+IHtcbiAgICByZXR1cm4gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmdzLCBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkRGF0ZVRpbWVGb3JtYXRMb2NhbGVzKTtcbiAgfTtcblxuICBUaURhdGVUaW1lRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZiA9IFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWREYXRlVGltZUZvcm1hdExvY2FsZXM7IC8vIFNldCB1cCBhbiBcIkludGwuTnVtYmVyRm9ybWF0XCIgdHlwZSB3aGljaCB3cmFwcyBvdXIgdW5kb2N1bWVudGVkIFwiVGkuTG9jYWxlLk51bWJlckZvcm1hdFwiIHByb3h5LlxuXG4gIGZ1bmN0aW9uIFRpTnVtYmVyRm9ybWF0KCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZE51bWJlckZvcm1hdExvY2FsZXMpO1xuICAgIHJldHVybiBuZXcgVGkuTG9jYWxlLk51bWJlckZvcm1hdChwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIFRpTnVtYmVyRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZiA9IFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWROdW1iZXJGb3JtYXRMb2NhbGVzOyAvLyBNYWtlIG91ciBjdXN0b20gXCJJbnRsXCIgbW9kdWxlIGF2YWlsYWJsZSBnbG9iYWxseS5cblxuICBjb21tb25qc0dsb2JhbC5JbnRsID0ge1xuICAgIENvbGxhdG9yOiBUaUNvbGxhdG9yLFxuICAgIERhdGVUaW1lRm9ybWF0OiBUaURhdGVUaW1lRm9ybWF0LFxuICAgIE51bWJlckZvcm1hdDogVGlOdW1iZXJGb3JtYXQsXG4gICAgZ2V0Q2Fub25pY2FsTG9jYWxlczogVGkuTG9jYWxlLmdldENhbm9uaWNhbExvY2FsZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIE51bWJlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KC4uLmFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcy52YWx1ZU9mKCkpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cbntcbiAgU3RyaW5nLnByb3RvdHlwZS5sb2NhbGVDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVTdHJpbmcsIGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKGxvY2FsZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb2xsYXRvci5jb21wYXJlKHRoaXMsIGNvbXBhcmVTdHJpbmcpO1xuICB9O1xuXG4gIFN0cmluZy5wcm90b3R5cGUudG9Mb2NhbGVMb3dlckNhc2UgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIFRpLkxvY2FsZS5tYWtlTG93ZXJDYXNlKHRoaXMsIGxvY2FsZSk7XG4gIH07XG5cbiAgU3RyaW5nLnByb3RvdHlwZS50b0xvY2FsZVVwcGVyQ2FzZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICByZXR1cm4gVGkuTG9jYWxlLm1ha2VVcHBlckNhc2UodGhpcywgbG9jYWxlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCB0byBoaWphY2sgdGhlIHN0YW5kYXJkIHJlcXVpcmUgdG8gYWxsb3cgZm9yIEpTXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgXCJjb3JlXCIgbW9kdWxlcy5cbiAqXG4gKiBZb3UgYWRkIGEgYmluZGluZyBmcm9tIHRoZSBcImNvcmVcIiBtb2R1bGUgaWQgdG8gdGhlIHVuZGVyIHRoZSBob29kIEpTXG4gKiBpbXBsZW1lbnRhdGlvbi4gV2UgdGhlbiBpbnRlcmNlcHQgcmVxdWlyZSBjYWxscyB0byBoYW5kbGUgcmVxdWVzdHMgZm9yIHRoZXNlIG1vZHVsZXNcbiAqIGFuZCBsYXppbHkgbG9hZCB0aGUgZmlsZS5cbiAqL1xuXG4vKipcbiAqIFVzZWQgYnkgQGZ1bmN0aW9uIGJpbmRPYmplY3RUb0NvcmVNb2R1bGVJZFxuICogQHR5cGUge21hcDxzdHJpbmcsIG9iamVjdD59XG4gKi9cbmNvbnN0IGJpbmRpbmdzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBVc2VkIGJ5IEBmdW5jdGlvbiByZWRpcmVjdENvcmVNb2R1bGVJZFRvUGF0aFxuICogQHR5cGUge21hcDxzdHJpbmcsIHN0cmluZz59XG4gKi9cblxuY29uc3QgcmVkaXJlY3RzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBEb2VzIHRoZSByZXF1ZXN0IGxvb2sgbGlrZSBhIHR5cGljYWwgY29yZSBtb2R1bGU/IChubyAnLicgb3IgJy8nIGNoYXJhY3RlcnMpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBvcmlnaW5hbCByZXF1aXJlIHBhdGgvaWRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzSGlqYWNrYWJsZU1vZHVsZUlkKHBhdGgpIHtcbiAgaWYgKCFwYXRoIHx8IHBhdGgubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hhciA9IHBhdGguY2hhckF0KDApO1xuICByZXR1cm4gZmlyc3RDaGFyICE9PSAnLicgJiYgZmlyc3RDaGFyICE9PSAnLyc7XG59IC8vIEhhY2sgcmVxdWlyZSB0byBwb2ludCB0byB0aGlzIGFzIGNvcmUgbW9kdWxlIFwiYmluZGluZ1wiLiAoTm90ZSB0aGF0IGlPUyBkb2VzIG5vdCBoYXZlIGEgZ2xvYmFsIHJlcXVpcmUuKVxuXG5cbmNvbnN0IG9yaWdpbmFsUmVxdWlyZSA9IGdsb2JhbC5yZXF1aXJlID8gZ2xvYmFsLnJlcXVpcmUgOiByZXF1aXJlLm1haW4ucmVxdWlyZS5iaW5kKHJlcXVpcmUubWFpbik7IC8vIFRoaXMgd29ya3MgZm9yIFdpbmRvd3MgYXMtaXMsIGFuZCBhbHNvIGludGVyY2VwdHMgdGhlIGNhbGwgb24gQW5kcm9pZC9pT1MgZm9yIHRpLm1haW4uanMgKHRoZSBmaXJzdCBmaWxlIGV4ZWN1dGVkKVxuXG5nbG9iYWwucmVxdWlyZSA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIHJldHVybiBiaW5kaW5ncy5nZXQobW9kdWxlSWQpO1xuICB9XG5cbiAgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgbW9kdWxlSWQgPSByZWRpcmVjdHMuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbFJlcXVpcmUobW9kdWxlSWQpO1xufTsgLy8gLi4uIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhhY2sgaXQgd2hlbiByZXF1aXJpbmcgZnJvbSBvdGhlciBmaWxlcyBmb3IgQW5kcm9pZC9pT1MgKGR1ZSB0byBtb2R1bGUuanMgaW1wbClcblxuXG5jb25zdCBvcmlnaW5hbE1vZHVsZVJlcXVpcmUgPSBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlO1xuXG5nbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgaWYgKGJpbmRpbmdzLmhhcyhwYXRoKSkge1xuICAgIHJldHVybiBiaW5kaW5ncy5nZXQocGF0aCk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhwYXRoKSkge1xuICAgIHBhdGggPSByZWRpcmVjdHMuZ2V0KHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIG9yaWdpbmFsTW9kdWxlUmVxdWlyZS5jYWxsKHRoaXMsIHBhdGgsIGNvbnRleHQpO1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIGFuIGFscmVhZHkgbG9hZGVkL2NvbnN0cnVjdGVkIG9iamVjdC92YWx1ZSB0byBleHBvcnQgZm9yIHRoYXQgY29yZSBtb2R1bGUgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0geyp9IGJpbmRpbmcgYW4gYWxyZWFkeSBjb25zdHJ1Y3R1cmVkIHZhbHVlL29iamVjdCB0byByZXR1cm5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKG1vZHVsZUlkLCBiaW5kaW5nKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgZm9yIHJlbGF0aXZlL2Fic29sdXRlIGZpbGUgcGF0aHM7IG5vIGxlYWRpbmcgJy4nIG9yICcvJyBhbGxvd2VkICh3YXMgZ2l2ZW4gJHttb2R1bGVJZH0pYCk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICAgIHJlZGlyZWN0cy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICB9XG5cbiAgYmluZGluZ3Muc2V0KG1vZHVsZUlkLCBiaW5kaW5nKTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIHRoZSBmdWxsIHVuZGVyIHRoZSBob29kIGZpbGVwYXRoIGlmIGdpdmVuIGEgc3RyaW5nLlxuICogVGhpcyBhbGxvd3MgZm9yIGxhenkgaW5zdGFudGlhdGlvbiBvZiB0aGUgbW9kdWxlIG9uLWRlbWFuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCB0aGUgbW9kdWxlIGlkIHRvIFwiaGlqYWNrXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCB0aGUgZnVsbCBmaWxlcGF0aCB0byByZXF1aXJlIHVuZGVyIHRoZSBob29kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIHNob3VsZCBiZSBhbiBhbHJlYWR5IHJlc29sdmVkIGFic29sdXRlIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIG90aGVyd2lzZSB0aGUgY29udGV4dCBvZiB0aGUgY2FsbCBjb3VsZCBjaGFuZ2Ugd2hhdCBnZXRzIGxvYWRlZCFcbiAqL1xuXG5mdW5jdGlvbiByZWRpcmVjdChtb2R1bGVJZCwgZmlsZXBhdGgpIHtcbiAgaWYgKCFpc0hpamFja2FibGVNb2R1bGVJZChtb2R1bGVJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiAke21vZHVsZUlkfSlgKTtcbiAgfVxuXG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgICBiaW5kaW5ncy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgfVxuXG4gIHJlZGlyZWN0cy5zZXQobW9kdWxlSWQsIGZpbGVwYXRoKTtcbn0gLy8gRklYTUU6IFRoZXJlJ3MgYSBjb2xsaXNpb24gaGVyZSB3aXRoIGdsb2JhbC5iaW5kaW5nIGRlY2xhcmVkIGluIEtyb2xsQnJpZGdlLm0gb24gaU9TXG5cbmlmICghZ2xvYmFsLmJpbmRpbmcpIHtcbiAgZ2xvYmFsLmJpbmRpbmcgPSB7fTtcbn1cblxuZ2xvYmFsLmJpbmRpbmcucmVnaXN0ZXIgPSByZWdpc3Rlcjtcbmdsb2JhbC5iaW5kaW5nLnJlZGlyZWN0ID0gcmVkaXJlY3Q7XG5cbi8vIExvYWQgYWxsIEphdmFTY3JpcHQgZXh0ZW5zaW9ucy9wb2x5ZmlsbHNcbnJlZ2lzdGVyKCdjb25zb2xlJywgZ2xvYmFsQ29uc29sZSk7XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGluIEpTT04gc3RydWN0dXJlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRhbml1bS5BY3Rpdml0eS5wcm90b3R5cGUsICd0b0pTT04nLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICAgIGNvbnN0IGtleUNvdW50ID0ga2V5cy5sZW5ndGg7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0ge307XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoayA9PT0gJ3dpbmRvdycgfHwgayA9PT0gJ2ludGVudCcgfHwgay5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWFsaXplZFtrXSA9IHRoaXNba107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBjb25zdCBQcm9wZXJ0aWVzID0gVGl0YW5pdW0uQXBwLlByb3BlcnRpZXM7XG5cbiAgZnVuY3Rpb24gbnVsbE9yRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BlcnR5R2V0dGVyKGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgaWYgKCFQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxPckRlZmF1bHRWYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsZWdhdGUuY2FsbChQcm9wZXJ0aWVzLCBrZXkpO1xuICAgIH07XG4gIH1cblxuICBbJ2dldEJvb2wnLCAnZ2V0RG91YmxlJywgJ2dldEludCcsICdnZXRTdHJpbmcnXS5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICBQcm9wZXJ0aWVzW2dldHRlcl0gPSBwcm9wZXJ0eUdldHRlcihQcm9wZXJ0aWVzW2dldHRlcl0pO1xuICB9KTtcblxuICBQcm9wZXJ0aWVzLmdldExpc3QgPSBQcm9wZXJ0aWVzLmdldE9iamVjdCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghUHJvcGVydGllcy5oYXNQcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbE9yRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoUHJvcGVydGllcy5nZXRTdHJpbmcoa2V5KSk7XG4gIH07XG5cbiAgUHJvcGVydGllcy5zZXRMaXN0ID0gUHJvcGVydGllcy5zZXRPYmplY3QgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBQcm9wZXJ0aWVzLnNldFN0cmluZyhrZXksIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOS1QcmVzZW50IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCwgT1NfSU9TLCBPU19WRVJTSU9OX01BSk9SICovXG5jb25zdCBidWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICB2YWx1ZTogJydcbn0pO1xuY29uc3QgYmxvYiA9IGJ1ZmZlci50b0Jsb2IoKTtcbmNvbnN0IEJsb2JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmxvYik7XG5cbntcbiAgLy8gVGhpcyBkb2Vzbid0IFwic3RpY2tcIiBmb3IgaU9TLiBJdCBpcyBpbXBsZW1lbnRlZCBuYXRpdmVseS5cbiAgLy8gV2ViIEJsb2IgaGFzIGFuIGFycmF5QnVmZmVyKCkgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFByb21pc2VcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvYXJyYXlCdWZmZXJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2JQcm90b3R5cGUsICdhcnJheUJ1ZmZlcicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGJ1ZjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJ1ZiA9IHRoaXMudG9BcnJheUJ1ZmZlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGJ1Zik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xuXG57XG4gIGNvbnN0IExvY2FsZSA9IFRpdGFuaXVtLkxvY2FsZTtcbiAgY29uc3Qgd3JhcHBlZEdldFN0cmluZyA9IExvY2FsZS5nZXRTdHJpbmc7XG5cbiAgTG9jYWxlLmdldFN0cmluZyA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVR5cGUgPSB0eXBlb2YgZGVmYXVsdFZhbHVlOyAvLyBJZiB0aGUgaGludC9kZWZhdWx0IGlzIG5vdCBhIHN0cmluZywgaWdub3JlIGl0IVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gd3JhcHBlZEdldFN0cmluZy5jYWxsKExvY2FsZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlZEdldFN0cmluZy5jYWxsKExvY2FsZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9O1xuXG4gIGNvbW1vbmpzR2xvYmFsLkwgPSBMb2NhbGUuZ2V0U3RyaW5nO1xufVxuXG4vLyBLZWVwcyBhbiBvYmplY3QgYWxpdmUgdW50aWwgZGlzcG9zZSgpIGlzIGNhbGxlZC5cbi8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgdG8ga2VlcCBcInRvcCBsZXZlbFwiIG9iamVjdHNcbi8vIChleDogd2luZG93cywgdGFiIGdyb3VwcykgYWxpdmUgdW50aWwgdGhlaXIgbGlmZWN5Y2xlIGVuZHMuXG5mdW5jdGlvbiBQZXJzaXN0ZW50SGFuZGxlKG9iamVjdCkge1xuICB0aGlzLmNlbGwgPSBQZXJzaXN0ZW50SGFuZGxlLmxhc3RJZCsrO1xuICBQZXJzaXN0ZW50SGFuZGxlLm9iamVjdHNbdGhpcy5jZWxsXSA9IG9iamVjdDtcbn0gLy8gT2JqZWN0cyByZXRhaW5lZCBieSBwZXJzaXN0ZW50IGhhbmRsZXMuXG4vLyBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBhY3RzIGFzIGEgc3RvcmFnZSBcImNlbGxcIlxuLy8ga2VlcGluZyB0aGUgb2JqZWN0IHJlYWNoYWJsZSBhbmQgYWxpdmUgdW50aWwgaXQgaXMgcmVtb3ZlZC5cblxuXG5QZXJzaXN0ZW50SGFuZGxlLm9iamVjdHMgPSB7fTtcblBlcnNpc3RlbnRIYW5kbGUubGFzdElkID0gMDtcblxuUGVyc2lzdGVudEhhbmRsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2VsbCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIGhhbmRsZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlbGV0ZSBQZXJzaXN0ZW50SGFuZGxlLm9iamVjdHNbdGhpcy5jZWxsXTtcbiAgdGhpcy5jZWxsID0gLTE7XG59O1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxMy1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG57XG4gIGNvbnN0IEhUVFBDbGllbnQgPSBUaXRhbml1bS5OZXR3b3JrLkhUVFBDbGllbnQ7XG4gIGNvbnN0IF9zZW5kID0gSFRUUENsaWVudC5wcm90b3R5cGUuc2VuZDtcblxuICBIVFRQQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBSZXRhaW4gdGhlIGh0dHBjbGllbnQgdW50aWwgdGhlIHJlcXVlc3QgaGFzIGJlZW4gZmluaXNoZWQuXG4gICAgY29uc3QgaGFuZGxlID0gbmV3IFBlcnNpc3RlbnRIYW5kbGUodGhpcyk7XG4gICAgdGhpcy5vbignZGlzcG9zZWhhbmRsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZS5kaXNwb3NlKCk7XG5cbiAgICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgICAga3JvbGwubG9nKCdIVFRQQ2xpZW50JywgJ1RoZSBwZXJzaXN0ZW50IGhhbmRsZSBpcyBkaXNwb3NlZC4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9zZW5kLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDEyLVByZXNlbnQgYnkgQXBwY2VsZXJhdG9yLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBmdW5jdGlvbiBpUGhvbmVDb25zdGFudChuYW1lKSB7XG4gICAgVGl0YW5pdW0uQVBJLmVycm9yKCchISEnKTtcbiAgICBUaXRhbml1bS5BUEkuZXJyb3IoJyEhISBXQVJOSU5HIDogVXNlIG9mIHVuc3VwcG9ydGVkIGNvbnN0YW50IFRpLlVJLmlQaG9uZS4nICsgbmFtZSArICcgISEhJyk7XG4gICAgVGl0YW5pdW0uQVBJLmVycm9yKCchISEnKTtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgbWUuIE9ubHkgZm9yIHRlbXBvcmFyeSBjb21wYXRpYmlsaXR5XG5cblxuICBUaXRhbml1bS5VSS5pUGhvbmUgPSB7XG4gICAgQWN0aXZpdHlJbmRpY2F0b3JTdHlsZToge1xuICAgICAgZ2V0IEJJRygpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdBY3Rpdml0eUluZGljYXRvclN0eWxlLkJJRycpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IERBUksoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnQWN0aXZpdHlJbmRpY2F0b3JTdHlsZS5EQVJLJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIEFuaW1hdGlvblN0eWxlOiB7XG4gICAgICBnZXQgRkxJUF9GUk9NX0xFRlQoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnQW5pbWF0aW9uU3R5bGUuRkxJUF9GUk9NX0xFRlQnKTtcbiAgICAgIH1cblxuICAgIH0sXG4gICAgUHJvZ3Jlc3NCYXJTdHlsZToge1xuICAgICAgZ2V0IFNJTVBMRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdQcm9ncmVzc0JhclN0eWxlLlNJTVBMRScpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBTeXN0ZW1CdXR0b246IHtcbiAgICAgIGdldCBGTEVYSUJMRV9TUEFDRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdTeXN0ZW1CdXR0b24uRkxFWElCTEVfU1BBQ0UnKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBESVNDTE9TVVJFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1N5c3RlbUJ1dHRvbi5ESVNDTE9TVVJFJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFN5c3RlbUJ1dHRvblN0eWxlOiB7XG4gICAgICBnZXQgQkFSKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1N5c3RlbUJ1dHRvblN0eWxlLkJBUicpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBUYWJsZVZpZXdDZWxsU2VsZWN0aW9uU3R5bGU6IHtcbiAgICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld0NlbGxTZWxlY3Rpb25TdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFRhYmxlVmlld1NlcGFyYXRvclN0eWxlOiB7XG4gICAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdUYWJsZVZpZXdTZXBhcmF0b3JTdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFJvd0FuaW1hdGlvblN0eWxlOiB7XG4gICAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdSb3dBbmltYXRpb25TdHlsZS5OT05FJyk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIFRhYmxlVmlld1Njcm9sbFBvc2l0aW9uOiB7XG4gICAgICBnZXQgTUlERExFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld1Njcm9sbFBvc2l0aW9uLk1JRERMRScpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBUYWJsZVZpZXdTdHlsZToge1xuICAgICAgZ2V0IEdST1VQRUQoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnVGFibGVWaWV3U3R5bGUuR1JPVVBFRCcpO1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMC1QcmVzZW50IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWwgT1NfQU5EUk9JRCAqL1xuXG57XG4gIGNvbnN0IExpc3RWaWV3ID0gVGl0YW5pdW0uVUkuTGlzdFZpZXc7XG4gIGNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBoZWlnaHQ6ICc0NWRwJ1xuICAgIH0sXG4gICAgY2hpbGRUZW1wbGF0ZXM6IFt7XG4gICAgICB0eXBlOiAnVGkuVUkuTGFiZWwnLFxuICAgICAgYmluZElkOiAndGl0bGUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBsZWZ0OiAnNmRwJyxcbiAgICAgICAgd2lkdGg6ICc3NSUnXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdHlwZTogJ1RpLlVJLkltYWdlVmlldycsXG4gICAgICBiaW5kSWQ6ICdpbWFnZScsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJpZ2h0OiAnMjVkcCcsXG4gICAgICAgIHdpZHRoOiAnMTUlJ1xuICAgICAgfVxuICAgIH1dXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdFZpZXcob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMudGVtcGxhdGVzID0ge1xuICAgICAgW1RpdGFuaXVtLlVJLkxJU1RfSVRFTV9URU1QTEFURV9ERUZBVUxUXTogZGVmYXVsdFRlbXBsYXRlLFxuICAgICAgLi4ub3B0aW9ucy50ZW1wbGF0ZXNcbiAgICB9O1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IG9wdGlvbnMudGVtcGxhdGVzO1xuXG4gICAgZm9yIChjb25zdCBiaW5kaW5nIGluIHRlbXBsYXRlcykge1xuICAgICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gdGVtcGxhdGVzW2JpbmRpbmddO1xuICAgICAgcHJvY2Vzc1RlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZSk7XG4gICAgICBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMoY3VycmVudFRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExpc3RWaWV3KG9wdGlvbnMpO1xuICB9IC8vIENyZWF0ZSBMaXN0SXRlbVByb3h5LCBhZGQgZXZlbnRzLCB0aGVuIHN0b3JlIGl0IGluICd0aVByb3h5JyBwcm9wZXJ0eVxuXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlKHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjZWxsUHJveHkgPSBUaXRhbml1bS5VSS5jcmVhdGVMaXN0SXRlbSgpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHByb3BlcnRpZXMuZXZlbnRzO1xuICAgIHByb3BlcnRpZXMudGlQcm94eSA9IGNlbGxQcm94eTtcbiAgICBhZGRFdmVudExpc3RlbmVycyhldmVudHMsIGNlbGxQcm94eSk7XG4gIH0gLy8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgcHJvY2VzcyBjaGlsZFRlbXBsYXRlcyBhbmQgYXBwZW5kIGNvcnJlc3BvbmRpbmcgcHJveGllcyB0b1xuICAvLyBwcm9wZXJ0eSAndGlQcm94eScuIEkuZTogdHlwZTogXCJUaXRhbml1bS5VSS5MYWJlbFwiIC0+IHRpUHJveHk6IExhYmVsUHJveHkgb2JqZWN0XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMocHJvcGVydGllcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsICdjaGlsZFRlbXBsYXRlcycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jaGlsZFRlbXBsYXRlcztcblxuICAgIGlmICghY2hpbGRQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRQcm9wZXJ0aWVzW2ldO1xuICAgICAgY29uc3QgcHJveHlUeXBlID0gY2hpbGQudHlwZTtcblxuICAgICAgaWYgKHByb3h5VHlwZSkge1xuICAgICAgICBjb25zdCBjcmVhdGlvblByb3BlcnRpZXMgPSBjaGlsZC5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBjcmVhdGlvbkZ1bmN0aW9uID0gbG9va3VwKHByb3h5VHlwZSk7IC8vIENyZWF0ZSBwcm94eS5cblxuICAgICAgICBsZXQgY2hpbGRQcm94eTtcblxuICAgICAgICBpZiAoY3JlYXRpb25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY2hpbGRQcm94eSA9IGNyZWF0aW9uRnVuY3Rpb24oY3JlYXRpb25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZFByb3h5ID0gY3JlYXRpb25GdW5jdGlvbigpO1xuICAgICAgICB9IC8vIEFkZCBldmVudCBsaXN0ZW5lcnMuXG5cblxuICAgICAgICBjb25zdCBldmVudHMgPSBjaGlsZC5ldmVudHM7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXJzKGV2ZW50cywgY2hpbGRQcm94eSk7IC8vIEFwcGVuZCBwcm94eSB0byB0aVByb3h5IHByb3BlcnR5LlxuXG4gICAgICAgIGNoaWxkLnRpUHJveHkgPSBjaGlsZFByb3h5O1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMoY2hpbGQpO1xuICAgIH1cbiAgfSAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoZXZlbnRzLCBwcm94eSkge1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIHByb3h5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwUHJveHlDb25zdHJ1Y3RvcihuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBuYW1lc3BhY2VJbmRleCA9IG5hbWVzcGFjZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGNvbnN0IHByb3h5TmFtZSA9IG5hbWVzcGFjZS5zbGljZShuYW1lc3BhY2VJbmRleCArIDEpO1xuICAgIGNvbnN0IHBhcmVudE5hbWVzcGFjZSA9IG5hbWVzcGFjZS5zdWJzdHJpbmcoMCwgbmFtZXNwYWNlSW5kZXgpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gcGFyZW50TmFtZXNwYWNlLnNwbGl0KCcuJyk7XG4gICAgbGV0IHBhcmVudFByb3h5ID0gY29tbW9uanNHbG9iYWw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJlbnRQcm94eSA9IHBhcmVudFByb3h5W3NlZ21lbnRzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50UHJveHkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBhcmVudFByb3h5W2BjcmVhdGUke3Byb3h5TmFtZX1gXTtcblxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGxvb2t1cCBjb25zdHJ1Y3RvciBmb3IgbmFtZXNwYWNlOiBcIiR7bmFtZXNwYWNlfVwiYCk7XG4gIH0gLy8gQ29udmVydCBuYW1lIG9mIFVJIGVsZW1lbnRzIGludG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgLy8gaS5lOiBsb29rdXAoXCJUaXRhbml1bS5VSS5MYWJlbFwiKSByZXR1cm5zIFRpdGFuaXVtLlVJLmNyZWF0ZUxhYmVsIGZ1bmN0aW9uLlxuXG5cbiAgZnVuY3Rpb24gbG9va3VwKG5hbWVzcGFjZSkge1xuICAgIC8vIEhhbmRsZSBUaXRhbml1bSB3aWRnZXRzLlxuICAgIGlmICgvXihUaXxUaXRhbml1bSkvLnRlc3QobmFtZXNwYWNlKSkge1xuICAgICAgcmV0dXJuIGxvb2t1cFByb3h5Q29uc3RydWN0b3IobmFtZXNwYWNlKTsgLy8gSGFuZGxlIEFsbG95IHdpZGdldHMuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB3aWRnZXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCBhbGxveSB3aWRnZXQuXG4gICAgICAgIHdpZGdldCA9IGNvbW1vbmpzR2xvYmFsLk1vZHVsZS5tYWluLnJlcXVpcmUoYC9hbGxveS93aWRnZXRzLyR7bmFtZXNwYWNlfS9jb250cm9sbGVycy93aWRnZXRgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaWRnZXQgZG9lcyBub3QgZXhpc3QsIGF0dGVtcHQgdG8gbG9hZCBuYW1lc3BhY2UuXG4gICAgICAgICAgd2lkZ2V0ID0gY29tbW9uanNHbG9iYWwuTW9kdWxlLm1haW4ucmVxdWlyZShuYW1lc3BhY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBOYW1lc3BhY2UgZG9lcyBub3QgZXhpc3QsIGZhbGwgYmFjayB0byBsZWdhY3kgYmVoYXZpb3VyLlxuICAgICAgICAgIHJldHVybiBsb29rdXBQcm94eUNvbnN0cnVjdG9yKG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBjb25zdCBvYmogPSBuZXcgd2lkZ2V0KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIHJldHVybiBvYmouZ2V0VmlldygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBPdmVyd3JpdGUgbGlzdCB2aWV3IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggb3VyIG93bi5cblxuXG4gIFRpdGFuaXVtLlVJLmNyZWF0ZUxpc3RWaWV3ID0gY3JlYXRlTGlzdFZpZXc7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGluIEpTT04gc3RydWN0dXJlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRhbml1bS5VSS5OYXZpZ2F0aW9uV2luZG93LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAncGFyZW50JyB8fCBrID09PSAnd2luZG93JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjcmlwdCBpcyB1c2VkIGF0IHJ1bnRpbWUgZm9yIFRpLlVJLmZldGNoU2VtYW50aWNDb2xvciAtIGFzIHdlbGwgYXMgYXQgYnVpbGQgdGltZSBieSBib3RoIGlPUy9BbmRyb2lkLlxuICogSXQgcHJvdmlkZXMgYSBjb21tb24gaW50ZXJmYWNlIGZvciBoYW5kbGluZyBjb2xvcnMgYW5kIGNvbnZlcnRpbmcgdG8gbmVjZXNzYXJ5IHN0cmluZyBmb3Jtcy5cbiAqL1xuXG5jb25zdCBIRVhfM19SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7IC8vIGkuZS4gIzBGM1xuXG5jb25zdCBIRVhfNF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pOyAvLyBpLmUuICMwRjM4XG5cbmNvbnN0IEhFWF82X1JFR0VYID0gL14jPyhbYS1mXFxkXSl7Nn0kL2k7IC8vIGkuZS4gIzAwRkYzM1xuXG5jb25zdCBIRVhfOF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pezh9JC9pOyAvLyBpLmUuICMwMEZGMzM4OFxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlZ2VyIGluIHJhbmdlIG9mIDAtMjU1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAyLWNoYXJhY3RlciBoZXggc3RyaW5nIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gcGFkZGVkSGV4KGludGVnZXIpIHtcbiAgY29uc3Qgc3RyID0gaW50ZWdlci50b1N0cmluZygxNik7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYDAke3N0cn1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuY2xhc3MgQ29sb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHIgcmVkIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIGdyZWVuIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIGJsdWUgdmFsdWUgaW4gcmFuZ2UgMC0yNTVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthPTEuMF0gYWxwaGEgdmFsdWUgaW4gcmFuZ2UgMC4wLTEuMFxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEuMCkge1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nID0gZztcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYWxwaGEgPSBhO1xuICB9XG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgaWYgdGhpcyBpcyBhIGZ1bGx5IG9wYXF1ZSBjb2xvciAoYWxwaGEgaXMgMS4wIG9yIHdhcyB1bmRlZmluZWQpXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGlzT3BhcXVlKCkge1xuICAgIHJldHVybiB0aGlzLmFscGhhID09PSAxLjA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBhbHBoYSB2YWx1ZSBpbnRvIGVxdWl2YWxlbnQgaGV4IHN0cmluZyB2YWx1ZSBwcm9wZXJseS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBhbHBoYUhleCgpIHtcbiAgICAvLyBuZWVkIHRvIHJvdW5kIHRvIGF2b2lkIG5vbnNlbnNpY2FsIHZhbHVlcyBsaWtlICc3Zi44JyBmb3IgYSAwLjUgYWxwaGFcbiAgICByZXR1cm4gcGFkZGVkSGV4KE1hdGgucm91bmQodGhpcy5hbHBoYSAqIDI1NS4wKSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmRzIGFueSBhbHBoYSB2YWx1ZS4gVG8gYmUgdXNlZCBpbnRlcm5hbGx5LCBub3QgZXh0ZXJuYWwgYXBpLiBEb2VzIG5vdCBwcm92aWRlIGxlYWRpbmcgJyMnIHN5bWJvbC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBfdG9SR0JIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3BhZGRlZEhleCh0aGlzLnIpfSR7cGFkZGVkSGV4KHRoaXMuZyl9JHtwYWRkZWRIZXgodGhpcy5iKX1gO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IENTUy5cbiAgICogQ29udmVydHMgdGhpcyBjb2xvciB0byBhIGhleCBzdHJpbmcgd2l0aCBsZWFkaW5nICcjJyBzeW1ib2wgYW5kIDYtIG9yIDgtXG4gICAqIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKGRlcGVuZGluZyBvbiBpZiBhbHBoYSBpcyAxLjApXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9SR0JBSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX0ke3RoaXMuYWxwaGFIZXgoKX1gO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEFuZHJvaWQvaU9TXG4gICAqIENvbnZlcnRzIHRoaXMgY29sb3IgdG8gYSBoZXggc3RyaW5nIHdpdGggbGVhZGluZyAnIycgc3ltYm9sIGFuZCA2LSBvciA4LVxuICAgKiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzIChkZXBlbmRpbmcgb24gaWYgYWxwaGEgaXMgMS4wKS4gQWxwaGEgaXMgdGhlIGZpcnN0IGVudHJ5IChpZiB0aGVyZSBpcyBhbHBoYS4pXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9BUkdCSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIHJldHVybiBgIyR7dGhpcy5hbHBoYUhleCgpfSR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgY29tbW9uYWxpdHkgd2l0aCBuYXRpdmUgaU9TIFRpQ29sb3IgcHJveHkuIFByb2R1Y2VzIGFuIEFBUlJHR0JCIChvciBSUkdHQkIgaWYgZnVsbCBhbHBoYSkgaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRvSGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRvQVJHQkhleFN0cmluZygpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGFuIHJnYmEgZXhwcmVzc2lvbi4gVGhpcyBleHByZXNzaW9uIGlzIG1vcmUgY29uc2lzdGVudCBhY3Jvc3MgcGxhdGZvcm1zLlxuICAgKiAod2hlcmVhcyBpT1MvQW5kcm9pZCBkaWZmZXIgaW4gZXhwZWN0YXRpb25zIGZvciBoZXggc3RyaW5ncy4pXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgdG9SR0JBU3RyaW5nKCkge1xuICAgIHJldHVybiBgcmdiYSgke3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYWxwaGEudG9GaXhlZCgzKX0pYDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge0NvbG9yfVxuICAgKi9cblxuXG4gIHN0YXRpYyBmYWxsYmFjaygpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDApOyAvLyByZXR1cm4gYmxhY2sgdG8gbWF0Y2ggbmF0aXZlIGltcGwgaW4gaU9TXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMCcgKGkuZS4gbGVhZGluZyBwb3VuZCBzeW1ib2wsIDYgaGV4IGNoYXJhY3RlcnMgYWZ0ZXIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGFdIGFscGhhIHZhbHVlXG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICovXG5cblxuICBzdGF0aWMgZnJvbUhleDZTdHJpbmcoaGV4LCBhbHBoYSkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCwgMiksIDE2KTtcbiAgICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4ICsgMiwgMiksIDE2KTtcbiAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4ICsgNCwgMiksIDE2KTtcbiAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGFscGhhKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN1cHBsaWVkIGhleCBzdHJpbmcgTVVTVCBiZSBpbiBmb3JtICcjMDAwMDAwMDAnIChpLmUuIGxlYWRpbmcgcG91bmQgc3ltYm9sLCA4IGhleCBjaGFyYWN0ZXJzIGFmdGVyKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21IZXg4U3RyaW5nKGhleCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgYWxwaGEgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXgsIDIpLCAxNik7IC8vIGFscGhhIGlzIG5vdyAwLTI1NVxuXG4gICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDIsIDIpLCAxNik7XG4gICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDQsIDIpLCAxNik7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDYsIDIpLCAxNik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhbHBoYSAvIDI1NS4wKTsgLy8gY29udmVydCB0byAwLjAtMS4wIChwZXJjZW50KVxuICB9XG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhlIGhleCB2YWx1ZSBjYW4gY29udGFpbiBhbHBoYSwgYnV0IG11c3QgZm9sbG93IHRoZSBDU1Mgc3RhbmRhcmQgb2YgI1JSR0dCQkFBIChOT1QgdGhlIEFuZHJvaWQgc3RhbmRhcmQgb2YgI0FBUlJHR0JCKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVudHJ5IHBvc3NpYmxlIGhleCBzdHJpbmcgb3IgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2hleC5hbHBoYV0gYWxwaGEgdmFsdWUgaW4gcGVyY2VudCAoMC4wLTEwMC4wKSB3aGVuIGhleCBpcyBhbiBvYmplY3RcbiAgXHQgKiBAcGFyYW0ge3N0cmluZ30gW2hleC5jb2xvcl0gaGV4IHN0cmluZyBmb3IgdGhlIGJhc2UgY29sb3Igd2hlbiBoZXggaXMgYW4gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICogQHRocm93cyBpZiBlbnRyeSBoYXMgYm90aCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYW4gYWxwaGEgdmFsdWVcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbVNlbWFudGljQ29sb3JzRW50cnkoZW50cnkpIHtcbiAgICBsZXQgY29sb3IgPSBlbnRyeTtcbiAgICBsZXQgYWxwaGEgPSAxLjA7XG4gICAgbGV0IGhhZEFscGhhID0gZmFsc2U7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAnYWxwaGEnKSkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGVudHJ5LmFscGhhKSAvIDEwMC4wOyAvLyBjb252ZXJ0IGZyb20gMC0xMDAgcmFuZ2UgdG8gMC0xIHJhbmdlXG5cbiAgICAgIGhhZEFscGhhID0gdHJ1ZTtcbiAgICAgIGNvbG9yID0gZW50cnkuY29sb3I7IC8vIGlmIGl0IGhhcyBhbiBhbHBoYSBwcm9wZXJ0eSBhc3N1bWUgaXQgaGFzIGEgY29sb3IgcHJvcGVydHkgdG9vIVxuICAgIH0gLy8gZXhwYW5kIHRoZSBzaG9ydGVyIGhleCBzdHJpbmcgZm9ybXMgdG8gNiBvciA4IGRpZ2l0c1xuXG5cbiAgICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0ZcIikgdG8gZnVsbCBmb3JtIChlLmcuIFwiMDAzM0ZGXCIpXG4gICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoSEVYXzNfUkVHRVgsIChtLCByLCBnLCBiKSA9PiByICsgciArIGcgKyBnICsgYiArIGIpO1xuICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAvLyBFeHBhbmQgc2hvcnRoYW5kIGZvcm0gKGUuZy4gXCIwM0Y4XCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRjg4XCIpXG4gICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoSEVYXzRfUkVHRVgsIChtLCBhLCByLCBnLCBiKSA9PiBhICsgYSArIHIgKyByICsgZyArIGcgKyBiICsgYik7XG4gICAgfVxuXG4gICAgaWYgKEhFWF82X1JFR0VYLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gQ29sb3IuZnJvbUhleDZTdHJpbmcoY29sb3IsIGFscGhhKTtcbiAgICB9XG5cbiAgICBpZiAoSEVYXzhfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIGlmIChoYWRBbHBoYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbG9yICR7ZW50cnl9IGhhZCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggdmFsdWUgY29udGFpbmluZyBhbHBoYS4gVXNlIG9uZSBvciB0aGUgb3RoZXIuYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4OFN0cmluZyhjb2xvcik7XG4gICAgfSAvLyB1aC1vaCwgc29tZXRoaW5nIGlzIHVwIVxuXG5cbiAgICByZXR1cm4gQ29sb3IuZmFsbGJhY2soKTtcbiAgfVxuXG59XG5cbnZhciBjb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOS0yMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vLyBUaS5VSSB3aXRoaW4gdGhpcyBmaWxlLCB3ZSBtdXN0IGNhbGwga3JvbGwuYmluZGluZyB0byBnZXQgdGhlIFRpdGFuaXVtXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBwYXNzZWQgaW4gd2l0aCByZXF1aXJlIGFuZCB0aGF0IGRlYWwgd2l0aCB0aGUgLlVJXG4vLyBuYW1lc3BhY2UgdGhhdCBpcyBvbiB0aGF0IGRpcmVjdGx5LlxuXG5jb25zdCBVSSA9IGtyb2xsLmJpbmRpbmcoJ1RpdGFuaXVtJykuVGl0YW5pdW0uVUkgOyAvLyBNYWtlIG91ciByZWFkLW9ubHkgY29uc3RhbnRzXG4vLyBUT0RPOiBSZW1vdmUgaW4gU0RLIDEwLCBERVBSRUNBVEVEIGluIDkuMS4wXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ1NFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQnLCB7XG4gIHZhbHVlOiAnbGlnaHQnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnU0VNQU5USUNfQ09MT1JfVFlQRV9EQVJLJywge1xuICB2YWx1ZTogJ2RhcmsnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnc2VtYW50aWNDb2xvclR5cGUnLCB7XG4gIGdldDogKCkgPT4ge1xuICAgIC8vIFRPRE86IEd1YXJkIGFnYWluc3QgaW9zIDwgMTMgYW5kIEFuZHJvaWQgYXBpIDwgMjk/XG4gICAgLy8gQXNzdW1lIFwibGlnaHRcIiBtb2RlIHVubGVzcyB3ZSBleHBsaWNpdGx5IGtub3cgaXQncyBkYXJrXG4gICAgaWYgKFRpLlVJLnVzZXJJbnRlcmZhY2VTdHlsZSA9PT0gVGkuVUkuVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSykge1xuICAgICAgcmV0dXJuIFVJLlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSztcbiAgICB9XG5cbiAgICByZXR1cm4gVUkuU0VNQU5USUNfQ09MT1JfVFlQRV9MSUdIVDtcbiAgfVxufSk7IC8vIG9uIEFuZHJvaWQvaU9TIDwgMTMsIHdlIG5lZWQgdG8gcm9sbCBvdXIgb3duIGZldGNoU2VtYW50aWNDb2xvciBpbXBsXG4vLyBvbiBpT1MgMTMrLCB3ZSBoYXZlIGEgbmF0aXZlIHZlcnNpb25cblxue1xuXG4gIGxldCBjb2xvcnNldDtcblxuICBVSS5mZXRjaFNlbWFudGljQ29sb3IgPSBmdW5jdGlvbiBmZXRjaFNlbWFudGljQ29sb3IoY29sb3JOYW1lKSB7XG4gICAgLy8gTG9hZCBhbGwgc2VtYW50aWMgY29sb3JzIGZyb20gSlNPTiBpZiBub3QgZG9uZSBhbHJlYWR5LlxuICAgIC8vIERvIHNvIHZpYSByZXF1aXJlKCkgaW4gY2FzZSB0aGlzIGZpbGUgd2FzIGNoYW5nZWQgd2hpbGUgcnVubmluZyBMaXZlVmlldy5cbiAgICBpZiAoIWNvbG9yc2V0KSB7XG4gICAgICBjb25zdCBjb2xvcnNldEZpbGVOYW1lID0gJ3NlbWFudGljLmNvbG9ycy5qc29uJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29sb3JzZXRGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBjb2xvcnNldEZpbGVOYW1lKTtcblxuICAgICAgICBpZiAoY29sb3JzZXRGaWxlLmV4aXN0cygpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgICAgY29sb3JzZXQgPSByZXF1aXJlKGAvJHtjb2xvcnNldEZpbGVOYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBjb2xvcnMgZmlsZSAnJHtjb2xvcnNldEZpbGVOYW1lfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gT24gQW5kcm9pZCwgdXNlIGN1c3RvbSBzdHJpbmcgcmVmZXJlbmNlcyB0byBiZSBoYW5kbGVkIGJ5IFwiVGlDb2xvckhlbHBlci5qYXZhXCIuXG4gICAgICAgIGlmIChjb2xvcnNldFtjb2xvck5hbWVdKSB7XG4gICAgICAgICAgLy8gQWRkIGFsbCB0aGVtZSBjb2xvcnMgdG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAgICAgIC8vIEV4YW1wbGU6IFwidGkuc2VtYW50aWMuY29sb3I6ZGFyaz08Q29sb3JTdHJpbmc+O2xpZ2h0PTxDb2xvclN0cmluZz5cIlxuICAgICAgICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBbXTtcblxuICAgICAgICAgIGZvciAoY29uc3QgY29sb3JUeXBlIGluIGNvbG9yc2V0W2NvbG9yTmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yT2JqID0gY29sb3IuZnJvbVNlbWFudGljQ29sb3JzRW50cnkoY29sb3JzZXRbY29sb3JOYW1lXVtjb2xvclR5cGVdKTtcbiAgICAgICAgICAgIGNvbG9yQXJyYXkucHVzaChgJHtjb2xvclR5cGV9PSR7Y29sb3JPYmoudG9SR0JBU3RyaW5nKCl9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICd0aS5zZW1hbnRpYy5jb2xvcjonICsgY29sb3JBcnJheS5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoVGkuQW5kcm9pZC5SLmNvbG9yW2NvbG9yTmFtZV0pIHtcbiAgICAgICAgICAvLyBXZSdyZSByZWZlcmVuY2luZyBhIG5hdGl2ZSBcInJlc1wiIGNvbG9yIGVudHJ5LlxuICAgICAgICAgIHJldHVybiBgQGNvbG9yLyR7Y29sb3JOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvb2t1cCBjb2xvciBmb3IgJHtjb2xvck5hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtUHJlc2VudCBieSBBcHBjZWxlcmF0b3IsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cbntcbiAgY29uc3QgVGFiID0gVGl0YW5pdW0uVUkuVGFiO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhYihvcHRpb25zKSB7XG4gICAgY29uc3QgdGFiID0gbmV3IFRhYihvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0YWIuX3dpbmRvdyA9IG9wdGlvbnMud2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiB0YWI7XG4gIH1cblxuICBUaXRhbml1bS5VSS5jcmVhdGVUYWIgPSBjcmVhdGVUYWI7XG5cbiAgVGFiLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHdpbmRvdywgb3B0aW9ucykge1xuICAgIGlmICghd2luZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfSAvLyBXaGVuIHdlIG9wZW4gYSB3aW5kb3cgdXNpbmcgdGFiLm9wZW4od2luKSwgd2UgdHJlYXQgaXQgYXNcbiAgICAvLyBvcGVuaW5nIGEgSFcgd2luZG93IG9uIHRvcCBvZiB0aGUgdGFiLlxuXG5cbiAgICBvcHRpb25zLnRhYk9wZW4gPSB0cnVlO1xuICAgIHdpbmRvdy5vcGVuKG9wdGlvbnMpO1xuICB9O1xuXG4gIFRhYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuZ2V0V2luZG93KCk7XG5cbiAgICBpZiAod2luZG93KSB7XG4gICAgICB3aW5kb3cuY2xvc2Uob3B0aW9ucyk7XG4gICAgICB0aGlzLnNldFdpbmRvdyhudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgX3NldFdpbmRvdyA9IFRhYi5wcm90b3R5cGUuc2V0V2luZG93O1xuXG4gIFRhYi5wcm90b3R5cGUuc2V0V2luZG93ID0gZnVuY3Rpb24gKHdpbmRvdykge1xuICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvdztcblxuICAgIF9zZXRXaW5kb3cuY2FsbCh0aGlzLCB3aW5kb3cpO1xuICB9OyAvLyBUT0RPOiBSZW1vdmUhIFRoaXMgaXMgYW4gdW5kb2N1bWVudGVkIGFjY2Vzc29yIG1ldGhvZFxuXG5cbiAgVGFiLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvdztcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiLnByb3RvdHlwZSwgJ3dpbmRvdycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHNldDogVGFiLnByb3RvdHlwZS5zZXRXaW5kb3csXG4gICAgZ2V0OiBUYWIucHJvdG90eXBlLmdldFdpbmRvd1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIGNvbnN0IFRhYkdyb3VwID0gVGl0YW5pdW0uVUkuVGFiR3JvdXA7IC8vIEF2b2lkIGNpcmN1bGFyIGxvb3BzIGluIHRvSlNPTigpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYkdyb3VwLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAnYWN0aXZpdHknIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmlhbGl6ZWRba10gPSB0aGlzW2tdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0YW5pdW0uVUkuVGFiLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAnd2luZG93JyB8fCBrID09PSAndGFiR3JvdXAnIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmlhbGl6ZWRba10gPSB0aGlzW2tdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxNS1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cbntcbiAgY29uc3QgVmlldyA9IFRpdGFuaXVtLlVJLlZpZXc7XG4gIGNvbnN0IF9hZGQgPSBWaWV3LnByb3RvdHlwZS5hZGQ7XG5cbiAgVmlldy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGl0YW5pdW0uVGlXaW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCB3aW5kb3cvdGFiR3JvdXAgdG8gYSB2aWV3LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4gfHwgW107XG5cbiAgICBfYWRkLmNhbGwodGhpcywgY2hpbGQpOyAvLyBUaGUgY2hpbGRyZW4gaGF2ZSB0byBiZSByZXRhaW5lZCBieSB0aGUgdmlldyBpbiB0aGUgSmF2YXNjcmlwdCBzaWRlXG4gICAgLy8gaW4gb3JkZXIgdG8gbGV0IFY4IGtub3cgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGNoaWxkcmVuIGFuZCB0aGUgdmlldy5cbiAgICAvLyBUaGVyZWZvcmUsIGFzIGxvbmcgYXMgaXRzIHdpbmRvdyBpcyBvcGVuLCBhbGwgaXRzIGNoaWxkcmVuIHdvbid0IGJlIGRldGFjaGVkXG4gICAgLy8gb3IgZ2FyYmFnZSBjb2xsZWN0ZWQgYW5kIFY4IHdpbGwgcmVjb2dhbml6ZSB0aGUgY2xvc3VyZXMgYW5kIHJldGFpbiBhbGxcbiAgICAvLyB0aGUgcmVsYXRlZCBwcm94aWVzLlxuXG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcblxuICBjb25zdCBfcmVtb3ZlID0gVmlldy5wcm90b3R5cGUucmVtb3ZlO1xuXG4gIFZpZXcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIF9yZW1vdmUuY2FsbCh0aGlzLCBjaGlsZCk7IC8vIFJlbW92ZSB0aGUgY2hpbGQgaW4gdGhlIEphdmFzY3JpcHQgc2lkZSBzbyBpdCBjYW4gYmUgZGV0YWNoZWQgYW5kIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuIHx8IFtdO1xuICAgIGNvbnN0IGNoaWxkSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgIGlmIChjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgIH1cbiAgfTsgLy8gRG8gbm90IHNlcmlhbGl6ZSB0aGUgcGFyZW50IHZpZXcuIERvaW5nIHNvIHdpbGwgcmVzdWx0XG4gIC8vIGluIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGxvb3AuXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0YW5pdW0uVGlWaWV3LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrID09PSAncGFyZW50JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIGNvbnN0IGNyZWF0ZVdlYlZpZXcgPSBUaXRhbml1bS5VSS5jcmVhdGVXZWJWaWV3O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdlYlZpZXdXcmFwcGVyKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3ZWJWaWV3ID0gY3JlYXRlV2ViVmlldy5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHdlYlZpZXcub25DcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFlLmlzVXNlckdlc3R1cmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdpbiA9IFRpdGFuaXVtLlVJLmNyZWF0ZVdpbmRvdyh7fSwge1xuICAgICAgICBmdWxsc2NyZWVuOiBmYWxzZSAvLyBGb3JjZSBuZXcgYWN0aXZpdHkuXG5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV3V2ViVmlldyA9IFRpdGFuaXVtLlVJLmNyZWF0ZVdlYlZpZXcoKTtcbiAgICAgIHdpbi5hZGQobmV3V2ViVmlldyk7XG4gICAgICB3aW4ub3BlbigpO1xuICAgICAgcmV0dXJuIG5ld1dlYlZpZXc7XG4gICAgfTtcblxuICAgIHJldHVybiB3ZWJWaWV3O1xuICB9XG5cbiAgVGl0YW5pdW0uVUkuY3JlYXRlV2ViVmlldyA9IGNyZWF0ZVdlYlZpZXdXcmFwcGVyO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxMS1QcmVzZW50IGJ5IEFwcGNlbGVyYXRvciwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG57XG4gIGNvbnN0IFRBRyA9ICdXaW5kb3cnO1xuICBjb25zdCBTY3JpcHQgPSBrcm9sbC5iaW5kaW5nKCdldmFscycpLlNjcmlwdDsgLy8gQW5kcm9pZC1zcGVjaWZpYyB3YXkgdG8gZ3JhYiBiaW5kaW5nLCBoYW5ncyBvZmYgJ3NjcmlwdCcgb24gaU9TXG5cbiAgY29uc3QgV2luZG93ID0gVGl0YW5pdW0uVUkuV2luZG93O1xuICBXaW5kb3cucHJvdG90eXBlLl9jYWNoZWRBY3Rpdml0eVByb3h5ID0gbnVsbDtcblxuICBmdW5jdGlvbiBjcmVhdGVXaW5kb3cob3B0aW9ucykge1xuICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBXaW5kb3cob3B0aW9ucyk7XG4gICAgd2luZG93Ll9jaGlsZHJlbiA9IFtdO1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBUaXRhbml1bS5VSS5jcmVhdGVXaW5kb3cgPSBjcmVhdGVXaW5kb3c7IC8vIEFjdGl2aXR5IGdldHRlciAoYWNjb3VudCBmb3Igc2NlbmFyaW8gd2hlbiBoZWF2eSB3ZWlnaHQgd2luZG93J3MgYWN0aXZpdHkgaXMgbm90IGNyZWF0ZWQgeWV0KVxuXG4gIGZ1bmN0aW9uIGFjdGl2aXR5UHJveHlHZXR0ZXIoKSB7XG4gICAgY29uc3QgYWN0aXZpdHlQcm94eSA9IHRoaXMuX2dldFdpbmRvd0FjdGl2aXR5UHJveHkoKTtcblxuICAgIGlmIChhY3Rpdml0eVByb3h5KSB7XG4gICAgICByZXR1cm4gYWN0aXZpdHlQcm94eTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FjaGVkQWN0aXZpdHlQcm94eSA9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB0aGlzLl9jYWNoZWRBY3Rpdml0eVByb3h5ID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHk7XG4gIH1cblxuICBXaW5kb3cucHJvdG90eXBlLmdldEFjdGl2aXR5ID0gYWN0aXZpdHlQcm94eUdldHRlcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpbmRvdy5wcm90b3R5cGUsICdhY3Rpdml0eScsIHtcbiAgICBnZXQ6IGFjdGl2aXR5UHJveHlHZXR0ZXJcbiAgfSk7XG4gIGNvbnN0IF9vcGVuID0gV2luZG93LnByb3RvdHlwZS5vcGVuO1xuXG4gIFdpbmRvdy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gUmV0YWluIHRoZSB3aW5kb3cgdW50aWwgaXQgaGFzIGNsb3NlZC5cbiAgICBjb25zdCBoYW5kbGUgPSBuZXcgUGVyc2lzdGVudEhhbmRsZSh0aGlzKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLl9jbG9zZUZyb21BY3Rpdml0eUZvcmNlZFRvRGVzdHJveSkge1xuICAgICAgICBpZiAoa3JvbGwuREJHKSB7XG4gICAgICAgICAga3JvbGwubG9nKFRBRywgJ1dpbmRvdyBpcyBjbG9zZWQgYmVjYXVzZSB0aGUgYWN0aXZpdHkgaXMgZm9yY2VkIHRvIGRlc3Ryb3kgYnkgQW5kcm9pZCBPUy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGlzcG9zZSB0aGUgVVJMIGNvbnRleHQgaWYgdGhlIHdpbmRvdydzIGFjdGl2aXR5IGlzIGRlc3Ryb3llZC5cblxuXG4gICAgICBpZiAoc2VsZi5fdXJsQ29udGV4dCkge1xuICAgICAgICBTY3JpcHQuZGlzcG9zZUNvbnRleHQoc2VsZi5fdXJsQ29udGV4dCk7XG4gICAgICAgIHNlbGYuX3VybENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGUuZGlzcG9zZSgpO1xuXG4gICAgICBpZiAoa3JvbGwuREJHKSB7XG4gICAgICAgIGtyb2xsLmxvZyhUQUcsICdXaW5kb3cgaXMgY2xvc2VkIG5vcm1hbGx5LicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfb3Blbi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IF9hZGQgPSBXaW5kb3cucHJvdG90eXBlLmFkZDtcblxuICBXaW5kb3cucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpdGFuaXVtLlRpV2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgd2luZG93L3RhYkdyb3VwIHRvIGFub3RoZXIgd2luZG93L3RhYkdyb3VwLicpO1xuICAgIH1cblxuICAgIF9hZGQuY2FsbCh0aGlzLCBjaGlsZCk7IC8vIFRoZSBjaGlsZHJlbiBoYXZlIHRvIGJlIHJldGFpbmVkIGJ5IHRoZSB3aW5kb3cgaW4gdGhlIEphdmFzY3JpcHQgc2lkZVxuICAgIC8vIGluIG9yZGVyIHRvIGxldCBWOCBrbm93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBjaGlsZHJlbiBhbmQgdGhlIHdpbmRvdy5cbiAgICAvLyBUaGVyZWZvcmUsIGFzIGxvbmcgYXMgdGhlIHdpbmRvdyBpcyBvcGVuLCBhbGwgaXRzIGNoaWxkcmVuIHdvbid0IGJlIGRldGFjaGVkXG4gICAgLy8gb3IgZ2FyYmFnZSBjb2xsZWN0ZWQgYW5kIFY4IHdpbGwgcmVjb2dhbml6ZSB0aGUgY2xvc3VyZXMgYW5kIHJldGFpbiBhbGxcbiAgICAvLyB0aGUgcmVsYXRlZCBwcm94aWVzLlxuXG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcblxuICBjb25zdCBfcmVtb3ZlID0gV2luZG93LnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgV2luZG93LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBfcmVtb3ZlLmNhbGwodGhpcywgY2hpbGQpOyAvLyBSZW1vdmUgdGhlIGNoaWxkIGluIHRoZSBKYXZhc2NyaXB0IHNpZGUgc28gaXQgY2FuIGJlIGRldGFjaGVkIGFuZCBnYXJiYWdlIGNvbGxlY3RlZC5cblxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBXaW5kb3cucHJvdG90eXBlLnBvc3RXaW5kb3dDcmVhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgIGtyb2xsLmxvZyhUQUcsICdDaGVja3BvaW50OiBwb3N0V2luZG93Q3JlYXRlZCgpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHkpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsQWN0aXZpdHkuZXh0ZW5kKHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciB0aGUgRXZlbnRFbWl0dGVyIGluc3RhbmNlIHRvIHVzZSB0byByZWdpc3RlciBmb3IgaXQncyBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIGZvclxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGNhbGxiYWNrL2Z1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByZXBlbmQgd2hldGhlciB0byBwcmVwZW5kIG9yIGFwcGVuZCB0aGUgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9OyAvLyBpbml0aWFsaXplIGl0XG4gIH0gLy8gaWYgdGhlcmUncyBzb21lb25lIGxpc3RlbmluZyB0byAnbmV3TGlzdGVuZXInIGV2ZW50cywgZW1pdCB0aGF0ICoqYmVmb3JlKiogd2UgYWRkIHRoZSBsaXN0ZW5lciAodG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uKVxuXG5cbiAgaWYgKGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzLm5ld0xpc3RlbmVyKSB7XG4gICAgZW1pdHRlci5lbWl0KCduZXdMaXN0ZW5lcicsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuXG4gIGlmIChwcmVwZW5kKSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnM7IC8vIENoZWNrIG1heCBsaXN0ZW5lcnMgYW5kIHNwaXQgb3V0IHdhcm5pbmcgaWYgPlxuXG4gIGNvbnN0IG1heCA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcblxuICBpZiAobWF4ID4gMCAmJiBsZW5ndGggPiBtYXgpIHtcbiAgICBjb25zdCB3ID0gbmV3IEVycm9yKGBQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICR7bGVuZ3RofSAke2V2ZW50TmFtZX0gbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdGApO1xuICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgIHcuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdy50eXBlID0gZXZlbnROYW1lO1xuICAgIHcuY291bnQgPSBsZW5ndGg7XG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyh3KTtcbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG5mdW5jdGlvbiBvbmNlV3JhcChlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy53cmFwcGVkRnVuYyk7IC8vIHJlbW92ZSBvdXJzZWx2ZXNcblxuICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy5lbWl0dGVyLCBhcmdzKTsgLy8gdGhlbiBmb3J3YXJkIHRoZSBldmVudCBjYWxsYmFja1xuICB9IC8vIHdlIGhhdmUgdG8gdXNlIGJpbmQgd2l0aCBhIGN1c3RvbSAndGhpcycsIGJlY2F1c2UgZXZlbnRzIGZpcmUgd2l0aCAndGhpcycgcG9pbnRpbmcgYXQgdGhlIGVtaXR0ZXJcblxuXG4gIGNvbnN0IHdyYXBwZXJUaGlzID0ge1xuICAgIGVtaXR0ZXIsXG4gICAgZXZlbnROYW1lLFxuICAgIGxpc3RlbmVyXG4gIH07XG4gIGNvbnN0IGJvdW5kID0gd3JhcHBlci5iaW5kKHdyYXBwZXJUaGlzKTsgLy8gYmluZCB0byBmb3JjZSBcInRoaXNcIiB0byByZWZlciB0byBvdXIgY3VzdG9tIG9iamVjdCB0cmFja2luZyB0aGUgd3JhcHBlci9lbWl0dGVyL2xpc3RlbmVyXG5cbiAgYm91bmQubGlzdGVuZXIgPSBsaXN0ZW5lcjsgLy8gaGF2ZSB0byBhZGQgbGlzdGVuZXIgcHJvcGVydHkgZm9yIFwidW53cmFwcGluZ1wiXG5cbiAgd3JhcHBlclRoaXMud3JhcHBlZEZ1bmMgPSBib3VuZDtcbiAgcmV0dXJuIGJvdW5kO1xufSAvLyBtYW55IGNvbnN1bWVycyBtYWtlIHVzZSBvZiB0aGlzIHZpYSB1dGlsLmluaGVyaXRzLCB3aGljaCBkb2VzIG5vdCBjaGFpbiBjb25zdHJ1Y3RvciBjYWxscyFcbi8vIHNvIHdlIG5lZWQgdG8gYmUgYXdhcmUgdGhhdCBfZXZlbnRzVG9MaXN0ZW5lcnMgbWF5ZSBiZSBudWxsL3VuZGVmaW5lZCBvbiBpbnN0YW5jZXMsIGFuZCBjaGVjayBpbiBtZXRob2RzIGJlZm9yZSBhY2Nlc3NpbmcgaXRcblxuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuXG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgfVxuXG4gIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICBsZXQgdW53cmFwcGVkTGlzdGVuZXI7IC8vIE5lZWQgdG8gc2VhcmNoIExJRk8sIGFuZCBuZWVkIHRvIGhhbmRsZSB3cmFwcGVkIGZ1bmN0aW9ucyAob25jZSB3cmFwcGVycylcblxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIHVud3JhcHBlZExpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcnNbaV0ubGlzdGVuZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBsZW5ndGggd2FzIDEgYW5kIHdlIHdhbnQgdG8gcmVtb3ZlIGxhc3QgZW50cnksIHNvIGRlbGV0ZSB0aGUgZXZlbnQgdHlwZSBmcm9tIG91ciBsaXN0ZW5lciBtYXBwaW5nIG5vdyFcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBoYWQgMisgbGlzdGVuZXJzLCBzbyBzdG9yZSBhcnJheSB3aXRob3V0IHRoaXMgZ2l2ZW4gbGlzdGVuZXJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpOyAvLyBtb2RpZmllcyBpbiBwbGFjZSwgbm8gbmVlZCB0byBhc3NpZ24gdG8gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxuICAgICAgfSAvLyBEb24ndCBlbWl0IGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzIGZvciAncmVtb3ZlTGlzdGVuZXInIHR5cGUhXG5cblxuICAgICAgaWYgKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCBldmVudE5hbWUsIHVud3JhcHBlZExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcblxuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgZXZlbnRMaXN0ZW5lcnMuc2xpY2UoKSkge1xuICAgICAgLy8gbXVzdCBvcGVyYXRlIG9uIGNvcHkgYmVjYXVzZSBsaXN0ZW5lcnMgLGF5IGdldCByZW1vdmUgYXMgc2lkZS1lZmZlY3Qgb2YgY2FsbGluZ1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuICB9XG5cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgfHwge30pO1xuICB9XG5cbiAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gLy8gTmVlZCB0byBcInVud3JhcFwiIG9uY2Ugd3JhcHBlcnMhXG5cblxuICAgIGNvbnN0IHJhdyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgcmV0dXJuIHJhdy5tYXAobCA9PiBsLmxpc3RlbmVyIHx8IGwpOyAvLyBoZXJlIHdlIHVud3JhcCB0aGUgb25jZSB3cmFwcGVyIGlmIHRoZXJlIGlzIG9uZSBvciBmYWxsIGJhY2sgdG8gbGlzdGVuZXIgZnVuY3Rpb25cbiAgfVxuXG4gIHJhd0xpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW10pLnNsaWNlKDApOyAvLyByZXR1cm4gYSBjb3B5XG4gIH1cblxuICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycyB8fCBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjsgLy8gVE9ETzogVHlwZSBjaGVjayBuLCBtYWtlIHN1cmUgPj0gMCAobyBlcXVhbHMgbm8gbGltaXQpXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGVtaXQhIHdlIGNhbiBqdXN0IHdpcGUhXG4gICAgICBpZiAoZXZlbnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZXJ5IHR5cGUhXG4gICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgdHlwZVxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyB5dWNrLCB3ZSdsbCBoYXZlIHRvIGVtaXQgJ3JlbW92ZUxpc3RlbmVyJyBldmVudHMgYXMgd2UgZ29cblxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW1vdmUgYWxsIHR5cGVzIChidXQgZG8gJ3JlbW92ZUxpc3RlbmVyJyBsYXN0ISlcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpLmZpbHRlcihuYW1lID0+IG5hbWUgIT09ICdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVycyBmb3Igb25lIHR5cGUsIGJhY2sgdG8gZnJvbnQgKExhc3QtaW4sIGZpcnN0LW91dCwgZXhjZXB0IHdoZXJlIHByZXBlbmQgZi1lZCBpdCB1cClcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgZXZlbnROYW1lKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcbn07XG5cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQHBhcmFtICB7Kn0gYXJnIHBhc3NlZCBpbiBhcmd1bWVudCB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVuYW1lIGkuZS4gJ3N0cmluZycsICdGdW5jdGlvbicgKHZhbHVlIGlzIGNvbXBhcmVkIHRvIHR5cGVvZiBhZnRlciBsb3dlcmNhc2luZylcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50VHlwZShhcmcsIG5hbWUsIHR5cGVuYW1lKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuXG4gIGlmICh0eXBlICE9PSB0eXBlbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSAke3R5cGVuYW1lfS4gUmVjZWl2ZWQgdHlwZSAke3R5cGV9YCk7XG4gIH1cbn1cblxuY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiAnc3RhbmRhcmRpemVzJyB0aGUgcmVwb3J0ZWQgYXJjaGl0ZWN0dXJlcyB0byB0aGUgZXF1aXZhbGVudHMgcmVwb3J0ZWQgYnkgTm9kZS5qc1xuICogbm9kZSB2YWx1ZXM6ICdhcm0nLCAnYXJtNjQnLCAnaWEzMicsICdtaXBzJywgJ21pcHNlbCcsICdwcGMnLCAncHBjNjQnLCAnczM5MCcsICdzMzkweCcsICd4MzInLCBhbmQgJ3g2NCcuXG4gKiBpT1MgdmFsdWVzOiBcImFybTY0XCIsIFwiYXJtdjdcIiwgXCJ4ODZfNjRcIiwgXCJpMzg2XCIsIFwiVW5rbm93blwiXG4gKiBBbmRyb2lkIHZhbHVlczogXCJhcm1lYWJpXCIsIFwiYXJtZWFiaS12N2FcIiwgXCJhcm02NC12OGFcIiwgXCJ4ODZcIiwgXCJ4ODZfNjRcIiwgXCJtaXBzXCIsIFwibWlwczY0XCIsIFwidW5rbm93blwiXG4gKiBXaW5kb3dzIHZhbHVlczogXCJ4NjRcIiwgXCJpYTY0XCIsIFwiQVJNXCIsIFwieDg2XCIsIFwidW5rbm93blwiXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWwgb3JpZ2luYWwgYXJjaGl0ZWN0dXJlIHJlcG9ydGVkIGJ5IFRpLlBsYXRmb3JtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQXJjaChvcmlnaW5hbCkge1xuICBzd2l0Y2ggKG9yaWdpbmFsKSB7XG4gICAgLy8gY29lcmNlICdhcm12NycsICdhcm1lYWJpJywgJ2FybWVhYmktdjdhJywgJ0FSTScgLT4gJ2FybSdcbiAgICAvLyAnYXJtZWFiaScgaXMgYSBkZWFkIEFCSSBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG4gICAgY2FzZSAnYXJtdjcnOlxuICAgIGNhc2UgJ2FybWVhYmknOlxuICAgIGNhc2UgJ2FybWVhYmktdjdhJzpcbiAgICBjYXNlICdBUk0nOlxuICAgICAgcmV0dXJuICdhcm0nO1xuICAgIC8vIGNvZXJjZSAnYXJtNjQtdjhhJyAtPiAnYXJtNjQnXG5cbiAgICBjYXNlICdhcm02NC12OGEnOlxuICAgICAgcmV0dXJuICdhcm02NCc7XG4gICAgLy8gY29lcmNlICdpMzg2JywgJ3g4NicgLT4gJ2lhMzInXG5cbiAgICBjYXNlICdpMzg2JzpcbiAgICBjYXNlICd4ODYnOlxuICAgICAgcmV0dXJuICdpYTMyJztcbiAgICAvLyBjb2VyY2UgJ3g4Nl82NCcsICdpYTY0JywgJ3g2NCcgLT4gJ3g2NCdcblxuICAgIGNhc2UgJ3g4Nl82NCc6XG4gICAgY2FzZSAnaWE2NCc6XG4gICAgICByZXR1cm4gJ3g2NCc7XG4gICAgLy8gY29lcmNlICdtaXBzNjQnIC0+ICdtaXBzJyAvLyAnbWlwcycgYW5kICdtaXBzNjQnIGFyZSBkZWFkIEFCSXMgZm9yIEFuZHJvaWQsIHJlbW92ZWQgaW4gTkRLIHIxN1xuXG4gICAgY2FzZSAnbWlwczY0JzpcbiAgICAgIHJldHVybiAnbWlwcyc7XG4gICAgLy8gY29lcmNlICdVbmtub3duJyAtPiAndW5rbm93bidcblxuICAgIGNhc2UgJ1Vua25vd24nOlxuICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbn1cblxuY29uc3QgcHJvY2VzcyQxID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5wcm9jZXNzJDEuYWJvcnQgPSAoKSA9PiB7fTsgLy8gVE9ETzogRG8gd2UgaGF2ZSBlcXVpdmFsZW50IG9mIGZvcmNpYmx5IGtpbGxpbmcgdGhlIHByb2Nlc3M/IFdlIGhhdmUgcmVzdGFydCwgYnV0IEkgdGhpbmsgd2UganVzdCB3YW50IGEgbm8tb3Agc3R1YiBoZXJlXG5cblxucHJvY2VzcyQxLmFyY2ggPSBzdGFuZGFyZGl6ZUFyY2goVGkuUGxhdGZvcm0uYXJjaGl0ZWN0dXJlKTtcbnByb2Nlc3MkMS5hcmd2ID0gW107IC8vIFRPRE86IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gcGF0aCB0byB0aXRhbml1bSBjbGkgZm9yIGZpcnN0IGFyZz8gcGF0aCB0byB0aS5tYWluL2FwcC5qcyBmb3Igc2Vjb25kP1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnYXJndjAnLCB7XG4gIHZhbHVlOiAnJyxcbiAgLy8gVE9ETzogUGF0aCB0byAuYXBwIG9uIGlPUz9cbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxucHJvY2VzcyQxLmJpbmRpbmcgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIHVuc3VwcG9ydGVkIGFuZCBub3QgdXNlci1mYWNpbmcgQVBJJyk7XG59O1xuXG5wcm9jZXNzJDEuY2hhbm5lbCA9IHVuZGVmaW5lZDtcblxucHJvY2VzcyQxLmNoZGlyID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgdW5zdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MkMS5jb25maWcgPSB7fTtcbnByb2Nlc3MkMS5jb25uZWN0ZWQgPSBmYWxzZTtcblxucHJvY2VzcyQxLmNwdVVzYWdlID0gKCkgPT4ge1xuICAvLyBGSVhNRTogQ2FuIHdlIGxvb2sgYXQgT1MuY3B1cyB0byBnZXQgdGhpcyBkYXRhP1xuICByZXR1cm4ge1xuICAgIHVzZXI6IDAsXG4gICAgc3lzdGVtOiAwXG4gIH07XG59O1xuXG5wcm9jZXNzJDEuY3dkID0gKCkgPT4gX19kaXJuYW1lO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnZGVidWdQb3J0Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgdmFsdWUgPSAwOyAvLyBkZWZhdWx0IHRvIDBcblxuICAgIHRyeSB7XG4gICAgICBpZiAoXCJhbmRyb2lkXCIgPT09ICdhbmRyb2lkJykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBrcm9sbC5iaW5kaW5nKCdhc3NldHMnKTtcbiAgICAgICAgY29uc3QganNvbiA9IGFzc2V0cy5yZWFkQXNzZXQoJ2RlcGxveS5qc29uJyk7XG5cbiAgICAgICAgaWYgKGpzb24pIHtcbiAgICAgICAgICBjb25zdCBkZXBsb3lEYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblxuICAgICAgICAgIGlmIChkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIC0xIG1lYW5zIG5vdCBzZXQgKG5vdCBpbiBkZWJ1ZyBtb2RlKVxuICAgICAgICAgICAgdmFsdWUgPSBkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge30gLy8gaWdub3JlXG4gICAgLy8gb3ZlcndyaXRlIHRoaXMgZ2V0dGVyIHdpdGggc3RhdGljIHZhbHVlXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVidWdQb3J0Jywge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5wcm9jZXNzJDEuZGlzY29ubmVjdCA9ICgpID0+IHt9OyAvLyBuby1vcFxuXG5cbnByb2Nlc3MkMS5kbG9wZW4gPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5kbG9wZW4gaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQxLmVtaXRXYXJuaW5nID0gZnVuY3Rpb24gKHdhcm5pbmcsIG9wdGlvbnMsIGNvZGUsIGN0b3IpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBsZXQgdHlwZTtcbiAgbGV0IGRldGFpbDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgdHlwZSA9IG9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICBjb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgIGRldGFpbCA9IG9wdGlvbnMuZGV0YWlsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3YXJuaW5nID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IG1ha2UgdXNlIG9mIGBjdG9yYCBhcmcgZm9yIGxpbWl0aW5nIHN0YWNrIHRyYWNlcz8gQ2FuIG9ubHkgcmVhbGx5IGJlIHVzZWQgb24gVjhcbiAgICAvLyBzZXQgc3RhY2sgdHJhY2UgbGltaXQgdG8gMCwgdGhlbiBjYWxsIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHdhcm5pbmcsIGN0b3IpO1xuICAgIHdhcm5pbmcgPSBuZXcgRXJyb3Iod2FybmluZyk7XG4gICAgd2FybmluZy5uYW1lID0gdHlwZSB8fCAnV2FybmluZyc7XG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZy5kZXRhaWwgPSBkZXRhaWw7XG4gICAgfVxuICB9IC8vIFRPRE86IFRocm93IFR5cGVFcnJvciBpZiBub3QgYW4gaW5zdGFuY2VvZiBFcnJvciBhdCB0aGlzIHBvaW50IVxuXG5cbiAgY29uc3QgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47IC8vIGlnbm9yZVxuICB9XG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICB0aHJvdyB3YXJuaW5nO1xuICB9XG5cbiAgdGhpcy5lbWl0KCd3YXJuaW5nJywgd2FybmluZyk7XG59O1xuXG5mdW5jdGlvbiBsb2FkRW52SnNvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBqc29uRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSwgJ19lbnZfLmpzb24nKTtcblxuICAgIGlmIChqc29uRmlsZS5leGlzdHMoKSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoYEZhaWxlZCB0byByZWFkIFwiX2Vudl8uanNvblwiLiBSZWFzb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkMSwgJ2VudicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZXRlIHRoaXMuZW52O1xuICAgIHJldHVybiB0aGlzLmVudiA9IGxvYWRFbnZKc29uKCk7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5wcm9jZXNzJDEuZXhlY0FyZ3YgPSBbXTtcbnByb2Nlc3MkMS5leGVjUGF0aCA9ICcnOyAvLyBGSVhNRTogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBQYXRoIHRvIHRpdGFuaXVtIENMSSBoZXJlP1xuXG5wcm9jZXNzJDEuZXhpdCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmV4aXQgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQxLmV4aXRDb2RlID0gdW5kZWZpbmVkO1xucHJvY2VzcyQxLm5vRGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkMS5waWQgPSAwOyAvLyBGSVhNRTogU2hvdWxkIHdlIHRyeSBhbmQgYWRvcHQgJ2lwYWQnLydpcGhvbmUnIHRvICdkYXJ3aW4nPyBvciAnaW9zJz9cblxucHJvY2VzcyQxLnBsYXRmb3JtID0gXCJhbmRyb2lkXCI7XG5wcm9jZXNzJDEucHBpZCA9IDA7IC8vIFRPRE86IEFkZCByZWxlYXNlIHByb3BlcnR5IChPYmplY3QpXG4vLyBUT0RPOiBDYW4gd2UgZXhwb3NlIHN0ZG91dC9zdGRlcnIvc3RkaW4gbmF0aXZlbHk/XG4vLyBEb24ndCB3cmFwIGNvbnNvbGUubG9nL2Vycm9yIGJlY2F1c2UgdGVjaG5pY2FsbHkgZ2xvYmFsIGNvbnNvbGUgd3JhcHMgcHJvY2Vzcy5zdGRvdXQvc3RkZXJyIChvciBzaG91bGQpXG5cbnByb2Nlc3MkMS5zdGRlcnIgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgIFRpLkFQSS5lcnJvcihjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDEuc3Rkb3V0ID0ge1xuICBpc1RUWTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICBUaS5BUEkuaW5mbyhjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDEudGl0bGUgPSBUaS5BcHAubmFtZTtcbnByb2Nlc3MkMS50aHJvd0RlcHJlY2F0aW9uID0gZmFsc2U7XG5wcm9jZXNzJDEudHJhY2VEZXByZWNhdGlvbiA9IGZhbHNlO1xuXG5wcm9jZXNzJDEudW1hc2sgPSAoKSA9PiAwOyAvLyBqdXN0IGFsd2F5cyByZXR1cm4gMFxuXG5cbnByb2Nlc3MkMS51cHRpbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGRpZmZNcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIHJldHVybiBkaWZmTXMgLyAxMDAwLjA7IC8vIGNvbnZlcnQgdG8gXCJzZWNvbmRzXCIgd2l0aCBmcmFjdGlvbnNcbn07XG5cbnByb2Nlc3MkMS52ZXJzaW9uID0gXCIxMC4xLjFcIjtcbnByb2Nlc3MkMS52ZXJzaW9ucyA9IHtcbiAgbW9kdWxlczogJycsXG4gIC8vIFRPRE86IFJlcG9ydCBtb2R1bGUgYXBpIHZlcnNpb24gKGZvciBjdXJyZW50IHBsYXRmb3JtISlcbiAgdjg6ICcnLFxuICAvLyBUT0RPOiByZXBvcnQgYW5kcm9pZCdzIHY4IHZlcnNpb24gKGlmIG9uIEFuZHJvaWQhKVxuICBqc2M6ICcnIC8vIFRPRE86IHJlcG9ydCBqYXZhc2NyaXB0Y29yZSB2ZXJzaW9uIGZvciBpT1MvV0luZG93cz9cbiAgLy8gVE9ETzogUmVwb3J0IGlvcy9BbmRyb2lkL1dpbmRvd3MgcGxhdGZvcm0gdmVyc2lvbnM/XG5cbn07XG5wcm9jZXNzJDFbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdwcm9jZXNzJztcbmdsb2JhbC5wcm9jZXNzID0gcHJvY2VzcyQxOyAvLyBoYW5kbGUgc3BpdHRpbmcgb3V0IHdhcm5pbmdzXG5cbmNvbnN0IFdBUk5JTkdfUFJFRklYID0gYCh0aXRhbml1bToke3Byb2Nlc3MkMS5waWR9KSBgO1xucHJvY2VzcyQxLm9uKCd3YXJuaW5nJywgd2FybmluZyA9PiB7XG4gIGNvbnN0IGlzRGVwcmVjYXRpb24gPSB3YXJuaW5nLm5hbWUgPT09ICdEZXByZWNhdGlvbldhcm5pbmcnOyAvLyBpZiB3ZSdyZSBub3QgZG9pbmcgZGVwcmVjYXRpb25zLCBpZ25vcmUhXG5cbiAgaWYgKGlzRGVwcmVjYXRpb24gJiYgcHJvY2VzcyQxLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVE9ETzogQ2hlY2sgcHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uIGFuZCBpZiBzZXQsIGluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gbWVzc2FnZSFcblxuXG4gIGxldCBtc2cgPSBXQVJOSU5HX1BSRUZJWDtcblxuICBpZiAod2FybmluZy5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtc2cgKz0gYFske3dhcm5pbmcuY29kZX1dIGA7XG4gIH1cblxuICBpZiAod2FybmluZy50b1N0cmluZykge1xuICAgIG1zZyArPSB3YXJuaW5nLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAod2FybmluZy5kZXRhaWwpIHtcbiAgICBtc2cgKz0gYFxcbiR7d2FybmluZy5kZXRhaWx9YDtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbn0pO1xubGV0IHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuXG5wcm9jZXNzJDEuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSAoKSA9PiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsO1xuXG5wcm9jZXNzJDEuc2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSBmbiA9PiB7XG4gIGlmIChmbiA9PT0gbnVsbCkge1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9jZXNzLnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrKClgIHdhcyBjYWxsZWQgd2hpbGUgYSBjYXB0dXJlIGNhbGxiYWNrIHdhcyBhbHJlYWR5IGFjdGl2ZScpO1xuICB9XG5cbiAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IGZuO1xufTtcblxuVGkuQXBwLmFkZEV2ZW50TGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIENyZWF0ZSBhbiBFcnJvciBpbnN0YW5jZSB0aGF0IHdyYXBzIHRoZSBkYXRhIGZyb20gdGhlIGV2ZW50XG4gIC8vIGlkZWFsbHkgd2UnZCBqdXN0IGZvcndhcmQgYWxvbmcgdGhlIG9yaWdpbmFsIEVycm9yIVxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihldmVudC5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBldmVudC5iYWNrdHJhY2U7XG4gIGVycm9yLmZpbGVOYW1lID0gZXZlbnQuc291cmNlTmFtZTtcbiAgZXJyb3IubGluZU51bWJlciA9IGV2ZW50LmxpbmU7XG4gIGVycm9yLmNvbHVtbk51bWJlciA9IGV2ZW50LmxpbmVPZmZzZXQ7XG5cbiAgaWYgKHByb2Nlc3MkMS5oYXNVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjaygpKSB7XG4gICAgcmV0dXJuIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2soZXJyb3IpO1xuICB9IC8vIG90aGVyd2lzZSBmb3J3YXJkIHRoZSBldmVudCFcblxuXG4gIHByb2Nlc3MkMS5lbWl0KCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yKTtcbn0pO1xuLy8gSlMgZW5naW5lIHNob3VsZCBiZSBhYmxlIHRvIG9wdGltaXplIGVhc2llclxuXG5jbGFzcyBDYWxsYmFja1dpdGhBcmdzIHtcbiAgY29uc3RydWN0b3IoZnVuYywgYXJncykge1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIHJ1bigpIHtcbiAgICBpZiAodGhpcy5hcmdzKSB7XG4gICAgICB0aGlzLmZ1bmMuYXBwbHkobnVsbCwgdGhpcy5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mdW4oKTtcbiAgICB9XG4gIH1cblxufSAvLyBuZXh0VGljayB2cyBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYSBzZW1pLXNtYXJ0IHdheVxuLy8gQmFzaWNhbGx5IG5leHRUaWNrIG5lZWRzIHRvIGRyYWluIHRoZSBmdWxsIHF1ZXVlIChhbmQgY2FuIGNhdXNlIGluZmluaXRlIGxvb3BzIGlmIG5leHRUaWNrIGNhbGxiYWNrIGNhbGxzIG5leHRUaWNrISlcbi8vIFRoZW4gd2Ugc2hvdWxkIGdvIHRocm91Z2ggdGhlIFwiaW1tZWRpYXRlXCIgcXVldWVcbi8vIGh0dHA6Ly9wbGFmZXIuZ2l0aHViLmlvLzIwMTUvMDkvMDgvbmV4dFRpY2stdnMtc2V0SW1tZWRpYXRlL1xuXG5cbmNvbnN0IHRpY2tRdWV1ZSA9IFtdO1xuY29uc3QgaW1tZWRpYXRlUXVldWUgPSBbXTtcbmxldCBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xubGV0IGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4vKipcbiAqIEl0ZXJhdGl2ZWx5IHJ1bnMgYWxsIFwidGlja3NcIiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZS5cbiAqIFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbiBpZiBhIHRpY2sgc2NoZWR1bGVzIGFub3RoZXIgZm9yZXZlci5cbiAqL1xuXG5mdW5jdGlvbiBkcmFpblRpY2tRdWV1ZSgpIHtcbiAgaWYgKGRyYWluaW5nVGlja1F1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSB0cnVlO1xuXG4gIHdoaWxlICh0aWNrUXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3QgdGljayA9IHRpY2tRdWV1ZS5zaGlmdCgpO1xuICAgIHRpY2sucnVuKCk7XG4gIH1cblxuICBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlcygpIHtcbiAgLy8gZHJhaW4gdGhlIGZ1bGwgdGljayBxdWV1ZSBmaXJzdC4uLlxuICBkcmFpblRpY2tRdWV1ZSgpOyAvLyB0aWNrIHF1ZXVlIHNob3VsZCBiZSBlbXB0eSFcblxuICBjb25zdCBpbW1lZGlhdGVzUmVtYWluaW5nID0gcHJvY2Vzc0ltbWVkaWF0ZVF1ZXVlKCk7XG5cbiAgaWYgKGltbWVkaWF0ZXNSZW1haW5pbmcgIT09IDApIHtcbiAgICAvLyByZS1zY2hlZHVsZSBkcmFpbmluZyBvdXIgcXVldWVzLCBhcyB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBtb3JlIFwiaW1tZWRpYXRlXCIgdG8gaGFuZGxlXG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH0gZWxzZSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBwcm9jZXNzIFwiaW1tZWRpYXRlc1wiIChpbiBhIG11Y2ggbW9yZSBsZWlzdXJlbHkgd2F5IHRoYW4gdGlja3MpXG4gKiBXZSBnaXZlIGEgMTAwbXMgd2luZG93IHRvIHJ1biB0aGVtIGluIGJlZm9yZSByZS1zY2hlZHVsaW5nIHRoZSB0aW1lb3V0IHRvIHByb2Nlc3MgdGhlbSBhZ2Fpbi5cbiAqIElmIGFueSB0aWNrcyBhcmUgYWRkZWQgZHVyaW5nIGludm9jYXRpb24gb2YgaW1tZWRpYXRlLCB3ZSBkcmFpbiB0aGUgdGljayBxdWV1ZSBmdWxseSBiZWZvcmVcbiAqIHByb2NlZWRpbmcgdG8gbmV4dCBpbW1lZGlhdGUgKGlmIHdlIHN0aWxsIGhhdmUgdGltZSBpbiBvdXIgd2luZG93KS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IG51bWJlciBvZiByZW1haW5pbmcgaW1tZWRpYXRlcyB0byBiZSBwcm9jZXNzZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpIHtcbiAgY29uc3QgaW1tZWRpYXRlRGVhZGxpbmUgPSBEYXRlLm5vdygpICsgMTAwOyAvLyBnaXZlIHVzIHVwIHRvIDEwMG1zIHRvIHByb2Nlc3MgaW1tZWRpYXRlc1xuXG4gIHdoaWxlIChpbW1lZGlhdGVRdWV1ZS5sZW5ndGggJiYgRGF0ZS5ub3coKSA8IGltbWVkaWF0ZURlYWRsaW5lKSB7XG4gICAgY29uc3QgaW1tZWRpYXRlID0gaW1tZWRpYXRlUXVldWUuc2hpZnQoKTtcbiAgICBpbW1lZGlhdGUucnVuKCk7XG5cbiAgICBpZiAodGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHRoZXkgYWRkZWQgYSB0aWNrISBkcmFpbiB0aGUgdGljayBxdWV1ZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZSAodGhpcyAqbWF5KiBlYXQgdXAgb3VyIGRlYWRsaW5lL3dpbmRvdyB0byBwcm9jZXNzIGFueSBtb3JlIGltbWVkaWF0ZXMpXG4gICAgICBkcmFpblRpY2tRdWV1ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbW1lZGlhdGVRdWV1ZS5sZW5ndGg7XG59XG5cbnByb2Nlc3MkMS5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgLi4uYXJncykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY2FsbGJhY2ssICdjYWxsYmFjaycsICdmdW5jdGlvbicpO1xuICB0aWNrUXVldWUucHVzaChuZXcgQ2FsbGJhY2tXaXRoQXJncyhjYWxsYmFjaywgYXJncykpO1xuXG4gIGlmICghZHJhaW5RdWV1ZXNUaW1lb3V0KSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH1cbn07XG5cbmdsb2JhbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgY29uc3QgaW1tZWRpYXRlID0gbmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpO1xuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGltbWVkaWF0ZSk7XG5cbiAgaWYgKCFkcmFpblF1ZXVlc1RpbWVvdXQpIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfVxuXG4gIHJldHVybiBpbW1lZGlhdGU7XG59O1xuXG5nbG9iYWwuY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIGNvbnN0IGluZGV4ID0gaW1tZWRpYXRlUXVldWUuaW5kZXhPZihpbW1lZGlhdGUpO1xuXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBpbW1lZGlhdGVRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5jb25zdCBGT1JXQVJEX1NMQVNIID0gNDc7IC8vICcvJ1xuXG5jb25zdCBCQUNLV0FSRF9TTEFTSCA9IDkyOyAvLyAnXFxcXCdcblxuLyoqXG4gKiBJcyB0aGlzIFthLXpBLVpdP1xuICogQHBhcmFtICB7bnVtYmVyfSAgY2hhckNvZGUgdmFsdWUgZnJvbSBTdHJpbmcuY2hhckNvZGVBdCgpXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuZnVuY3Rpb24gaXNXaW5kb3dzRGV2aWNlTmFtZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gOTAgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyO1xufVxuLyoqXG4gKiBbaXNBYnNvbHV0ZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IGlzUG9zaXggd2hldGhlciB0aGlzIGltcGwgaXMgZm9yIFBPU0lYIG9yIG5vdFxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gaXNBYnNvbHV0ZShpc1Bvc2l4LCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7IC8vIGVtcHR5IHN0cmluZyBzcGVjaWFsIGNhc2VcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcblxuICBpZiAoZmlyc3RDaGFyID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gd2UgYWxyZWFkeSBkaWQgb3VyIGNoZWNrcyBmb3IgcG9zaXhcblxuXG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHdpbjMyIGZyb20gaGVyZSBvbiBvdXRcblxuXG4gIGlmIChmaXJzdENoYXIgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMiAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhcikgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBjb25zdCB0aGlyZENoYXIgPSBmaWxlcGF0aC5jaGFyQXQoMik7XG4gICAgcmV0dXJuIHRoaXJkQ2hhciA9PT0gJy8nIHx8IHRoaXJkQ2hhciA9PT0gJ1xcXFwnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBbZGlybmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpcm5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgbGV0IGZyb21JbmRleCA9IGxlbmd0aCAtIDE7XG4gIGNvbnN0IGhhZFRyYWlsaW5nID0gZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKTtcblxuICBpZiAoaGFkVHJhaWxpbmcpIHtcbiAgICBmcm9tSW5kZXgtLTtcbiAgfVxuXG4gIGNvbnN0IGZvdW5kSW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGZyb21JbmRleCk7IC8vIG5vIHNlcGFyYXRvcnNcblxuICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIHJvb3Qgd2luZG93cyBwYXRoc1xuICAgIGlmIChsZW5ndGggPj0gMiAmJiBzZXBhcmF0b3IgPT09ICdcXFxcJyAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgICAgY29uc3QgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyKSkge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7IC8vIGl0J3MgYSByb290IHdpbmRvd3MgcGF0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnLic7XG4gIH0gLy8gb25seSBmb3VuZCByb290IHNlcGFyYXRvclxuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gc2VwYXJhdG9yOyAvLyBpZiBpdCB3YXMgJy8nLCByZXR1cm4gdGhhdFxuICB9IC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgJy8vc29tZXRoaW5nJ1xuXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IDEgJiYgc2VwYXJhdG9yID09PSAnLycgJiYgZmlsZXBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gJy8vJztcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZSgwLCBmb3VuZEluZGV4KTtcbn1cbi8qKlxuICogW2V4dG5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBleHRuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgaW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgbGV0IGVuZEluZGV4ID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZShpbmRleCwgZW5kSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGNoYXIgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNoYXIgPT09IEJBQ0tXQVJEX1NMQVNIIHx8IGNoYXIgPT09IEZPUldBUkRfU0xBU0gpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICogW2Jhc2VuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtleHRdICAgICAgZmlsZSBleHRlbnNpb24gdG8gZHJvcCBpZiBpdCBleGlzdHNcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBiYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoLCBleHQpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcblxuICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnRBcmd1bWVudFR5cGUoZXh0LCAnZXh0JywgJ3N0cmluZycpO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBpc1Bvc2l4ID0gc2VwYXJhdG9yID09PSAnLyc7XG4gIGxldCBlbmRJbmRleCA9IGxlbmd0aDsgLy8gZHJvcCB0cmFpbGluZyBzZXBhcmF0b3IgKGlmIHRoZXJlIGlzIG9uZSlcblxuICBjb25zdCBsYXN0Q2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpO1xuXG4gIGlmIChsYXN0Q2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgIWlzUG9zaXggJiYgbGFzdENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIGVuZEluZGV4LS07XG4gIH0gLy8gRmluZCBsYXN0IG9jY3VyZW5jZSBvZiBzZXBhcmF0b3JcblxuXG4gIGxldCBsYXN0SW5kZXggPSAtMTtcblxuICBpZiAoaXNQb3NpeCkge1xuICAgIGxhc3RJbmRleCA9IGZpbGVwYXRoLmxhc3RJbmRleE9mKHNlcGFyYXRvciwgZW5kSW5kZXggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbiB3aW4zMiwgaGFuZGxlICplaXRoZXIqIHNlcGFyYXRvciFcbiAgICBsYXN0SW5kZXggPSBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgZW5kSW5kZXggLSAxKTsgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiByb290IHBhdGggbGlrZSAnQzonIG9yICdDOlxcXFwnXG5cbiAgICBpZiAoKGxhc3RJbmRleCA9PT0gMiB8fCBsYXN0SW5kZXggPT09IC0xKSAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKGZpbGVwYXRoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9IC8vIFRha2UgZnJvbSBsYXN0IG9jY3VycmVuY2Ugb2Ygc2VwYXJhdG9yIHRvIGVuZCBvZiBzdHJpbmcgKG9yIGJlZ2lubmluZyB0byBlbmQgaWYgbm90IGZvdW5kKVxuXG5cbiAgY29uc3QgYmFzZSA9IGZpbGVwYXRoLnNsaWNlKGxhc3RJbmRleCArIDEsIGVuZEluZGV4KTsgLy8gZHJvcCB0cmFpbGluZyBleHRlbnNpb24gKGlmIHNwZWNpZmllZClcblxuICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBiYXNlLmVuZHNXaXRoKGV4dCkgPyBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gZXh0Lmxlbmd0aCkgOiBiYXNlO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgubm9ybWFsaXplKClgIG1ldGhvZCBub3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzLlxuICpcbiAqIFdoZW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcGF0aCBzZWdtZW50IHNlcGFyYXRpb24gY2hhcmFjdGVycyBhcmUgZm91bmQgKGUuZy5cbiAqIC8gb24gUE9TSVggYW5kIGVpdGhlciBcXCBvciAvIG9uIFdpbmRvd3MpLCB0aGV5IGFyZSByZXBsYWNlZCBieSBhIHNpbmdsZVxuICogaW5zdGFuY2Ugb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggc2VnbWVudCBzZXBhcmF0b3IgKC8gb24gUE9TSVggYW5kIFxcXG4gKiBvbiBXaW5kb3dzKS4gVHJhaWxpbmcgc2VwYXJhdG9ycyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBwYXRoIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLCAnLicgaXMgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGVcbiAqIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcblxuICBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcuJztcbiAgfSAvLyBXaW5kb3dzIGNhbiBoYW5kbGUgJy8nIG9yICdcXFxcJyBhbmQgYm90aCBzaG91bGQgYmUgdHVybmVkIGludG8gc2VwYXJhdG9yXG5cblxuICBjb25zdCBpc1dpbmRvd3MgPSBzZXBhcmF0b3IgPT09ICdcXFxcJztcblxuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgZmlsZXBhdGggPSBmaWxlcGF0aC5yZXBsYWNlKC9cXC8vZywgc2VwYXJhdG9yKTtcbiAgfVxuXG4gIGNvbnN0IGhhZExlYWRpbmcgPSBmaWxlcGF0aC5zdGFydHNXaXRoKHNlcGFyYXRvcik7IC8vIE9uIFdpbmRvd3MsIG5lZWQgdG8gaGFuZGxlIFVOQyBwYXRocyAoXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxkaXIpIHNwZWNpYWwgdG8gcmV0YWluIGxlYWRpbmcgZG91YmxlIGJhY2tzbGFzaFxuXG4gIGNvbnN0IGlzVU5DID0gaGFkTGVhZGluZyAmJiBpc1dpbmRvd3MgJiYgZmlsZXBhdGgubGVuZ3RoID4gMiAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJztcbiAgY29uc3QgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuICBjb25zdCBwYXJ0cyA9IGZpbGVwYXRoLnNwbGl0KHNlcGFyYXRvcik7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXJ0cykge1xuICAgIGlmIChzZWdtZW50Lmxlbmd0aCAhPT0gMCAmJiBzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTsgLy8gRklYTUU6IFdoYXQgaWYgdGhpcyBnb2VzIGFib3ZlIHJvb3Q/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBub3JtYWxpemVkID0gaGFkTGVhZGluZyA/IHNlcGFyYXRvciA6ICcnO1xuICBub3JtYWxpemVkICs9IHJlc3VsdC5qb2luKHNlcGFyYXRvcik7XG5cbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgbm9ybWFsaXplZCArPSBzZXBhcmF0b3I7XG4gIH1cblxuICBpZiAoaXNVTkMpIHtcbiAgICBub3JtYWxpemVkID0gJ1xcXFwnICsgbm9ybWFsaXplZDtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBbYXNzZXJ0U2VnbWVudCBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAgeyp9IHNlZ21lbnQgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7dm9pZH0gICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRTZWdtZW50KHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJHtzZWdtZW50fWApO1xuICB9XG59XG4vKipcbiAqIFRoZSBgcGF0aC5qb2luKClgIG1ldGhvZCBqb2lucyBhbGwgZ2l2ZW4gcGF0aCBzZWdtZW50cyB0b2dldGhlciB1c2luZyB0aGVcbiAqIHBsYXRmb3JtLXNwZWNpZmljIHNlcGFyYXRvciBhcyBhIGRlbGltaXRlciwgdGhlbiBub3JtYWxpemVzIHRoZSByZXN1bHRpbmcgcGF0aC5cbiAqIFplcm8tbGVuZ3RoIHBhdGggc2VnbWVudHMgYXJlIGlnbm9yZWQuIElmIHRoZSBqb2luZWQgcGF0aCBzdHJpbmcgaXMgYSB6ZXJvLVxuICogbGVuZ3RoIHN0cmluZyB0aGVuICcuJyB3aWxsIGJlIHJldHVybmVkLCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nW119IHBhdGhzIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgVGhlIGpvaW5lZCBmaWxlcGF0aFxuICovXG5cblxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdOyAvLyBuYWl2ZSBpbXBsOiBqdXN0IGpvaW4gYWxsIHRoZSBwYXRocyB3aXRoIHNlcGFyYXRvclxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRocykge1xuICAgIGFzc2VydFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc2VwYXJhdG9yLCByZXN1bHQuam9pbihzZXBhcmF0b3IpKTtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlc29sdmUoKWAgbWV0aG9kIHJlc29sdmVzIGEgc2VxdWVuY2Ugb2YgcGF0aHMgb3IgcGF0aCBzZWdtZW50cyBpbnRvIGFuIGFic29sdXRlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmUoc2VwYXJhdG9yLCBwYXRocykge1xuICBsZXQgcmVzb2x2ZWQgPSAnJztcbiAgbGV0IGhpdFJvb3QgPSBmYWxzZTtcbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nOyAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuXG4gIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoc1tpXTtcbiAgICBhc3NlcnRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eVxuICAgIH1cblxuICAgIHJlc29sdmVkID0gc2VnbWVudCArIHNlcGFyYXRvciArIHJlc29sdmVkOyAvLyBwcmVwZW5kIG5ldyBzZWdtZW50XG5cbiAgICBpZiAoaXNBYnNvbHV0ZShpc1Bvc2l4LCBzZWdtZW50KSkge1xuICAgICAgLy8gaGF2ZSB3ZSBiYWNrZWQgaW50byBhbiBhYnNvbHV0ZSBwYXRoP1xuICAgICAgaGl0Um9vdCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gaWYgd2UgZGlkbid0IGhpdCByb290LCBwcmVwZW5kIGN3ZFxuXG5cbiAgaWYgKCFoaXRSb290KSB7XG4gICAgcmVzb2x2ZWQgPSAoZ2xvYmFsLnByb2Nlc3MgPyBwcm9jZXNzLmN3ZCgpIDogJy8nKSArIHNlcGFyYXRvciArIHJlc29sdmVkO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShzZXBhcmF0b3IsIHJlc29sdmVkKTtcblxuICBpZiAobm9ybWFsaXplZC5jaGFyQXQobm9ybWFsaXplZC5sZW5ndGggLSAxKSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgb24gV2luZG93cyBhcyB3ZWxsLCBzbyB3ZSBkb24ndCB0cmltIHRyYWlsaW5nIHNlcGFyYXRvciBvbiBzb21ldGhpbmcgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJ1xuICAgIC8vIERvbid0IHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3IgaWYgdGhpcyBpcyByb290IHBhdGggb24gd2luZG93cyFcbiAgICBpZiAoIWlzUG9zaXggJiYgbm9ybWFsaXplZC5sZW5ndGggPT09IDMgJiYgbm9ybWFsaXplZC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKG5vcm1hbGl6ZWQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yXG5cblxuICAgIHJldHVybiBub3JtYWxpemVkLnNsaWNlKDAsIG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlbGF0aXZlKClgIG1ldGhvZCByZXR1cm5zIHRoZSByZWxhdGl2ZSBwYXRoIGBmcm9tYCBmcm9tIHRvIGB0b2AgYmFzZWRcbiAqIG9uIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBmcm9tIGFuZCB0byBlYWNoIHJlc29sdmUgdG8gdGhlIHNhbWVcbiAqIHBhdGggKGFmdGVyIGNhbGxpbmcgYHBhdGgucmVzb2x2ZSgpYCBvbiBlYWNoKSwgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcGFzc2VkIGFzIGBmcm9tYCBvciBgdG9gLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICogd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHplcm8tbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZnJvbSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbGF0aXZlKHNlcGFyYXRvciwgZnJvbSwgdG8pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZyb20sICdmcm9tJywgJ3N0cmluZycpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUodG8sICd0bycsICdzdHJpbmcnKTtcblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmcm9tID0gcmVzb2x2ZShzZXBhcmF0b3IsIFtmcm9tXSk7XG4gIHRvID0gcmVzb2x2ZShzZXBhcmF0b3IsIFt0b10pO1xuXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyB3ZSBub3cgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsXG4gIC8vIGxldHMgXCJnbyB1cFwiIGZyb20gYGZyb21gIHVudGlsIHdlIHJlYWNoIGNvbW1vbiBiYXNlIGRpciBvZiBgdG9gXG4gIC8vIGNvbnN0IG9yaWdpbmFsRnJvbSA9IGZyb207XG5cblxuICBsZXQgdXBDb3VudCA9IDA7XG4gIGxldCByZW1haW5pbmdQYXRoID0gJyc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodG8uc3RhcnRzV2l0aChmcm9tKSkge1xuICAgICAgLy8gbWF0Y2ghIHJlY29yZCByZXN0Li4uP1xuICAgICAgcmVtYWluaW5nUGF0aCA9IHRvLnNsaWNlKGZyb20ubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gRklYTUU6IEJyZWFrL3Rocm93IGlmIHdlIGhpdCBiYWQgZWRnZSBjYXNlIG9mIG5vIGNvbW1vbiByb290IVxuXG5cbiAgICBmcm9tID0gZGlybmFtZShzZXBhcmF0b3IsIGZyb20pO1xuICAgIHVwQ291bnQrKztcbiAgfSAvLyByZW1vdmUgbGVhZGluZyBzZXBhcmF0b3IgZnJvbSByZW1haW5pbmdQYXRoIGlmIHRoZXJlIGlzIGFueVxuXG5cbiAgaWYgKHJlbWFpbmluZ1BhdGgubGVuZ3RoID4gMCkge1xuICAgIHJlbWFpbmluZ1BhdGggPSByZW1haW5pbmdQYXRoLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuICgnLi4nICsgc2VwYXJhdG9yKS5yZXBlYXQodXBDb3VudCkgKyByZW1haW5pbmdQYXRoO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgucGFyc2UoKWAgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgcmVwcmVzZW50XG4gKiBzaWduaWZpY2FudCBlbGVtZW50cyBvZiB0aGUgcGF0aC4gVHJhaWxpbmcgZGlyZWN0b3J5IHNlcGFyYXRvcnMgYXJlIGlnbm9yZWQsXG4gKiBzZWUgYHBhdGguc2VwYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBkaXIgPHN0cmluZz5cbiAqIC0gcm9vdCA8c3RyaW5nPlxuICogLSBiYXNlIDxzdHJpbmc+XG4gKiAtIG5hbWUgPHN0cmluZz5cbiAqIC0gZXh0IDxzdHJpbmc+XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByb290OiAnJyxcbiAgICBkaXI6ICcnLFxuICAgIGJhc2U6ICcnLFxuICAgIGV4dDogJycsXG4gICAgbmFtZTogJydcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIENoZWF0IGFuZCBqdXN0IGNhbGwgb3VyIG90aGVyIG1ldGhvZHMgZm9yIGRpcm5hbWUvYmFzZW5hbWUvZXh0bmFtZT9cblxuXG4gIHJlc3VsdC5iYXNlID0gYmFzZW5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCk7XG4gIHJlc3VsdC5leHQgPSBleHRuYW1lKHNlcGFyYXRvciwgcmVzdWx0LmJhc2UpO1xuICBjb25zdCBiYXNlTGVuZ3RoID0gcmVzdWx0LmJhc2UubGVuZ3RoO1xuICByZXN1bHQubmFtZSA9IHJlc3VsdC5iYXNlLnNsaWNlKDAsIGJhc2VMZW5ndGggLSByZXN1bHQuZXh0Lmxlbmd0aCk7XG4gIGNvbnN0IHRvU3VidHJhY3QgPSBiYXNlTGVuZ3RoID09PSAwID8gMCA6IGJhc2VMZW5ndGggKyAxO1xuICByZXN1bHQuZGlyID0gZmlsZXBhdGguc2xpY2UoMCwgZmlsZXBhdGgubGVuZ3RoIC0gdG9TdWJ0cmFjdCk7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIVxuXG4gIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDApOyAvLyBib3RoIHdpbjMyIGFuZCBQT1NJWCByZXR1cm4gJy8nIHJvb3RcblxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJlc3VsdC5yb290ID0gJy8nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gd2UncmUgZG9uZSB3aXRoIFBPU0lYLi4uXG5cblxuICBpZiAoc2VwYXJhdG9yID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIGZvciB3aW4zMi4uLlxuXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZmlsZV9wYXRoJ1xuICAgIC8vIG5lZWQgdG8gcmV0YWluICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFwnIGFzIHJvb3QgaW4gdGhhdCBjYXNlIVxuICAgIHJlc3VsdC5yb290ID0gJ1xcXFwnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gY2hlY2sgZm9yIEM6IHN0eWxlIHJvb3RcblxuXG4gIGlmIChsZW5ndGggPiAxICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyQ29kZSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgLy8gaXMgaXQgbGlrZSBDOlxcXFw/XG4gICAgICBjb25zdCB0aGlyZENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdCgyKTtcblxuICAgICAgaWYgKHRoaXJkQ2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgdGhpcmRDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IC8vIG5vcGUsIGp1c3QgQzosIG5vIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgICByZXN1bHQucm9vdCA9IGZpbGVwYXRoLnNsaWNlKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLmZvcm1hdCgpYCBtZXRob2QgcmV0dXJucyBhIHBhdGggc3RyaW5nIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHRoZVxuICogb3Bwb3NpdGUgb2YgYHBhdGgucGFyc2UoKWAuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gcGF0aE9iamVjdCBvYmplY3Qgb2YgZm9ybWF0IHJldHVybmVkIGJ5IGBwYXRoLnBhcnNlKClgXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuZGlyIGRpcmVjdG9yeSBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3Qucm9vdCBmaWxlIHJvb3QgZGlyLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmRpcmAgaXMgcHJvdmlkZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5iYXNlIGZpbGUgYmFzZW5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5uYW1lIGJhc2VuYW1lIG1pbnVzIGV4dGVuc2lvbiwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5iYXNlYCBleGlzdHNcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5leHQgZmlsZSBleHRlbnNpb24sIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuYmFzZWAgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXQoc2VwYXJhdG9yLCBwYXRoT2JqZWN0KSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwYXRoT2JqZWN0LCAncGF0aE9iamVjdCcsICdvYmplY3QnKTtcbiAgY29uc3QgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCBgJHtwYXRoT2JqZWN0Lm5hbWUgfHwgJyd9JHtwYXRoT2JqZWN0LmV4dCB8fCAnJ31gOyAvLyBhcHBlbmQgYmFzZSB0byByb290IGlmIGBkaXJgIHdhc24ndCBzcGVjaWZpZWQsIG9yIGlmXG4gIC8vIGRpciBpcyB0aGUgcm9vdFxuXG4gIGlmICghcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5kaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBgJHtwYXRoT2JqZWN0LnJvb3QgfHwgJyd9JHtiYXNlfWA7XG4gIH0gLy8gY29tYmluZSBkaXIgKyAvICsgYmFzZVxuXG5cbiAgcmV0dXJuIGAke3BhdGhPYmplY3QuZGlyfSR7c2VwYXJhdG9yfSR7YmFzZX1gO1xufVxuLyoqXG4gKiBPbiBXaW5kb3dzIHN5c3RlbXMgb25seSwgcmV0dXJucyBhbiBlcXVpdmFsZW50IG5hbWVzcGFjZS1wcmVmaXhlZCBwYXRoIGZvclxuICogdGhlIGdpdmVuIHBhdGguIElmIHBhdGggaXMgbm90IGEgc3RyaW5nLCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxuICogU2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MvZGVza3RvcC9GaWxlSU8vbmFtaW5nLWEtZmlsZSNuYW1lc3BhY2VzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCByZXNvbHZlZFBhdGggPSByZXNvbHZlKCdcXFxcJywgW2ZpbGVwYXRoXSk7XG4gIGNvbnN0IGxlbmd0aCA9IHJlc29sdmVkUGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAvLyBuZWVkICdcXFxcXFxcXCcgb3IgJ0M6JyBtaW5pbXVtXG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApOyAvLyBpZiBzdGFydCB3aXRoICdcXFxcXFxcXCcsIHByZWZpeCB3aXRoIFVOQyByb290LCBkcm9wIHRoZSBzbGFzaGVzXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJykge1xuICAgIC8vIHJldHVybiBhcy1pcyBpZiBpdCdzIGFuIGFyZWFkeSBsb25nIHBhdGggKCdcXFxcXFxcXD9cXFxcJyBvciAnXFxcXFxcXFwuXFxcXCcgcHJlZml4KVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgdGhpcmRDaGFyID0gcmVzb2x2ZWRQYXRoLmNoYXJBdCgyKTtcblxuICAgICAgaWYgKHRoaXJkQ2hhciA9PT0gJz8nIHx8IHRoaXJkQ2hhciA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBmaWxlcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFxVTkNcXFxcJyArIHJlc29sdmVkUGF0aC5zbGljZSgyKTtcbiAgfSBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhckNvZGUpICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgIHJldHVybiAnXFxcXFxcXFw/XFxcXCcgKyByZXNvbHZlZFBhdGg7XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGg7XG59XG5cbmNvbnN0IFdpbjMyUGF0aCA9IHtcbiAgc2VwOiAnXFxcXCcsXG4gIGRlbGltaXRlcjogJzsnLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMuc2VwLCBwYXRoT2JqZWN0KTtcbiAgfSxcbiAgdG9OYW1lc3BhY2VkUGF0aDogdG9OYW1lc3BhY2VkUGF0aFxufTtcbmNvbnN0IFBvc2l4UGF0aCA9IHtcbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUodHJ1ZSwgZmlsZXBhdGgpO1xuICB9LFxuICByZWxhdGl2ZTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlKHRoaXMuc2VwLCBmcm9tLCB0byk7XG4gIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIHJldHVybiByZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiAocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG5jb25zdCBwYXRoID0gUG9zaXhQYXRoO1xucGF0aC53aW4zMiA9IFdpbjMyUGF0aDtcbnBhdGgucG9zaXggPSBQb3NpeFBhdGg7XG5cbmNvbnN0IFBvc2l4Q29uc3RhbnRzID0ge1xuICBVVl9VRFBfUkVVU0VBRERSOiA0LFxuICBkbG9wZW46IHt9LFxuICBlcnJubzoge1xuICAgIEUyQklHOiA3LFxuICAgIEVBQ0NFUzogMTMsXG4gICAgRUFERFJJTlVTRTogNDgsXG4gICAgRUFERFJOT1RBVkFJTDogNDksXG4gICAgRUFGTk9TVVBQT1JUOiA0NyxcbiAgICBFQUdBSU46IDM1LFxuICAgIEVBTFJFQURZOiAzNyxcbiAgICBFQkFERjogOSxcbiAgICBFQkFETVNHOiA5NCxcbiAgICBFQlVTWTogMTYsXG4gICAgRUNBTkNFTEVEOiA4OSxcbiAgICBFQ0hJTEQ6IDEwLFxuICAgIEVDT05OQUJPUlRFRDogNTMsXG4gICAgRUNPTk5SRUZVU0VEOiA2MSxcbiAgICBFQ09OTlJFU0VUOiA1NCxcbiAgICBFREVBRExLOiAxMSxcbiAgICBFREVTVEFERFJSRVE6IDM5LFxuICAgIEVET006IDMzLFxuICAgIEVEUVVPVDogNjksXG4gICAgRUVYSVNUOiAxNyxcbiAgICBFRkFVTFQ6IDE0LFxuICAgIEVGQklHOiAyNyxcbiAgICBFSE9TVFVOUkVBQ0g6IDY1LFxuICAgIEVJRFJNOiA5MCxcbiAgICBFSUxTRVE6IDkyLFxuICAgIEVJTlBST0dSRVNTOiAzNixcbiAgICBFSU5UUjogNCxcbiAgICBFSU5WQUw6IDIyLFxuICAgIEVJTzogNSxcbiAgICBFSVNDT05OOiA1NixcbiAgICBFSVNESVI6IDIxLFxuICAgIEVMT09QOiA2MixcbiAgICBFTUZJTEU6IDI0LFxuICAgIEVNTElOSzogMzEsXG4gICAgRU1TR1NJWkU6IDQwLFxuICAgIEVNVUxUSUhPUDogOTUsXG4gICAgRU5BTUVUT09MT05HOiA2MyxcbiAgICBFTkVURE9XTjogNTAsXG4gICAgRU5FVFJFU0VUOiA1MixcbiAgICBFTkVUVU5SRUFDSDogNTEsXG4gICAgRU5GSUxFOiAyMyxcbiAgICBFTk9CVUZTOiA1NSxcbiAgICBFTk9EQVRBOiA5NixcbiAgICBFTk9ERVY6IDE5LFxuICAgIEVOT0VOVDogMixcbiAgICBFTk9FWEVDOiA4LFxuICAgIEVOT0xDSzogNzcsXG4gICAgRU5PTElOSzogOTcsXG4gICAgRU5PTUVNOiAxMixcbiAgICBFTk9NU0c6IDkxLFxuICAgIEVOT1BST1RPT1BUOiA0MixcbiAgICBFTk9TUEM6IDI4LFxuICAgIEVOT1NSOiA5OCxcbiAgICBFTk9TVFI6IDk5LFxuICAgIEVOT1NZUzogNzgsXG4gICAgRU5PVENPTk46IDU3LFxuICAgIEVOT1RESVI6IDIwLFxuICAgIEVOT1RFTVBUWTogNjYsXG4gICAgRU5PVFNPQ0s6IDM4LFxuICAgIEVOT1RTVVA6IDQ1LFxuICAgIEVOT1RUWTogMjUsXG4gICAgRU5YSU86IDYsXG4gICAgRU9QTk9UU1VQUDogMTAyLFxuICAgIEVPVkVSRkxPVzogODQsXG4gICAgRVBFUk06IDEsXG4gICAgRVBJUEU6IDMyLFxuICAgIEVQUk9UTzogMTAwLFxuICAgIEVQUk9UT05PU1VQUE9SVDogNDMsXG4gICAgRVBST1RPVFlQRTogNDEsXG4gICAgRVJBTkdFOiAzNCxcbiAgICBFUk9GUzogMzAsXG4gICAgRVNQSVBFOiAyOSxcbiAgICBFU1JDSDogMyxcbiAgICBFU1RBTEU6IDcwLFxuICAgIEVUSU1FOiAxMDEsXG4gICAgRVRJTUVET1VUOiA2MCxcbiAgICBFVFhUQlNZOiAyNixcbiAgICBFV09VTERCTE9DSzogMzUsXG4gICAgRVhERVY6IDE4XG4gIH0sXG4gIHNpZ25hbHM6IHtcbiAgICBTSUdIVVA6IDEsXG4gICAgU0lHSU5UOiAyLFxuICAgIFNJR1FVSVQ6IDMsXG4gICAgU0lHSUxMOiA0LFxuICAgIFNJR1RSQVA6IDUsXG4gICAgU0lHQUJSVDogNixcbiAgICBTSUdJT1Q6IDYsXG4gICAgU0lHQlVTOiAxMCxcbiAgICBTSUdGUEU6IDgsXG4gICAgU0lHS0lMTDogOSxcbiAgICBTSUdVU1IxOiAzMCxcbiAgICBTSUdTRUdWOiAxMSxcbiAgICBTSUdVU1IyOiAzMSxcbiAgICBTSUdQSVBFOiAxMyxcbiAgICBTSUdBTFJNOiAxNCxcbiAgICBTSUdURVJNOiAxNSxcbiAgICBTSUdDSExEOiAyMCxcbiAgICBTSUdDT05UOiAxOSxcbiAgICBTSUdTVE9QOiAxNyxcbiAgICBTSUdUU1RQOiAxOCxcbiAgICBTSUdUVElOOiAyMSxcbiAgICBTSUdUVE9VOiAyMixcbiAgICBTSUdVUkc6IDE2LFxuICAgIFNJR1hDUFU6IDI0LFxuICAgIFNJR1hGU1o6IDI1LFxuICAgIFNJR1ZUQUxSTTogMjYsXG4gICAgU0lHUFJPRjogMjcsXG4gICAgU0lHV0lOQ0g6IDI4LFxuICAgIFNJR0lPOiAyMyxcbiAgICBTSUdJTkZPOiAyOSxcbiAgICBTSUdTWVM6IDEyXG4gIH0sXG4gIHByaW9yaXR5OiB7XG4gICAgUFJJT1JJVFlfTE9XOiAxOSxcbiAgICBQUklPUklUWV9CRUxPV19OT1JNQUw6IDEwLFxuICAgIFBSSU9SSVRZX05PUk1BTDogMCxcbiAgICBQUklPUklUWV9BQk9WRV9OT1JNQUw6IC03LFxuICAgIFBSSU9SSVRZX0hJR0g6IC0xNCxcbiAgICBQUklPUklUWV9ISUdIRVNUOiAtMjBcbiAgfVxufTsgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnNcblxuY29uc3QgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6ICgpID0+IHByb2Nlc3MuYXJjaCxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gVGkuUGxhdGZvcm0ucHJvY2Vzc29yQ291bnQ7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiAndW5rbm93bicsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICB0aW1lczoge1xuICAgICAgICAgIHVzZXI6IDAsXG4gICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICBzeXM6IDAsXG4gICAgICAgICAgaWRsZTogMCxcbiAgICAgICAgICBpcnE6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBlbmRpYW5uZXNzOiAoKSA9PiB7XG4gICAgLy8gVE9ETzogQ2FjaGUgdGhlIHZhbHVlIVxuICAgIGNvbnN0IHJlc3VsdCA9IFRpLkNvZGVjLmdldE5hdGl2ZUJ5dGVPcmRlcigpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gVGkuQ29kZWMuTElUVExFX0VORElBTikge1xuICAgICAgcmV0dXJuICdMRSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdCRSc7XG4gIH0sXG4gIGZyZWVtZW06ICgpID0+IFRpLlBsYXRmb3JtLmF2YWlsYWJsZU1lbW9yeSxcbiAgZ2V0UHJpb3JpdHk6ICgpID0+IDAsXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6ICgpID0+IFRpLlBsYXRmb3JtLmFkZHJlc3MsXG4gIC8vIGZha2UgaXRcbiAgbG9hZGF2ZzogKCkgPT4gWzAsIDAsIDBdLFxuICAvLyBmYWtlIGl0XG4gIG5ldHdvcmtJbnRlcmZhY2VzOiAoKSA9PiB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgcmVsZWFzZTogKCkgPT4gVGkuUGxhdGZvcm0udmVyc2lvbixcbiAgc2V0UHJpb3JpdHk6ICgpID0+IHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRtcGRpcigpYCBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtJ3MgZGVmYXVsdCBkaXJlY3RvcnkgZm9yIHRlbXBvcmFyeSBmaWxlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0bXBkaXI6ICgpID0+IFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSxcblxuICAvKipcbiAgICogVGhlIGBvcy50b3RhbG1lbSgpYCBtZXRob2QgcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIHN5c3RlbSBtZW1vcnkgaW4gYnl0ZXMgYXMgYW4gaW50ZWdlci5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG90YWxtZW06ICgpID0+IFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5LFxuICB0eXBlOiAoKSA9PiAnVW5rbm93bicsXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS51cHRpbWUsXG4gIHVzZXJJbmZvOiAoKSA9PiB7XG4gICAgLy8gZmFrZSBpdCFcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiAtMSxcbiAgICAgIGdpZDogLTEsXG4gICAgICB1c2VybmFtZTogVGkuUGxhdGZvcm0udXNlcm5hbWUsXG4gICAgICBob21lZGlyOiBUaS5GaWxlc3lzdGVtLmFwcGxpY2F0aW9uRGF0YURpcmVjdG9yeSxcbiAgICAgIHNoZWxsOiBudWxsXG4gICAgfTtcbiAgfVxufTsgLy8gT24gc3BlY2lmaWMgcGxhdGZvcm1zLCBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbnMgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoZW1cbi8vIHlldCBhbmQgbmVlZCB0byBmYWtlIGl0LCBvciB0byBoYWNrIHRoZW1cbi8vIEknbSBhbHNvIGRvaW5nIHRoaXMgaW4gYmxvY2tzIHRvIGFzc2lnbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCBkb24ndCBuZWVkIHRvIGNvbnN1bHQgcGxhdGZvcm1cbi8vIHR5cGUgYXQgcnVudGltZSAoaG9wZWZ1bGx5IHNwZWVkaW5nIHVwIGV4ZWN1dGlvbiBhdCBydW50aW1lKVxuXG57XG4gIE9TLmNwdXMgPSAoKSA9PiBUaS5QbGF0Zm9ybS5jcHVzKCk7XG5cbiAgT1MudHlwZSA9ICgpID0+ICdMaW51eCc7XG59XG5cbmNvbnN0IHR0eSA9IHtcbiAgaXNhdHR5OiAoKSA9PiBmYWxzZSxcbiAgUmVhZFN0cmVhbTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIFdyaXRlU3RyZWFtOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dHkuV3JpdGVTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IE1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbmNvbnN0IHV0aWwgPSB7XG4gIGZvcm1hdDogZm9ybWF0JDEsXG4gIGZvcm1hdFdpdGhPcHRpb25zLFxuICBpbnNwZWN0LFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICBpc0Jvb2xlYW46IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBpc0J1ZmZlcjogQnVmZmVyTW9kdWxlLkJ1ZmZlci5pc0J1ZmZlcixcbiAgaXNGdW5jdGlvbjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nLFxuICBpc051bGw6IHZhbHVlID0+IHZhbHVlID09PSBudWxsLFxuICBpc051bGxPclVuZGVmaW5lZDogdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNOdW1iZXI6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGlzT2JqZWN0OiB2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICBpc1ByaW1pdGl2ZTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGwsXG4gIGlzU3RyaW5nOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICBpc1N5bWJvbDogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyxcbiAgaXNVbmRlZmluZWQ6IHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRXJyb3I6IGUgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcixcbiAgbG9nOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWUgPSBgJHtkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDsgLy8gUHJvZHVjZXMgb3V0cHV0IGxpa2U6IFwiMjEgRmViIDEwOjA0OjIzIC0gbWVzc2FnZVwiXG5cbiAgICBjb25zb2xlLmxvZyhgJHtkYXRlLmdldERhdGUoKX0gJHtNT05USFNbZGF0ZS5nZXRNb250aCgpXX0gJHt0aW1lfSAtICR7c3RyaW5nfWApO1xuICB9LFxuICBwcmludDogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignJykpLFxuICAvLyBGSVhNRTogU2hvdWxkbid0IGFkZCB0cmFpbGluZyBuZXdsaW5lIGxpa2UgY29uc29sZS5sb2cgZG9lcyFcbiAgcHV0czogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignXFxuJykpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSksXG4gIGRlYnVnOiBzdHJpbmcgPT4gY29uc29sZS5lcnJvcihgREVCVUc6ICR7c3RyaW5nfWApLFxuICB0eXBlc1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3Igc3ViY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3IgYmFzZSBjbGFzc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gd3JhcCB3aGljaCBpcyBleHBlY3RlZCB0byBoYXZlIGEgZmluYWwgY2FsbGJhY2sgYXJndW1lbnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuICovXG5cblxudXRpbC5wcm9taXNpZnkgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKG9yaWdpbmFsLCAnb3JpZ2luYWwnLCAnRnVuY3Rpb24nKTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCAuLi5hcmdzLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcblxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGFzeW5jL1Byb21pc2UgcmV0dXJuIHZhbHVlIHRvIGEgY2FsbGJhY2sgc3R5bGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICovXG5cblxudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcHJvbWlzZS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG4gICAgICAgIHdyYXBwZWRFcnJvci5yZWFzb24gPSBlcnI7XG4gICAgICAgIGVyciA9IHdyYXBwZWRFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBkZXByZWNhdGUvd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBtZXNzYWdlIHRvIGdpdmUgd2hlbiBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGRlcHJlY2F0aW9uIGNvZGUgdG8gdXNlIHRvIGdyb3VwIHdhcm5pbmdzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuXG5cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH0gLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG5cblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhzdHJpbmcsICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZDtcbn07IC8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cblxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbnV0aWwuZGVidWdsb2cgPSAoKSA9PiB7XG4gIHJldHVybiBub29wO1xufTtcblxuY29uc3QgREVGQVVMVF9NRVNTQUdFUyA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86J1xufTsgLy8gRmFrZSBlbnVtcyB0byB1c2UgaW50ZXJuYWxseVxuXG5jb25zdCBDT01QQVJFX1RZUEUgPSB7XG4gIE9iamVjdDogMCxcbiAgTWFwOiAxLFxuICBTZXQ6IDJcbn07XG5jb25zdCBTVFJJQ1RORVNTID0ge1xuICBTdHJpY3Q6IDAsXG4gIExvb3NlOiAxXG59O1xuXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCB7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvclxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBGSVhNRTogR2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIG1lc3NhZ2Ugd2l0aCBkaWZmIG9mIGFjdHVhbC9leHBlY3RlZCFcbiAgICAgIG1lc3NhZ2UgPSBgJHtERUZBVUxUX01FU1NBR0VTW29wZXJhdG9yXX1cXG5cXG5gO1xuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXSc7XG4gICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICB9XG5cbn0gLy8gVE9ETzogQ2FuIHdlIGRlZmluZSBBc3NlcnRTdHJpY3QgYW5kIEFzc2VydExvb3NlIGFzIHN1YmNsYXNzZXMgb2YgYSBiYXNlIEFzc2VydCBjbGFzc1xuLy8gdGhhdCBjbGFzcyBob2xkcyBpbXBscyBmb3Igc2hhcmVkIG1ldGhvZHMsIHN1YmNsYXNzZXMgb3ZlcnJpZGUgc3BlY2lmaWNcbi8vIGNvbXBhcmlzb25zIHVzZWQgKE9iamVjdC5pcyB2cyA9PT0pP1xuXG5cbmNvbnN0IGFzc2VydCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmFzc2VydC5vayA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXJnc1swXTtcblxuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbWVzc2FnZSA9IGFyZ3NbMV07XG4gIGxldCBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7IC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIC8vIFRPRE86IGdlbmVyYXRlIHJlc3Qgb2YgdGhlIG1lc3NhZ2UuIE5vZGUgYWN0dWFsbHkgcmVhZHMgdGhlIGlucHV0IGZpbGUhIFRoZSBoYWNrZWQgYnJvd3NlcmlmeSBkb2VzIG5vdCBkbyB0aGlzXG4gICAgLy8gSXQgdHJlYXRlcyBvayBmYWlsaW5nIGxpa2UgYHZhbHVlID09IHRydWVgIGZhaWxpbmdcbiAgICBtZXNzYWdlID0gJ1RoZSBleHByZXNzaW9uIGV2YWx1YXRlZCB0byBhIGZhbHN5IHZhbHVlOlxcblxcbic7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0IGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnPT0nXG4gIH0pO1xuICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Iob2JqKSB7XG4gIC8vIElmIG1lc3NhZ2UgaXMgYW4gRXJyb3Igb2JqZWN0LCB0aHJvdyB0aGF0IGluc3RlYWQhXG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIH1cblxuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdlcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQubm90RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdEVxdWFsJ1xuICB9KTtcbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5jb25zdCBpc1ByaW1pdGl2ZSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlID09PSBudWxsO1xufTtcbi8qKlxuICogQHBhcmFtIHtNYXB9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtNYXB9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZU1hcHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykge1xuICBjb25zdCBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiBvYmplY3RzIHdlIG5lZWQgdG8gdGVzdCBtb3JlIGV4dGVuc2l2ZWx5IHRoYW4gdXNpbmcgI2dldCgpLyNoYXMoKVxuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGdldCgpL2hhcygpXG4gICAgICBsb29zZUNoZWNrcy5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFuZGxlIFwicHJpbWl0aXZlc1wiXG4gICAgICBpZiAoZXhwZWN0ZWQuaGFzKGtleSkgJiYgZGVlcEVxdWFsKHZhbHVlLCBleHBlY3RlZC5nZXQoa2V5KSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgLy8geWF5ISBhIG5pY2UgZWFzeSBtYXRjaCAtIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVkIGV4YWN0bHkgLSBtb3ZlIG9uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgaW4gc3RyaWN0IG1vZGUsIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIG9rLCBzbyBpdCBkaWRuJ3QgbWF0Y2gga2V5L3ZhbHVlIHBlcmZlY3RseSAtIGJ1dCB3ZSdyZSBpbiBsb29zZSBtb2RlLCBzbyBmYWxsIGJhY2sgdG8gdHJ5IGFnYWluXG5cblxuICAgICAgbG9vc2VDaGVja3MuYWRkKGtleSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgTWFwIG9uY2UhXG5cblxuICBmb3IgKGNvbnN0IFtleHBlY3RlZEtleSwgZXhwZWN0ZWRWYWx1ZV0gb2YgZXhwZWN0ZWQpIHtcbiAgICAvLyBpZiBpdCdzIG5vdCBhIG5vbi1udWxsIG9iamVjdCBpbiBzdHJpY3QgbW9kZSwgZmFpbCFcbiAgICAvLyAoaS5lLiBpZiBpdCdzIGEgcHJpbWl0aXZlIHRoYXQgZmFpbGVkIGEgbWF0Y2gsIGRvbid0IGZhbGwgYmFjayB0byBtb3JlIGxvb3NlbHkgbWF0Y2ggaXQpXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkbid0IGV2ZXIgaGFwcGVuIHNpbmNlIHdlIHNob3VsZCBiZSByZXR1cm5pbmcgZmFsc2UgaW1tZWRpYXRlbHkgYWJvdmVcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QgJiYgISh0eXBlb2YgZXhwZWN0ZWRLZXkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkS2V5ICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCB0ZXN0IGl0IC8vIFRPRE86IFdpc2ggd2UgY291bGQgdXNlICNmaW5kKCkgbGlrZSBvbiBhbiBBcnJheSwgYnV0IFNldCBkb2Vzbid0IGhhdmUgaXQhXG5cblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgbG9vc2VDaGVja3MpIHtcbiAgICAgIC8vIGlmIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVzXG4gICAgICBpZiAoZGVlcEVxdWFsKGtleSwgZXhwZWN0ZWRLZXksIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpICYmIGRlZXBFcXVhbChhY3R1YWwuZ2V0KGtleSksIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKGtleSk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgYWxyZWFkeSBtYXRjaGVkIGl0XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuXG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIGRpZCB3ZSBsZWF2ZSB1bi1tYXRjaGVkIGtleXM/IGlmIHNvLCBmYWlsXG5cblxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cbi8qKlxuICogQHBhcmFtIHtTZXR9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtTZXR9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtzdHJpY3RuZXNzLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykge1xuICBjb25zdCBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiB2YWx1ZXMgd2UgbmVlZCB0byB0ZXN0IG1vcmUgZXh0ZW5zaXZlbHkgdGhhbiB1c2luZyAjaGFzKClcblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBub24tbnVsbCBvYmplY3QuIFdlIG5lZWQgdG8gZG8gb3VyIG93biBjaGVja2luZywgbm90IHVzZSBoYXMoKVxuICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFleHBlY3RlZC5oYXModmFsdWUpKSB7XG4gICAgICAvLyBGSVhNRTogaGFzIGRvZXMgXCJzYW1lLXZhbHVlLXplcm9cIiBjaGVjaywgd2hpY2ggaXMgbGlrZSBPYmplY3QuaXMgZXhjZXB0IGZvciAtMC8rMCBiZWluZyBjb25zaWRlcmVkIGVxdWFsXG4gICAgICAvLyBzbyBtYXkgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhhdCBoZXJlLCB0aGF0J2QgaGF2ZSB0byBiZSBpbiBhbiBlbHNlIGJlbG93IChzaW5jZSBoYXMgd2lsbCByZXR1cm4gdHJ1ZSBoZXJlKVxuICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgIC8vIGZhaWxlZCBcInNhbWUtdmFsdWVcIiBtYXRjaCBmb3IgcHJpbWl0aXZlIGluIHN0cmljdCBtb2RlLCBzbyBmYWlsIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBXaGVuIGRvaW5nIGxvb3NlIGNoZWNrLCB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byBsb29zZXIgY2hlY2sgdGhhbiAjaGFzKCksIHNvIHdlIGNhbid0IGp1c3QgcmV0dXJuIGZhbHNlIGltbWVkaWF0ZWx5IGhlcmVcbiAgICAgIC8vIGFkZCB0byBzZXQgb2YgdmFsdWVzIHRvIGNoZWNrIG1vcmUgdGhvcm91Z2hseVxuXG5cbiAgICAgIGxvb3NlQ2hlY2tzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVHJ5IHRvIHdoaXR0bGUgZG93biB0aGUgbG9vc2UgY2hlY2tzIHNldCB0byBiZSBlbXB0eS4uLlxuICAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBTZXQgb25jZSFcblxuXG4gIGZvciAoY29uc3QgZXhwZWN0ZWRWYWx1ZSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZFZhbHVlID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgbG9vc2VDaGVja3MpIHtcbiAgICAgIGlmIChkZWVwRXF1YWwob2JqZWN0LCBleHBlY3RlZFZhbHVlLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7IC8vIGZvdW5kIGEgbWF0Y2ghXG5cbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKG9iamVjdCk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgbWF0Y2hlZCBpdFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gaWYgbm90IGZvdW5kLCB3ZSBmYWlsZWQgdG8gbWF0Y2hcblxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCB2YWx1ZXM/IGlmIHNvLCBmYWlsXG5cblxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSBhY3R1YWwgdmFsdWUgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHsqfSBleHBlY3RlZCB2YWx1ZXMgd2UncmUgY29tcGFyaW5nIGFnYWluc3RcbiAqIEBwYXJhbSB7U1RSSUNUTkVTUy5TdHJpY3R8U1RSSUNUTkVTUy5Mb29zZX0gc3RyaWN0bmVzcyBob3cgc3RyaWN0IGEgY29tcGFyaXNvbiB0byBkb1xuICogQHBhcmFtIHtvYmplY3R9IFtyZWZlcmVuY2VzXSBvcHRpb25hbCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSBoaWVyYXJjaHlcbiAqIEBwYXJhbSB7TWFwPG9iamVjdCxudW1iZXI+fSBbcmVmZXJlbmNlcy5hY3R1YWxdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBhY3R1YWxgKSB0byB0aGVpciBkZXB0aFxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmV4cGVjdGVkXSBtYXBwaW5nIGZyb20gb2JqZWN0cyB2aXNpdGVkIChvbiBgZXhwZWN0ZWRgKSB0byB0aGVpciBkZXB0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtyZWZlcmVuY2VzLmRlcHRoXSBUaGUgY3VycmVudCBkZXB0aCBvZiB0aGUgaGllcmFyY2h5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIC8vIGlmIHByaW1pdGl2ZXMsIGNvbXBhcmUgdXNpbmcgT2JqZWN0LmlzXG4gIC8vIFRoaXMgaGFuZGxlczogbnVsbCwgdW5kZWZpbmVkLCBudW1iZXIsIHN0cmluZywgYm9vbGVhblxuICBpZiAoaXNQcmltaXRpdmUoYWN0dWFsKSAmJiBpc1ByaW1pdGl2ZShleHBlY3RlZCkpIHtcbiAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgfVxuICB9IC8vIE5vdyB3ZSBoYXZlIHZhcmlvdXMgb2JqZWN0cy9mdW5jdGlvbnM6XG4gIC8vIERhdGUsIEVycm9yLCBSZWdFeHAsIEFycmF5LCBNYXAsIFNldCwgT2JqZWN0LCBGdW5jdGlvbiwgQXJyb3cgZnVuY3Rpb25zLCBXZWFrTWFwLCBEYXRhVmlldywgQXJyYXlCdWZmZXIsIFdlYWtTZXQsIHR5cGVkIGFycmF5c1xuICAvLyBub3RhYmx5LCB0aGlzIGluY2x1ZGVzIFwiYm94ZWRcIiBwcmltaXRpdmVzIGNyZWF0ZWQgYnkgbmV3IEJvb2xlYW4oZmFsc2UpLCBuZXcgU3RyaW5nKCd2YWx1ZScpLCBTeW1ib2woJ3doYXRldmVyJyksIGV0Y1xuICAvLyBUeXBlIHRhZ3Mgb2Ygb2JqZWN0cyBzaG91bGQgYmUgdGhlIHNhbWVcblxuXG4gIGNvbnN0IGFjdHVhbFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhY3R1YWwpO1xuICBjb25zdCBleHBlY3RlZFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCk7XG5cbiAgaWYgKGFjdHVhbFRhZyAhPT0gZXhwZWN0ZWRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gW1tQcm90b3R5cGVdXSBvZiBvYmplY3RzIGFyZSBjb21wYXJlZCB1c2luZyB0aGUgU3RyaWN0IEVxdWFsaXR5IENvbXBhcmlzb24uXG5cblxuICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAvLyBkb24ndCBjaGVjayBwcm90b3R5cGUgd2hlbiBkb2luZyBcImxvb3NlXCJcbiAgICBjb25zdCBhY3R1YWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZCk7XG5cbiAgICBpZiAoYWN0dWFsUHJvdG90eXBlICE9PSBleHBlY3RlZFByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk9iamVjdDtcblxuICBpZiAodXRpbC50eXBlcy5pc1JlZ0V4cChhY3R1YWwpKSB7XG4gICAgLy8gUmVnRXhwIHNvdXJjZSBhbmQgZmxhZ3Mgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSB8fCBhY3R1YWwuZmxhZ3MgIT09IGV4cGVjdGVkLmZsYWdzIHx8IGFjdHVhbC5zb3VyY2UgIT09IGV4cGVjdGVkLnNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0RhdGUoYWN0dWFsKSkge1xuICAgIC8vIERhdGUncyB1bmRlcmx5aW5nIHRpbWUgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzRGF0ZShleHBlY3RlZCkgfHwgYWN0dWFsLmdldFRpbWUoKSAhPT0gZXhwZWN0ZWQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIEVycm9yJ3MgbmFtZSBhbmQgbWVzc2FnZSBtdXN0IG1hdGNoXG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikgfHwgYWN0dWFsLm5hbWUgIT09IGV4cGVjdGVkLm5hbWUgfHwgYWN0dWFsLm1lc3NhZ2UgIT09IGV4cGVjdGVkLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSkge1xuICAgIC8vIGlmIGFycmF5IGxlbmd0aHMgZGlmZmVyLCBxdWljayBmYWlsXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSB8fCBhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayB0aGF0IHRoZXkncmUgdGhlIHNhbWUgdHlwZSBvZiB3cmFwcGVkIHByaW1pdGl2ZSBhbmQgdGhlbiBjYWxsIHRoZSByZWxldmFudCB2YWx1ZU9mKCkgZm9yIHRoYXQgdHlwZSB0byBjb21wYXJlIHRoZW0hXG5cblxuICAgIGlmICh1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGV4cGVjdGVkKSB8fCAhT2JqZWN0LmlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGV4cGVjdGVkKSB8fCBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoZXhwZWN0ZWQpIHx8IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGSVhNRTogVW5jb21tZW50IHdoZW4gd2Ugc3VwcG9ydCBCaWdJbnQgY3Jvc3MtcGxhdGZvcm0hXG4gICAgICAvLyB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoYWN0dWFsKVxuICAgICAgLy8gXHQmJiAoIXV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoZXhwZWN0ZWQpXG4gICAgICAvLyBcdFx0fHwgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgLy8gXHRyZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGV4cGVjdGVkKSB8fCBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU2V0KGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNTZXQoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5TZXQ7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzTWFwKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNNYXAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5NYXA7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSAvLyBOb3cgaXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgYW5kIGNvbXBhcmUgdGhlbSFcblxuXG4gIGNvbnN0IGFjdHVhbEtleXMgPSBPYmplY3Qua2V5cyhhY3R1YWwpOyAvLyBmb3IgYW4gYXJyYXksIHRoaXMgd2lsbCByZXR1cm4gdGhlIGluZGljZXMgdGhhdCBoYXZlIHZhbHVlc1xuXG4gIGNvbnN0IGV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gYW5kIGl0IGp1c3QgbWFnaWNhbGx5IHdvcmtzXG4gIC8vIE11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG5cbiAgaWYgKGFjdHVhbEtleXMubGVuZ3RoICE9PSBleHBlY3RlZEtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEFyZSB0aGV5IHRoZSBzYW1lIGtleXM/IElmIG9uZSBpcyBtaXNzaW5nLCB0aGVuIG5vLCBmYWlsIHJpZ2h0IGF3YXlcblxuXG4gIGlmICghYWN0dWFsS2V5cy5ldmVyeShrZXkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cGVjdGVkLCBrZXkpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBEb24ndCBjaGVjayBvd24gc3ltYm9scyB3aGVuIGRvaW5nIFwibG9vc2VcIlxuXG5cbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgY29uc3QgYWN0dWFsU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV4cGVjdGVkKTsgLy8gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHN5bWJvbHNcblxuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCAhPT0gZXhwZWN0ZWRTeW1ib2xzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEhhdmUgdG8gZmlsdGVyIHRoZW0gZG93biB0byBlbnVtZXJhYmxlIHN5bWJvbHMhXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY3R1YWxTeW1ib2xzKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhY3R1YWwsIGtleSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGV4cGVjdGVkLCBrZXkpO1xuXG4gICAgICAgIGlmIChhY3R1YWxJc0VudW1lcmFibGUgIT09IGV4cGVjdGVkSXNFbnVtZXJhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0aGV5IGRpZmZlciBvbiB3aGV0ZWhyIHN5bWJvbCBpcyBlbnVtZXJhYmxlLCBmYWlsIVxuICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbElzRW51bWVyYWJsZSkge1xuICAgICAgICAgIC8vIGl0J3MgZW51bWVyYWJsZSwgYWRkIHRvIGtleXMgdG8gY2hlY2tcbiAgICAgICAgICBhY3R1YWxLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBleHBlY3RlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMhXG4gIC8vIFJlY29yZCBtYXAgZnJvbSBvYmplY3RzIHRvIGRlcHRoIGluIHRoZSBoaWVyYXJjaHlcblxuXG4gIGlmIChyZWZlcmVuY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZWZlcmVuY2VzID0ge1xuICAgICAgYWN0dWFsOiBuZXcgTWFwKCksXG4gICAgICBleHBlY3RlZDogbmV3IE1hcCgpLFxuICAgICAgZGVwdGg6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIHRoZXNlIG9iamVjdHMuXG4gICAgLy8gaWYgc28sIG1ha2Ugc3VyZSB0aGV5IHJlZmVyIHRvIHNhbWUgZGVwdGggaW4gb2JqZWN0IGhpZXJhcmNoeVxuICAgIGNvbnN0IG1lbW9pemVkQWN0dWFsID0gcmVmZXJlbmNlcy5hY3R1YWwuZ2V0KGFjdHVhbCk7XG5cbiAgICBpZiAobWVtb2l6ZWRBY3R1YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWVtb2l6ZWRFeHBlY3RlZCA9IHJlZmVyZW5jZXMuZXhwZWN0ZWQuZ2V0KGV4cGVjdGVkKTtcblxuICAgICAgaWYgKG1lbW9pemVkRXhwZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWRBY3R1YWwgPT09IG1lbW9pemVkRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmZXJlbmNlcy5kZXB0aCsrO1xuICB9IC8vIHN0b3JlIHRoZSBvYmplY3QgLT4gZGVwdGggbWFwcGluZ1xuXG5cbiAgcmVmZXJlbmNlcy5hY3R1YWwuc2V0KGFjdHVhbCwgcmVmZXJlbmNlcy5kZXB0aCk7XG4gIHJlZmVyZW5jZXMuZXhwZWN0ZWQuc2V0KGV4cGVjdGVkLCByZWZlcmVuY2VzLmRlcHRoKTsgLy8gV2hlbiBjb21wYXJpbmcgTWFwcy9TZXRzLCBjb21wYXJlIGVsZW1lbnRzIGJlZm9yZSBjdXN0b20gcHJvcGVydGllc1xuXG4gIGxldCByZXN1bHQgPSB0cnVlO1xuXG4gIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuU2V0KSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PT0gQ09NUEFSRV9UWVBFLk1hcCkge1xuICAgIHJlc3VsdCA9IGNvbXBhcmVNYXBzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIC8vIE5vdyBsb29wIG92ZXIga2V5cyBhbmQgY29tcGFyZSB0aGVtIHRvIGVhY2ggb3RoZXIhXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWN0dWFsS2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0sIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gd2lwZSB0aGUgb2JqZWN0IHRvIGRlcHRoIG1hcHBpbmcgZm9yIHRoZXNlIG9iamVjdHMgbm93XG5cblxuICByZWZlcmVuY2VzLmFjdHVhbC5kZWxldGUoYWN0dWFsKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5kZWxldGUoZXhwZWN0ZWQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQuZmFpbCA9IChtZXNzYWdlID0gJ0ZhaWxlZCcpID0+IHRocm93RXJyb3Ioe1xuICBtZXNzYWdlXG59KTtcblxuY29uc3QgTk9fRVhDRVBUSU9OID0ge307XG5cbmZ1bmN0aW9uIGV4ZWN1dGUoZm4pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZuLCAnZm4nLCAnRnVuY3Rpb24nKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoZm4pIHtcbiAgcmV0dXJuIHV0aWwudHlwZXMuaXNQcm9taXNlKGZuKSB8fCBmbiAmJiB0eXBlb2YgZm4gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmbi50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZShmbikge1xuICBsZXQgcHJvbWlzZTtcbiAgY29uc3QgZm5UeXBlID0gdHlwZW9mIGZuO1xuXG4gIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlID0gZm4oKTtcblxuICAgIGlmICghaXNQcm9taXNlTGlrZShwcm9taXNlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5zdGFuY2VvZiBQcm9taXNlIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFwiZm5cIiBmdW5jdGlvbiBidXQgZ290ICR7dHlwZW9mIHByb21pc2V9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNQcm9taXNlTGlrZShmbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZuXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uIG9yIFByb21pc2UuIFJlY2VpdmVkIHR5cGUgJHtmblR5cGV9YCk7XG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IGZuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OO1xufVxuXG5hc3NlcnQudGhyb3dzID0gKGZuLCBlcnJvciwgbWVzc2FnZSkgPT4ge1xuICBjb25zdCBhY3R1YWwgPSBleGVjdXRlKGZuKTtcblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3Qgcm9sbCB3aXRoIGl0XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgYWN0dWFsOyAvLyB0aHJvdyB0aGUgRXJyb3IgaXQgZGlkIGdlbmVyYXRlXG4gIH1cbn07XG5cbmFzc2VydC5yZWplY3RzID0gYXN5bmMgZnVuY3Rpb24gKGFzeW5jRm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGFjdHVhbCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlKGFzeW5jRm4pO1xuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgIG9wZXJhdG9yOiAncmVqZWN0cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3Qgcm9sbCB3aXRoIGl0XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgYWN0dWFsOyAvLyB0aHJvdyB0aGUgRXJyb3IgaXQgZGlkIGdlbmVyYXRlXG4gIH1cbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pOyAvLyBubyBFcnJvciwganVzdCByZXR1cm5cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3QgcmUtdGhyb3dcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH0gLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcblxuXG4gIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogJ2RvZXNOb3RUaHJvdycsXG4gICAgICBtZXNzYWdlOiBgR290IHVud2FudGVkIGV4Y2VwdGlvbiR7bWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nfWBcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gZG9lc24ndCBtYXRjaCwgcmUtdGhyb3dcblxuXG4gIHRocm93IGFjdHVhbDtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gYXN5bmMgZnVuY3Rpb24gKGZuLCBlcnJvciwgbWVzc2FnZSkge1xuICBjb25zdCBhY3R1YWwgPSBhd2FpdCBleGVjdXRlUHJvbWlzZShmbik7IC8vIG5vIEVycm9yLCBqdXN0IHJldHVyblxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIHJldHVybjtcbiAgfSAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByZS10aHJvd1xuXG5cbiAgaWYgKCFlcnJvcikge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfSAvLyBJZiBlcnJvciBtYXRjaGVzIGV4cGVjdGVkLCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuXG5cbiAgaWYgKGNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvcikpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiAnZG9lc05vdFRocm93JyxcbiAgICAgIG1lc3NhZ2U6IGBHb3QgdW53YW50ZWQgZXhjZXB0aW9uJHttZXNzYWdlID8gJzogJyArIG1lc3NhZ2UgOiAnLid9YFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuXG5cbiAgdGhyb3cgYWN0dWFsO1xufTtcbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gYWN0dWFsIHRoZSBhY3R1YWwgRXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uL2Jsb2NrXG4gKiBAcGFyYW0ge29iamVjdHxSZWdFeHB8RnVuY3Rpb258RXJyb3J8Q2xhc3N9IGV4cGVjdGVkIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QgdGhlIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGN1c3RvbSBtZXNzYWdlIHRvIGFwcGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIEVycm9yIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHZhbHVlL29iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tFcnJvcihhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIC8vIFdoYXQgd2UgZG8gaGVyZSBkZXBlbmRzIG9uIHdoYXQgYGV4cGVjdGVkYCBpczpcbiAgLy8gZnVuY3Rpb24gLSBjYWxsIGl0IHRvIHZhbGlkYXRlXG4gIC8vIG9iamVjdCAtIHRlc3QgcHJvcGVydGllcyBhZ2FpbnN0IGFjdHVhbFxuICAvLyBSZWdleHAgLSB0ZXN0IGFnYWluc3QgYWN0dWFsLnRvU3RyaW5nKClcbiAgLy8gRXJyb3IgdHlwZSAtIGNoZWNrIHR5cGUgbWF0Y2hlc1xuICAvLyBFcnJvciBpbnN0YW5jZSAtIGNvbXBhcmUgcHJvcGVydGllc1xuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gZG9lcyB0aGUgZXJyb3IgbWF0Y2ggdGhlIFJlZ0V4cCBleHByZXNzaW9uPyBpZiBzbywgcGFzc1xuICAgIH0gLy8gVGVzdCBwcm9wZXJ0aWVzIChgZXhwZWN0ZWRgIGlzIGVpdGhlciBhIGdlbmVyaWMgT2JqZWN0IG9yIGFuIEVycm9yIGluc3RhbmNlKVxuXG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBJZiB3ZSdyZSB0ZXN0aW5nIGFnYWluc3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIHdlIG5lZWQgdG8gaGFjayBpbiBuYW1lL21lc3NhZ2UgcHJvcGVydGllcy5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnVuc2hpZnQoJ25hbWUnLCAnbWVzc2FnZScpOyAvLyB3ZSB3YW50IHRvIGNvbXBhcmUgbmFtZSBhbmQgbWVzc2FnZSwgYnV0IHRoZXkncmUgbm90IHNldCBhcyBlbnVtZXJhYmxlIG9uIEVycm9yXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0sIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBnZW5lcmF0ZSBhIG1lYW5pbmdmdWwgbWVzc2FnZSEgQ2hlYXQgYnkgdHJlYXRpbmcgbGlrZSBlcXVhbGl0eSBjaGVjayBvZiB2YWx1ZXNcbiAgICAgICAgICAvLyB0aGVuIHN0ZWFsIHRoZSBtZXNzYWdlIGl0IGdlbmVyYXRlZFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWxba2V5XSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkW2tleV0sXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcih7XG4gICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgb3BlcmF0b3I6ICd0aHJvd3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7IC8vIFRoZXkgYWxsIG1hdGNoZWQsIHBhc3MhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaWYgYGV4cGVjdGVkYCBpcyBhIFwidHlwZVwiIGFuZCBhY3R1YWwgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB0eXBlLCB0aGVuIHBhc3NcbiAgICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9IG51bGwgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gSWYgYGV4cGVjdGVkYCBpcyBhIHN1YmNsYXNzIG9mIEVycm9yIGJ1dCBgYWN0dWFsYCB3YXNuJ3QgYW4gaW5zdGFuY2Ugb2YgaXQgKGFib3ZlKSwgZmFpbFxuXG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoRXJyb3IsIGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gb2ssIGxldCdzIGFzc3VtZSB3aGF0J3MgbGVmdCBpcyB0aGF0IGBleHBlY3RlZGAgd2FzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbixcbiAgICAvLyBzbyBjYWxsIGl0IHdpdGggZW1wdHkgYHRoaXNgIGFuZCBzaW5nbGUgYXJndW1lbnQgb2YgdGhlIGFjdHVhbCBlcnJvciB3ZSByZWNlaXZlZFxuXG5cbiAgICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuYXNzZXJ0LmlmRXJyb3IgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogbnVsbCxcbiAgICBtZXNzYWdlOiBgaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAke3ZhbHVlfWAsXG4gICAgb3BlcmF0b3I6ICdpZkVycm9yJ1xuICB9KTtcbn07IC8vIENyZWF0ZSBcInN0cmljdFwiIGNvcHkgd2hpY2ggb3ZlcnJpZGVzIFwibG9vc2VcIiBtZXRob2RzIHRvIGNhbGwgc3RyaWN0IGVxdWl2YWxlbnRzXG5cblxuYXNzZXJ0LnN0cmljdCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTsgLy8gXCJDb3B5XCIgbWV0aG9kcyBmcm9tIGFzc2VydCB0byBhc3NlcnQuc3RyaWN0IVxuXG5cbk9iamVjdC5hc3NpZ24oYXNzZXJ0LnN0cmljdCwgYXNzZXJ0KTsgLy8gT3ZlcnJpZGUgdGhlIFwibG9vc2VcIiBtZXRob2RzIHRvIHBvaW50IHRvIHRoZSBzdHJpY3Qgb25lc1xuXG5hc3NlcnQuc3RyaWN0LmRlZXBFcXVhbCA9IGFzc2VydC5kZWVwU3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0Lm5vdERlZXBFcXVhbCA9IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0LmVxdWFsID0gYXNzZXJ0LnN0cmljdEVxdWFsO1xuYXNzZXJ0LnN0cmljdC5ub3RFcXVhbCA9IGFzc2VydC5ub3RTdHJpY3RFcXVhbDsgLy8gaGFuZyBzdHJpY3Qgb2ZmIGl0c2VsZlxuXG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgdGhlIGBTdHJpbmdEZWNvZGVyYCB3aWxsIHVzZS5cbiAqL1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZyA9ICd1dGY4Jykge1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFV0ZjhTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFV0ZjE2U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy5faW1wbCA9IG5ldyBCYXNlNjRTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFN0cmluZ0RlY29kZXJJbXBsKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyBhbnkgcmVtYWluaW5nIGlucHV0IHN0b3JlZCBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICogQnl0ZXMgcmVwcmVzZW50aW5nIGluY29tcGxldGUgVVRGLTggYW5kIFVURi0xNiBjaGFyYWN0ZXJzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzdWJzdGl0dXRpb25cbiAqIGNoYXJhY3RlcnMgYXBwcm9wcmlhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcuXG4gKlxuICogSWYgdGhlIGJ1ZmZlciBhcmd1bWVudCBpcyBwcm92aWRlZCwgb25lIGZpbmFsIGNhbGwgdG8gc3RyaW5nRGVjb2Rlci53cml0ZSgpIGlzIHBlcmZvcm1lZCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZW1haW5pbmcgaW5wdXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gW2J1ZmZlcl0gY29udGFpbmluZyB0aGUgYnl0ZXMgdG8gZGVjb2RlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2ltcGwuZW5kKGJ1ZmZlcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlZCBzdHJpbmcsIGVuc3VyaW5nIHRoYXQgYW55IGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlcnMgYXQgdGhlIGVuZCBvZiB0aGUgQnVmZmVyLCBvclxuICogVHlwZWRBcnJheSwgb3IgRGF0YVZpZXcgYXJlIG9taXR0ZWQgZnJvbSB0aGUgcmV0dXJuZWQgc3RyaW5nIGFuZCBzdG9yZWQgaW4gYW4gaW50ZXJuYWwgYnVmZmVyIGZvciB0aGVcbiAqIG5leHQgY2FsbCB0byBzdHJpbmdEZWNvZGVyLndyaXRlKCkgb3Igc3RyaW5nRGVjb2Rlci5lbmQoKS5cbiAqIEBwYXJhbSB7QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd9IGJ1ZmZlciBjb250YWluaW5nIHRoZSBieXRlcyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSAvLyBlbXB0eSBzdHJpbmcgZm9yIGVtcHR5IGJ1ZmZlclxuXG5cbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5faW1wbC53cml0ZShidWZmZXIpO1xufTtcbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcy4gV2Ugb3ZlcnJpZGUgcGFydHMgb2YgaXQgZm9yIGNlcnRhaW4gZW5jb2RpbmdzLiBGb3IgYXNjaWkvaGV4L2JpbmFyeS9sYXRpbjEgdGhlIGltcGwgaXMgc3VwZXItZWFzeVxuICovXG5cblxuY2xhc3MgU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGY4Jykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMTtcbiAgfSAvLyB0aGUgYWN0dWFsIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24hXG5cblxuICBlbmQoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShidWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHdyaXRlKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsgLy8gc2luZ2xlIGJ5dGUgY2hhcmFjdGVyIGVuY29kaW5ncyBhcmUgYSBjaW5jaFxuICAgIH1cblxuICAgIHJldHVybiAnJzsgLy8gbm8gYnVmZmVyLCBvciBlbXB0eVxuICB9XG5cbn0gLy8gRm9yIG11bHRpLWJ5dGUgZW5jb2RpbmdzLCBsZXQncyBpbXBsZW1lbnQgc29tZSBiYXNlIGxvZ2ljLi4uXG5cblxuY2xhc3MgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwgZXh0ZW5kcyBTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nLCBieXRlc1BlckNoYXIpIHtcbiAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgdGhpcy5pbmNvbXBsZXRlID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzUGVyQ2hhcik7IC8vIHRlbXBvcmFyeSBpbmNvbXBsZXRlIGNoYXJhY3RlciBidWZmZXJcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gSW5jb21wbGV0ZUNoYXJPYmplY3RcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBieXRlc05lZWRlZCBieXRlcyBtaXNzaW5nIHRvIGNvbXBsZXRlIHRoZSBjaGFyYWN0ZXJcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBjaGFyTGVuZ3RoIGJ5dGVzIGV4cGVjdGVkIHRvIGNvbXBsZXRlIHRoZSBjaGFyYWN0ZXJcbiAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBjaGFyYWN0ZXIgc3RhcnRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIEJ1ZmZlciwgc2VlcyBpZiB3ZSBoYXZlIGFuIGluY29tcGxldGUgXCJjaGFyYWN0ZXJcIiBhdCB0aGUgZW5kIG9mIGl0LlxuICAgKiBSZXR1cm5zIGluZm8gb24gdGhhdDpcbiAgICogLSBieXRlc05lZWRlZDogMC0zLCBudW1iZXIgb2YgYnl0ZXMgc3RpbGwgcmVtYWluaW5nXG4gICAqIC0gY2hhckxlbmd0aDogZXhwZWN0ZWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICogLSBpbmRleDogaW5kZXggaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYmVnaW5zXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBfYnVmZmVyIEJ1ZmZlciB3ZSBhcmUgY2hlY2tpbmcgdG8gc2VlIGlmIGl0IGhhcyBhbiBpbmNvbXBlbHRlIFwiY2hhcmFjdGVyXCIgYXQgdGhlIGVuZFxuICAgKi9cblxuXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhfYnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSEnKTtcbiAgfVxuXG4gIF9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpIHtcbiAgICAvLyB0eXBpY2FsbHkgd2UgcmVzZXQgYnl0ZSBjb3VudCBiYWNrIHRvIDAgYW5kIGNoYXJhY3RlciBsZW5ndGggdG8gMVxuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9XG5cbiAgZW5kKGJ1ZmZlcikge1xuICAgIGxldCByZXN1bHQgPSBzdXBlci5lbmQoYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmJ5dGVDb3VudCAhPT0gMCkge1xuICAgICAgLy8gd2UgaGF2ZSBpbmNvbXBsZXRlIGNoYXJhY3RlcnMhXG4gICAgICByZXN1bHQgKz0gdGhpcy5faW5jb21wbGV0ZUVuZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCk7IC8vIHJlc2V0IG91ciBpbnRlcm5hbHMgdG8gXCJ3aXBlXCIgdGhlIGluY29tcGxldGUgYnVmZmVyXG5cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB3cml0ZShidWZmZXIpIHtcbiAgICAvLyBmaXJzdCBsZXQncyBzZWUgaWYgd2UgaGFkIHNvbWUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgd2UgZGlkbid0IGZpbmlzaC4uLlxuICAgIGxldCBjaGFyID0gJyc7XG5cbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIHN0aWxsIG5lZWRlZCBzb21lIGJ5dGVzIHRvIGZpbmlzaCB0aGUgY2hhcmFjdGVyXG4gICAgICAvLyBIb3cgbWFueSBieXRlcyBkbyB3ZSBzdGlsbCBuZWVkPyBjaGFyTGVuZ3RoIC0gYnl0ZXMgd2UgcmVjZWl2ZWRcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmJ5dGVDb3VudDsgLy8gbmVlZCA0LCBoYXZlIDE/IHRoZW4gd2UgaGF2ZSAzIFwibGVmdFwiXG5cbiAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gTWF0aC5taW4obGVmdCwgYnVmZmVyLmxlbmd0aCk7IC8vIGNvcHkgdXAgdG8gdGhhdCBtYW55IGJ5dGVzXG4gICAgICAvLyBjb3B5IGJ5dGVzIGZyb20gYGJ1ZmZlcmAgdG8gb3VyIGluY29tcGxldGUgYnVmZmVyXG5cbiAgICAgIGJ1ZmZlci5jb3B5KHRoaXMuaW5jb21wbGV0ZSwgdGhpcy5ieXRlQ291bnQsIDAsIGJ5dGVzQ29waWVkKTtcbiAgICAgIHRoaXMuYnl0ZUNvdW50ICs9IGJ5dGVzQ29waWVkOyAvLyByZWNvcmQgaG93IG1hbnkgbW9yZSBieXRlcyB3ZSBjb3BpZWQuLi5cblxuICAgICAgaWYgKGJ5dGVzQ29waWVkIDwgbGVmdCkge1xuICAgICAgICAvLyBzdGlsbCBuZWVkIG1vcmUgYnl0ZXMgdG8gY29tcGxldGUhXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gLy8gd2Ugd2VyZSBhYmxlIHRvIGNvbXBsZXRlLCB5YXkhXG4gICAgICAvLyBncmFiIHRoZSBjaGFyYWN0ZXIgd2UgY29tcGxldGVkXG5cblxuICAgICAgY2hhciA9IHRoaXMuaW5jb21wbGV0ZS5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyByZXNldCBvdXIgY291bnRlcnNcblxuICAgICAgdGhpcy5faW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKTsgLy8gZG8gd2UgaGF2ZSBhbnkgYnl0ZXMgbGVmdCBpbiB0aGlzIGJ1ZmZlcj9cblxuXG4gICAgICBpZiAoYnl0ZXNDb3BpZWQgPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNoYXI7IC8vIGlmIG5vdCwgcmV0dXJuIHRoZSBjaGFyYWN0ZXIgd2UgZmluaXNoZWQhXG4gICAgICB9IC8vIHdlIHN0aWxsIGhhdmUgbW9yZSBieXRlcywgc28gc2xpY2UgdGhlIGJ1ZmZlciB1cFxuXG5cbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShieXRlc0NvcGllZCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgfSAvLyBjaGVjayB0aGlzIGJ1ZmZlciB0byBzZWUgaWYgaXQgaW5kaWNhdGVzIHdlIG5lZWQgbW9yZSBieXRlcz9cblxuXG4gICAgY29uc3QgaW5jb21wbGV0ZUNoYXJEYXRhID0gdGhpcy5fY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKTtcblxuICAgIGlmIChpbmNvbXBsZXRlQ2hhckRhdGEuYnl0ZXNOZWVkZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBubyBpbmNvbXBsZXRlIGJ5dGVzLCByZXR1cm4gYW55IGNoYXJhY3RlciB3ZSBjb21wbGV0ZWQgcGx1cyB0aGUgYnVmZmVyXG4gICAgfSAvLyBvayBzbyB0aGUgYnVmZmVyIGhvbGRzIGFuIGluY29tcGxldGUgY2hhcmFjdGVyIGF0IGl0J3MgZW5kXG5cblxuICAgIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGVDaGFyRGF0YS5jaGFyTGVuZ3RoOyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgbmVlZCBmb3IgdGhlICdjaGFyYWN0ZXInXG5cbiAgICBjb25zdCBpbmNvbXBsZXRlQ2hhckluZGV4ID0gaW5jb21wbGV0ZUNoYXJEYXRhLmluZGV4OyAvLyB0aGlzIGlzIHRoZSBpbmRleCBvZiB0aGUgbXVsdGlieXRlIGNoYXJhY3RlciB0aGF0IGlzIGluY29tcGxldGVcbiAgICAvLyBjb3B5IGZyb20gaW5kZXggb2YgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgdG8gZW5kIG9mIGJ1ZmZlclxuXG4gICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBidWZmZXIubGVuZ3RoIC0gaW5jb21wbGV0ZUNoYXJJbmRleDtcbiAgICBidWZmZXIuY29weSh0aGlzLmluY29tcGxldGUsIDAsIGluY29tcGxldGVDaGFySW5kZXgsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gYnl0ZXNUb0NvcHk7IC8vIHJlY29yZCBob3cgbWFueSBieXRlcyB3ZSBhY3R1YWxseSBjb3BpZWRcblxuICAgIGlmIChieXRlc1RvQ29weSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIGJ1ZmZlciBoYWQgYnl0ZXMgYmVmb3JlIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgICAgLy8gc28gc211c2ggYW55IGNoYXJhY3RlciB3ZSBtYXkgaGF2ZSBjb21wbGV0ZWQgd2l0aCBhbnkgY29tcGxldGUgY2hhcmFjdGVycyBpbiB0aGUgYnVmZmVyXG4gICAgICByZXR1cm4gY2hhciArIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBpbmNvbXBsZXRlQ2hhckluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcjsgLy8gYW55IG5vdy1jb21wbGV0ZWQgY2hhcmFjdGVyIHRoYXQgd2FzIHByZXZpb3VzbHkgaW5jb21wbGV0ZSwgcG9zc2libHkgZW1wdHlcbiAgfVxuXG59XG5cbmNsYXNzIFV0ZjhTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmOCcsIDQpO1xuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7IC8vIEZJWE1FOiBJbiBOb2RlLCB0aGV5IGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBmaXJzdCFcbiAgICAvLyBBbmQgdGhleSByZWx5IG9uIEJ1ZmZlciN0b1N0cmluZygpIHRvIGhhbmRsZSBpbmplY3RpbmcgdGhlICdcXHVmZmZkJyBjaGFyYWN0ZXIgZm9yIGJ1c3RlZCBtdWx0aS1ieXRlIHNlcXVlbmNlcyFcbiAgICAvLyBpT1MgYXBwYXJlbnRseSBqdXN0IHJldHVybnMgdW5kZWZpbmVkIGluIHRoYXQgc3BlY2lhbCBjYXNlIGFuZFxuICAgIC8vIEFuZHJvaWQgZGlmZmVycyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgbGFzdCBjaGFyXG4gICAgLy8gQ2FuIHdlIGNoZWF0IGhlcmUgYW5kLi4uXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvc3RyaW5nX2RlY29kZXIvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzI0wxNzMtTDE5OFxuICAgIC8vIC0gaWYgd2Ugc2VlIGEgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgc3RhcnQsIHZhbGlkYXRlIHRoZSBuZXh0IGNoYXJhY3RlcnMgYXJlIGNvbnRpbnVhdGlvbiBjaGFyc1xuICAgIC8vIC0gaWYgdGhleSdyZSBub3QgcmVwbGFjZSB0aGUgc2VxdWVuY2Ugd2l0aCAnXFx1ZmZmZCcsIHRyZWF0IGxpa2UgdGhhdCBtdWx0aS1ieXRlIGNoYXJhY3RlciB3YXMgXCJjb21wbGV0ZWRcIlxuICAgIC8vIE5vdGUgdGhhdCBldmVuIGlmIHdlIGRvIGhhY2sgdGhpcywgaWYgdGhlcmUncyBzb21lIGludmFsaWQgbXVsdGktYnl0ZSBVVEYtOCBpbiB0aGUgYnVmZmVyIHRoYXQgaXNuJ3QgYXQgdGhlIGxhc3QgMyBieXRlc1xuICAgIC8vIHRoZW4gd2UncmUgYXQgdGhlIG1lcmN5IG9mIHRoZSBKUyBlbmdpbmUvcGxhdGZvcm0gY29kZSBmb3IgaGFuZGxpbmcgdGhhdFxuICAgIC8vIEhlcmUncyBzb21lb25lJ3MgaGFjayB0aGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vb2xlZ2FuemEvOTk3MTU1XG4gICAgLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAzLCBjaGVjayAzcmQgdG8gbGFzdCBieXRlXG5cbiAgICBpZiAobGVuZ3RoID49IDMpIHtcbiAgICAgIGxldCBjaGFyTGVuZ3RoID0gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChidWZmZXJbbGVuZ3RoIC0gM10pO1xuXG4gICAgICBpZiAoY2hhckxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMyBsYXN0IGJ5dGVzLCBuZWVkIDR0aFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAzLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMiwgY2hlY2sgMm5kIHRvIGxhc3QgYnl0ZVxuXG5cbiAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgIGxldCBjaGFyTGVuZ3RoID0gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChidWZmZXJbbGVuZ3RoIC0gMl0pO1xuXG4gICAgICBpZiAoY2hhckxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IGNoYXJMZW5ndGggLSAyLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMiBieXRlcyBvZiB3aGF0ZXZlciB3ZSBuZWVkXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDIsXG4gICAgICAgICAgY2hhckxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAxLCBjaGVjayBsYXN0IGJ5dGVcblxuXG4gICAgaWYgKGxlbmd0aCA+PSAxKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDFdKTtcblxuICAgICAgaWYgKGNoYXJMZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiBjaGFyTGVuZ3RoIC0gMSxcbiAgICAgICAgICAvLyB3ZSBoYXZlIDEgYnl0ZSBvZiB3aGF0ZXZlciB3ZSBuZWVkXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDEsXG4gICAgICAgICAgY2hhckxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gYmFzZSBjYXNlLCBubyBieXRlcyBuZWVkZWQgLSBlbmRzIG9uIGNvbXBsZXRlIGNoYXJhY3RlclxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICBpbmRleDogbGVuZ3RoIC0gMSxcbiAgICAgIGNoYXJMZW5ndGg6IDFcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgcmV0dXJuICdcXHVmZmZkJzsgLy8gd2UgcmVwbGFjZSB0aGUgbWlzc2luZyBjaGFyYWN0ZXIgd2l0aCBhIHNwZWNpYWwgdXRmOCBjaGFyXG4gIH1cblxufVxuXG5jbGFzcyBVdGYxNlN0cmluZ0RlY29kZXIgZXh0ZW5kcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCd1dGYxNmxlJywgNCk7XG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBtb2R1bG8gPSBsZW5ndGggJSAyOyAvLyBvaywgd2UgaGF2ZSBhIG11bHRpcGxlIG9mIDIgYnl0ZXNcblxuICAgIGlmIChtb2R1bG8gPT09IDApIHtcbiAgICAgIC8vIGlzIHRoZSBsYXN0IGJ5dGUgYSBsZWFkaW5nL2hpZ2ggc3Vycm9nYXRlP1xuICAgICAgY29uc3QgYnl0ZSA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChieXRlID49IDB4RDggJiYgYnl0ZSA8PSAweERCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogNCxcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMlxuICAgICAgICB9O1xuICAgICAgfSAvLyB3ZSdyZSBnb29kLCBub3QgYSBzdXJyb2dhdGUsIHNvIHdlIGhhdmUgb3VyIG5lZWRlZCAyIGJ5dGVzXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDJcbiAgICAgIH07XG4gICAgfSAvLyBvayB3ZSBoYXZlIDEgYnl0ZSBsZWZ0IG92ZXIsIGFzc3VtZSB3ZSBuZWVkIDIgdG8gZm9ybSB0aGUgY2hhcmFjdGVyXG5cblxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMSxcbiAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgY2hhckxlbmd0aDogMlxuICAgIH07XG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBob3BlZnVsbHkgdGhlIGVuZ2luZSBjYW4gaGFuZGxlIGl0IGZvciB1cz9cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG5cbn1cblxuY2xhc3MgQmFzZTY0U3RyaW5nRGVjb2RlciBleHRlbmRzIE11bHRpQnl0ZVN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ2Jhc2U2NCcsIDMpO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7IC8vIGFsd2F5cyAzIVxuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgbW9kdWxvID0gbGVuZ3RoICUgMzsgLy8gYmFzZTY0IG5lZWRzIDMgYnl0ZXMgYWx3YXlzLCBzbyBpZiB3ZSBoYXZlIHRoYXQgbWFueSAob3IgYSBtdWx0aXBsZSksIHdlIGhhdmUgYSBjb21wbGV0ZSBidWZmZXJcblxuICAgIGlmIChtb2R1bG8gPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzTmVlZGVkOiAwLFxuICAgICAgICBjaGFyTGVuZ3RoOiAzXG4gICAgICB9O1xuICAgIH0gLy8gb2sgd2UgaGF2ZSAxIG9yIDIgYnl0ZXMgbGVmdCBvdmVyXG5cblxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMyAtIG1vZHVsbyxcbiAgICAgIC8vIGFsd2F5cyBuZWVkIDMsIHNvIGlmIHdlIGhhdmUgMSBsZWZ0IG92ZXIgLT4gbmVlZCAyXG4gICAgICBpbmRleDogbGVuZ3RoIC0gbW9kdWxvLFxuICAgICAgY2hhckxlbmd0aDogMyAvLyBhbHdheXMgbmVlZCAzXG5cbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAzOyAvLyBhbHdheXMgMyFcbiAgfVxuXG4gIF9pbmNvbXBsZXRlRW5kKCkge1xuICAgIC8vIEp1c3Qgd3JpdGUgb3V0IHRoZSBsYXN0IE4gYnl0ZXMsIGl0IHNob3VsZCBpbnNlcnQgdGhlICc9JyBwbGFjZWhvbGRlcnNcbiAgICAvLyBpdCdzIG5vdCByZWFsbHkgJ21pc3NpbmcnLydpbmNvbXBsZXRlJywganVzdCBuZWVkcyBwbGFjZWhvbGRlciBpbnNlcnRpb25cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCB0aGlzLmJ5dGVDb3VudCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjaGVja0NoYXJMZW5ndGhGb3JVVEY4KGJ5dGUpIHtcbiAgLy8gMTExMTBYWFggPT4gMTExMCA9PiAweDFFXG4gIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHtcbiAgICByZXR1cm4gNDtcbiAgfSAvLyAxMTEwWFhYWCA9PiAxMTEwID0+IDB4MUVcblxuXG4gIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHtcbiAgICByZXR1cm4gMztcbiAgfSAvLyAxMTBYWFhYWCA9PiAxMTAgPT4gMHgwNlxuXG5cbiAgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbnZhciBTdHJpbmdEZWNvZGVyJDEgPSB7XG4gIFN0cmluZ0RlY29kZXJcbn07XG5cbmNvbnN0IHByaW50ZWRXYXJuaW5ncyA9IHt9O1xuXG5mdW5jdGlvbiBvbmVUaW1lV2FybmluZyhrZXksIG1zZykge1xuICBpZiAoIXByaW50ZWRXYXJuaW5nc1trZXldKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgcHJpbnRlZFdhcm5pbmdzW2tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFByaW50cyBhIG9uZS10aW1lIHdhcm5pbmcgbWVzc2FnZSB0aGF0IHdlIGRvIG5vdCBzdXBwb3J0IHRoZSBnaXZlbiBBUEkgYW5kIHBlcmZvcm1zIGFuIGVmZmVjdGl2ZSBuby1vcFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgbmFtZSBvZiB0aGUgbW9kdWxlL29iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb24ucHJvcGVydHkgd2UgZG9uJ3Qgc3VwcG9ydFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBuby1vcCBmdW5jdGlvblxuICovXG5cblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBmcW4gPSBgJHttb2R1bGVOYW1lfS4ke25hbWV9YDtcbiAgICBvbmVUaW1lV2FybmluZyhmcW4sIGBcIiR7ZnFufVwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0IG9uIFRpdGFuaXVtIGFuZCB1c2VzIGEgbm8tb3AgZmFsbGJhY2suYCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgbmFtZSBvZiB0aGUgbW9kdWxlL29iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb24ucHJvcGVydHkgd2UgZG9uJ3Qgc3VwcG9ydFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2sgd2UgY2FsbCBpbiBhIHF1aWNrIHNldFRpbWVvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGFzeW5jVW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7IC8vIGVuZm9yY2Ugd2UgaGF2ZSBhIHZhbGlkIGNhbGxiYWNrXG5cbiAgdW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUpKCk7XG4gIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEpO1xufSAvLyBVc2VkIHRvIGNob29zZSB0aGUgYnVmZmVyL2NodW5rIHNpemUgd2hlbiBwdW1waW5nIGJ5dGVzIGR1cmluZyBjb3BpZXNcblxuXG5jb25zdCBDT1BZX0ZJTEVfQ0hVTktfU0laRSA9IDgwOTI7IC8vIHdoYXQgc2hvdWxkIHdlIHVzZSBoZXJlP1xuLy8gS2VlcCB0cmFjayBvZiBpbnRlZ2VyIC0+IEZpbGVTdHJlYW0gbWFwcGluZ3NcblxuY29uc3QgZmlsZURlc2NyaXB0b3JzID0gbmV3IE1hcCgpO1xubGV0IGZpbGVEZXNjcmlwdG9yQ291bnQgPSA0OyAvLyBnbG9iYWwgY291bnRlciB1c2VkIHRvIHJlcG9ydCBmaWxlIGRlc2NyaXB0b3IgaW50ZWdlcnNcbi8vIE1hcCBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3MgdG8gVGkuRmlsZXN5c3RlbS5NT0RFXyogY29uc3RhbnRzXG5cbmNvbnN0IEZMQUdTX1RPX1RJX01PREUgPSBuZXcgTWFwKCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYScsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2F4JywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYSsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdhcysnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3IrJywgVGkuRmlsZXN5c3RlbS5NT0RFX1JFQUQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3JzKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3JywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndysnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3d4KycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7IC8vIENvbW1vbiBlcnJvcnNcblxuY29uc3QgcGVybWlzc2lvbkRlbmllZCA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VBQ0NFUycsICdwZXJtaXNzaW9uIGRlbmllZCcsIC0xMywgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IG5vU3VjaEZpbGUgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9FTlQnLCAnbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIC0yLCBzeXNjYWxsLCBwYXRoKTtcblxuY29uc3QgZmlsZUFscmVhZHlFeGlzdHMgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFRVhJU1QnLCAnZmlsZSBhbHJlYWR5IGV4aXN0cycsIC0xNywgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IG5vdEFEaXJlY3RvcnkgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9URElSJywgJ25vdCBhIGRpcmVjdG9yeScsIC0yMCwgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IGRpcmVjdG9yeU5vdEVtcHR5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVEVNUFRZJywgJ2RpcmVjdG9yeSBub3QgZW1wdHknLCAtNjYsIHN5c2NhbGwsIHBhdGgpO1xuXG5jb25zdCBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUlTRElSJywgJ2lsbGVnYWwgb3BlcmF0aW9uIG9uIGEgZGlyZWN0b3J5JywgLTIxLCBzeXNjYWxsLCBwYXRoKTtcblxuY29uc3QgZnMgPSB7XG4gIGNvbnN0YW50czoge1xuICAgIE9fUkRPTkxZOiAwLFxuICAgIE9fV1JPTkxZOiAxLFxuICAgIE9fUkRXUjogMixcbiAgICBTX0lGTVQ6IDYxNDQwLFxuICAgIFNfSUZSRUc6IDMyNzY4LFxuICAgIFNfSUZESVI6IDE2Mzg0LFxuICAgIFNfSUZDSFI6IDgxOTIsXG4gICAgU19JRkJMSzogMjQ1NzYsXG4gICAgU19JRklGTzogNDA5NixcbiAgICBTX0lGTE5LOiA0MDk2MCxcbiAgICBTX0lGU09DSzogNDkxNTIsXG4gICAgT19DUkVBVDogNTEyLFxuICAgIE9fRVhDTDogMjA0OCxcbiAgICBPX05PQ1RUWTogMTMxMDcyLFxuICAgIE9fVFJVTkM6IDEwMjQsXG4gICAgT19BUFBFTkQ6IDgsXG4gICAgT19ESVJFQ1RPUlk6IDEwNDg1NzYsXG4gICAgT19OT0ZPTExPVzogMjU2LFxuICAgIE9fU1lOQzogMTI4LFxuICAgIE9fRFNZTkM6IDQxOTQzMDQsXG4gICAgT19TWU1MSU5LOiAyMDk3MTUyLFxuICAgIE9fTk9OQkxPQ0s6IDQsXG4gICAgU19JUldYVTogNDQ4LFxuICAgIFNfSVJVU1I6IDI1NixcbiAgICBTX0lXVVNSOiAxMjgsXG4gICAgU19JWFVTUjogNjQsXG4gICAgU19JUldYRzogNTYsXG4gICAgU19JUkdSUDogMzIsXG4gICAgU19JV0dSUDogMTYsXG4gICAgU19JWEdSUDogOCxcbiAgICBTX0lSV1hPOiA3LFxuICAgIFNfSVJPVEg6IDQsXG4gICAgU19JV09USDogMixcbiAgICBTX0lYT1RIOiAxLFxuICAgIEZfT0s6IDAsXG4gICAgUl9PSzogNCxcbiAgICBXX09LOiAyLFxuICAgIFhfT0s6IDEsXG4gICAgVVZfRlNfQ09QWUZJTEVfRVhDTDogMSxcbiAgICBDT1BZRklMRV9FWENMOiAxXG4gIH1cbn07XG5cbmNsYXNzIFN0YXRzIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgIHRoaXMuZGV2ID0gMDtcbiAgICB0aGlzLmlubyA9IDA7XG4gICAgdGhpcy5tb2RlID0gMDtcbiAgICB0aGlzLm5saW5rID0gMDtcbiAgICB0aGlzLnVpZCA9IDA7XG4gICAgdGhpcy5naWQgPSAwO1xuICAgIHRoaXMucmRldiA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmJsa3NpemUgPSA0MDk2OyAvLyBGSVhNRTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMxNTMxMS93aGF0LWlzLXRoZS1ibG9jay1zaXplLW9mLXRoZS1pcGhvbmUtZmlsZXN5c3RlbVxuXG4gICAgdGhpcy5ibG9ja3MgPSAwO1xuICAgIHRoaXMuYXRpbWVNcyA9IHRoaXMubXRpbWVNcyA9IHRoaXMuY3RpbWVNcyA9IHRoaXMuYmlydGh0aW1lTXMgPSAwO1xuICAgIHRoaXMuYXRpbWUgPSB0aGlzLm10aW1lID0gdGhpcy5jdGltZSA9IHRoaXMuYmlydGh0aW1lID0gbmV3IERhdGUoMCk7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy5fZmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpOyAvLyBUT0RPOiB1c2UgbGF6eSBnZXR0ZXJzIGhlcmU/XG5cbiAgICAgIHRoaXMuY3RpbWUgPSB0aGlzLmJpcnRodGltZSA9IHRoaXMuX2ZpbGUuY3JlYXRlZEF0KCk7XG4gICAgICB0aGlzLmF0aW1lID0gdGhpcy5tdGltZSA9IHRoaXMuX2ZpbGUubW9kaWZpZWRBdCgpO1xuICAgICAgdGhpcy5hdGltZU1zID0gdGhpcy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmJpcnRodGltZU1zID0gdGhpcy5iaXJ0aHRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5jdGltZU1zID0gdGhpcy5jdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLm10aW1lTXMgPSB0aGlzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2ZpbGUuc2l6ZTtcbiAgICAgIHRoaXMuYmxvY2tzID0gTWF0aC5jZWlsKHRoaXMuc2l6ZSAvIHRoaXMuYmxrc2l6ZSk7IC8vIFRPRE86IENhbiB3ZSBmYWtlIG91dCB0aGUgbW9kZSBiYXNlZCBvbiB0aGUgcmVhZG9ubHkvd3JpdGFibGUvZXhlY3V0YWJsZSBwcm9wZXJ0aWVzP1xuICAgIH1cbiAgfVxuXG4gIGlzRmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5pc0ZpbGUoKTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlLmlzRGlyZWN0b3J5KCk7XG4gIH1cblxuICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzU3ltYm9saWNMaW5rKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlLnN5bWJvbGljTGluaztcbiAgfVxuXG4gIGlzRklGTygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc1NvY2tldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuXG5mcy5TdGF0cyA9IFN0YXRzO1xuXG5jbGFzcyBSZWFkU3RyZWFtIHt9XG5cbmZzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtO1xuXG5jbGFzcyBXcml0ZVN0cmVhbSB7fVxuXG5mcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtO1xuLyoqXG4gKiBAY2FsbGJhY2sgc3RhdHNDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ZzLlN0YXRzfSBzdGF0cyAtIGZpbGUgc3RhdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTHxCdWZmZXJ9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPWZzLmNvbnN0YW50cy5GX09LXSBhY2Nlc3NpYmlsaXR5IG1vZGUvY2hlY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuZnMuYWNjZXNzID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbW9kZTtcbiAgICBtb2RlID0gZnMuY29uc3RhbnRzLkZfT0s7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMuYWNjZXNzU3luYyhwYXRoLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTHxCdWZmZXJ9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPWZzLmNvbnN0YW50cy5GX09LXSBhY2Nlc3NpYmlsaXR5IG1vZGUvY2hlY2tcbiAqL1xuXG5cbmZzLmFjY2Vzc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSA9IGZzLmNvbnN0YW50cy5GX09LKSB7XG4gIC8vIEZfT0sgaXMganVzdCB3aGV0aGVyIGZpbGUgZXhpc3RzIG9yIG5vdCwgbm8gcGVybWlzc2lvbnMgY2hlY2tcbiAgLy8gUl9PSyBpcyByZWFkIGNoZWNrXG4gIC8vIFdfT0sgaXMgd3JpdGUgY2hlY2tcbiAgLy8gWF9PSyBpcyBleGVjdXRlIGNoZWNrIChhY3RzIGxpa2UgRl9PSyBvbiBXaW5kb3dzKVxuICBjb25zdCBmaWxlSGFuZGxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCFmaWxlSGFuZGxlLmV4aXN0cygpKSB7XG4gICAgdGhyb3cgbm9TdWNoRmlsZSgnYWNjZXNzJywgcGF0aCk7XG4gIH0gLy8gVE9ETzogV2UgaGF2ZSBubyBtZWFucyBvZiB0ZXN0aW5nIGlmIGEgZmlsZSBpcyByZWFkYWJsZS4gSXQncyBhc3N1bWVkIGFsbCBmaWxlcyB0aGF0IGV4aXN0IHVuZGVyIHRoZSBhcHAgYXJlP1xuXG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuV19PSyAmJiAhZmlsZUhhbmRsZS53cml0YWJsZSkge1xuICAgIHRocm93IHBlcm1pc3Npb25EZW5pZWQoJ2FjY2VzcycsIHBhdGgpO1xuICB9XG5cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuWF9PSyAmJiAhZmlsZUhhbmRsZS5leGVjdXRhYmxlICYmIGZpbGVIYW5kbGUuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBwZXJtaXNzaW9uRGVuaWVkKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxufTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBiYWNrIHdpdGggZXJyb3IgaWYgZmFpbGVkXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ2EnXG4gIH0pO1xuICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogU3luY2hyb25vdXNseSBhcHBlbmQgZGF0YSB0byBhIGZpbGUsIGNyZWF0aW5nIHRoZSBmaWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC4gZGF0YSBjYW4gYmUgYSBzdHJpbmcgb3IgYSBCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfEZpbGVTdHJlYW19IGZpbGUgZmlsZXBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGEgdG8gYXBwZW5kIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBtb2RlIHRvIGNyZWF0ZSBmaWxlLCBpZiBub3QgY3JlYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J2EnXSBmaWxlIHN5c3RlbSBmbGFnXG4gKi9cblxuXG5mcy5hcHBlbmRGaWxlU3luYyA9IChmaWxlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCBkYXRhLCBvcHRpb25zKTsgLy8gVE9ETzogVXNlIFRpLkZpbGVzeXN0ZW0uRmlsZS5hcHBlbmQoKSBpbnN0ZWFkP1xufTtcblxuZnMuY2htb2QgPSAocGF0aCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZCcsIGNhbGxiYWNrKTtcblxuZnMuY2htb2RTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZFN5bmMnKTtcblxuZnMuY2hvd24gPSAocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2hvd24nLCBjYWxsYmFjayk7XG5cbmZzLmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2hvd25TeW5jJyk7XG4vKipcbiAqIENhbGxiYWNrIGZvciBmdW5jdGlvbnMgdGhhdCBjYW4gb25seSB0aHJvdyBlcnJvcnNcbiAqXG4gKiBAY2FsbGJhY2sgZXJyb3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gW2Vycl0gLSBFcnJvciB0aHJvd25cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuZnMuY2xvc2UgPSAoZmQsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG5cbmZzLmNsb3NlU3luYyA9IGZkID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmVhbS5jbG9zZSgpO1xufTsgLy8gUmF0aGVyIHRoYW4gdXNlIGEgaGFjayB0byB3cmFwIHN5bmMgdmVyc2lvbiBpbiBzZXRUaW1lb3V0LCB1c2UgYWN0dWFsIGFzeW5jIEFQSXMhXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxlZCBhdCBlbmQgb2Ygb3BlcmF0aW9uXG4gKi9cblxuXG5mcy5jb3B5RmlsZSA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGZsYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBmbGFncztcbiAgICBmbGFncyA9IDA7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBGSVhNRTogSSBkb24ndCBrbm93IHdoeSwgYnV0IGNoYW5naW5nIHRoaXMgdG8gdXNlIFRpLkZpbGVzeXN0ZW0ub3BlblN0cmVhbShtb2RlLCBwYXRoKSBmYWlscyAoYXQgbGVhc3Qgb24gaU9TKVxuXG4gIGNvbnN0IHNyY0ZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoc3JjKTtcbiAgY29uc3Qgc3JjU3RyZWFtID0gc3JjRmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbiAgY29uc3QgZGVzdEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoZGVzdCk7XG4gIGNvbnN0IGRlc3RTdHJlYW0gPSBkZXN0RmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG4gIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBzcmMgc291cmNlIGZpbGVuYW1lIHRvIGNvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGRlc3QgZGVzdGluYXRpb24gZmlsZW5hbWUgb2YgdGhlIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzPTBdIG1vZGlmaWVycyBmb3IgY29weSBvcGVyYXRpb25cbiAqL1xuXG5cbmZzLmNvcHlGaWxlU3luYyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzID0gMCkge1xuICBjb25zdCBzcmNGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHNyYyk7XG5cbiAgaWYgKGZsYWdzID09PSBmcy5jb25zdGFudHMuQ09QWUZJTEVfRVhDTCAmJiBmcy5leGlzdHNTeW5jKGRlc3QpKSB7XG4gICAgdGhyb3cgZmlsZUFscmVhZHlFeGlzdHMoJ2NvcHlGaWxlJywgZGVzdCk7XG4gIH1cblxuICBpZiAoIXNyY0ZpbGUuY29weShkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvcHkgJHtzcmN9IHRvICR7ZGVzdH1gKTsgLy8gRklYTUU6IFdoYXQgZXJyb3Igc2hvdWxkIHdlIGdpdmU/XG4gIH1cbn07IC8vIFRPRE86IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbi8vIC8qKlxuLy8gICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIGxpa2Vcbi8vICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMsIGlmIGEgc3RyaW5nLCBpdCdzIHRoZSBlbmNvZGluZ1xuLy8gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWdzPSdyJ10gU2VlIHN1cHBvcnQgb2YgZmlsZSBzeXN0ZW0gZmxhZ3MuXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2Rpbmdcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuZmQ9bnVsbF0gZmlsZSBkZXNjcmlwdG9yLCBpZiBzcGVjaWZpZWQsIGBwYXRoYCBpcyBpZ25vcmVkXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG82NjZdIHBlcm1pc3Npb25zIHRvIHNldCBpZiBmaWxlIGlzIGNyZWF0ZWRcbi8vICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0Nsb3NlPXRydWVdIGlmIGZhbHNlLCBmaWxlIGRlc2NyaXB0b3Igd2lsbCBub3QgYmUgY2xvc2VkOyBpZiB0cnVlIGV2ZW4gb24gZXJyb3IgaXQgd2lsbCBiZSBjbG9zZWRcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuc3RhcnRdIHN0YXJ0IGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmVuZD1JbmZpbml0eV0gZW5kIGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmhpZ2hXYXRlck1hcms9NjQgKiAxMDI0XVxuLy8gICogQHJldHVybnMge2ZzLlJlYWRTdHJlYW19XG4vLyAgKi9cbi8vIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuLy8gXHRvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7IGZsYWdzOiAncicsIGVuY29kaW5nOiBudWxsLCBmZDogbnVsbCwgbW9kZTogMG82NjYsIGF1dG9DbG9zZTogdHJ1ZSwgZW5kOiBJbmZpbml0eSwgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0IH0pO1xuLy8gXHQvLyBGSVhNRTogSWYgb3B0aW9ucy5mZCwgdXNlIHRoYXQgaW4gcGxhY2Ugb2YgcGF0aCFcbi8vIFx0Y29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG4vLyB9O1xuLy8gVE9ETzogZnMuY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcblxuLyoqXG4gKiBAY2FsbGJhY2sgZXhpc3RzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhpc3RzIC0gd2hldGhlciBwYXRoIGV4aXN0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBjaGVja1xuICogQHBhcmFtIHtleGlzdHNDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cblxuZnMuZXhpc3RzID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNhbGxiYWNrKGZzLmV4aXN0c1N5bmMocGF0aCkpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGEgZmlsZSBvciBkaXJlY3RvcnkgZXhpc3RzIGF0IHRoYXQgcGF0aFxuICovXG5cblxuZnMuZXhpc3RzU3luYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIHRyeSB7XG4gICAgZnMuYWNjZXNzU3luYyhwYXRoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnMuZmNobW9kID0gKGZkLCBtb2RlLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZCcsIGNhbGxiYWNrKTtcblxuZnMuZmNobW9kU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNobW9kU3luYycpO1xuXG5mcy5mY2hvd24gPSAoZmQsIHVpZCwgZ2lkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG93bicsIGNhbGxiYWNrKTtcblxuZnMuZmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNob3duU3luYycpO1xuXG5mcy5mZGF0YXN5bmMgPSAoZmQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jJywgY2FsbGJhY2spO1xuXG5mcy5mZGF0YXN5bmNTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdmZGF0YXN5bmNTeW5jJyk7XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuZnMuZnN0YXQgPSAoZmQsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgc3RhdHM7XG5cbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSBmcy5mc3RhdFN5bmMoZmQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtfb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbX29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEByZXR1cm5zIHtmcy5TdGF0c30gc3RhdHMgZm9yIGZpbGUgZGVzY3JpcHRvclxuICovXG5cblxuZnMuZnN0YXRTeW5jID0gKGZkLCBfb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXRoID0gcGF0aEZvckZpbGVEZXNjcmlwdG9yKGZkKTtcbiAgcmV0dXJuIGZzLnN0YXRTeW5jKHBhdGgpO1xufTsgLy8gVE9ETzogQWRkIHZlcnNpb25zIG9mIHRoZXNlIEFQSXM6XG4vLyBmcy5mc3luYyhmZCwgY2FsbGJhY2spXG4vLyBmcy5mc3luY1N5bmMoZmQpXG4vLyBmcy5mdHJ1bmNhdGUoZmRbLCBsZW5dLCBjYWxsYmFjaylcbi8vIGZzLmZ0cnVuY2F0ZVN5bmMoZmRbLCBsZW5dKVxuLy8gZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbi8vIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4vLyBmcy5sY2htb2QocGF0aCwgbW9kZSwgY2FsbGJhY2spXG4vLyBmcy5sY2htb2RTeW5jKHBhdGgsIG1vZGUpXG4vLyBmcy5sY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKVxuLy8gZnMubGNob3duU3luYyhwYXRoLCB1aWQsIGdpZClcbi8vIGZzLmxpbmsoZXhpc3RpbmdQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaylcbi8vIGZzLmxpbmtTeW5jKGV4aXN0aW5nUGF0aCwgbmV3UGF0aClcbi8vIEZJWE1FOiBJZiBzeW1ib2xpYyBsaW5rIHdlIG5lZWQgdG8gZm9sbG93IGxpbmsgdG8gdGFyZ2V0IHRvIGdldCBzdGF0cyEgT3VyIEFQSSBkb2Vzbid0IHN1cHBvcnQgdGhhdCFcblxuXG5mcy5sc3RhdCA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4gZnMuc3RhdChwYXRoLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cbmZzLmxzdGF0U3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiBmcy5zdGF0U3luYyhwYXRoLCBvcHRpb25zKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzaXZlPWZhbHNlXSByZWN1cnNpdmxleSBjcmVhdGUgZGlycz9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzc3N10gcGVybWlzc2lvbnNcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLm1rZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IDBvNzc3XG4gICAgfTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzaXZlPWZhbHNlXSByZWN1cnNpdmxleSBjcmVhdGUgZGlycz9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzc3N10gcGVybWlzc2lvbnNcbiAqL1xuXG5cbmZzLm1rZGlyU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IG9wdGlvbnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiAwbzc3N1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCF0aUZpbGUuY3JlYXRlRGlyZWN0b3J5KG9wdGlvbnMucmVjdXJzaXZlKSAmJiAhb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICBpZiAodGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICAvLyBhbHJlYWR5IGV4aXN0ZWQhXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnbWtkaXInLCBwYXRoKTtcbiAgICB9IC8vIFdlIGZhaWxlZCwgcHJvYmFibHkgYmVjYXVzZSB3ZSBkaWRuJ3QgYXNrIGZvciByZWN1cnNpdmUgYW5kIHBhcmVudCBkb2Vzbid0IGV4aXN0LCBzbyByZXByb2R1Y2Ugbm9kZSdzIGVycm9yXG5cblxuICAgIHRocm93IG5vU3VjaEZpbGUoJ21rZGlyJywgcGF0aCk7XG4gIH1cbn07XG4vKipcbiAqIEBjYWxsYmFjayB0ZW1wRGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIGdlbmVyYXRlZCBmb2xkZXIgbmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBkaXJlY3RvcnkgbmFtZSBwcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBwcmVmaXggZW5jb2RpbmdcbiAqIEBwYXJhbSB7dGVtcERpckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMubWtkdGVtcCA9IChwcmVmaXgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwcmVmaXgsICdwcmVmaXgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04J1xuICB9KTsgLy8gdHJ5IHRvIGJlIGFsbCBhc3luY1xuXG4gIGNvbnN0IHRyeU1rZHRlbXAgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG5cbiAgICBjb25zdCBwYXRoID0gYCR7cHJlZml4fSR7Z2VuZXJhdGVkfWA7XG4gICAgZnMubWtkaXIocGF0aCwgMG83MDAsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VFWElTVCcpIHtcbiAgICAgICAgICAvLyByZXRyeSFcbiAgICAgICAgICBzZXRUaW1lb3V0KHRyeU1rZHRlbXAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBidWJibGUgdXAgZXJyb3JcblxuXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc3VjY2VlZGVkISBIdXJyYXkhXG5cblxuICAgICAgY2FsbGJhY2sobnVsbCwgcGF0aCk7XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0VGltZW91dCh0cnlNa2R0ZW1wLCAxKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSB1bmlxdWUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggZGlyZWN0b3J5IG5hbWUgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gcHJlZml4IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwYXRoIHRvIGNyZWF0ZWQgZGlyZWN0b3J5XG4gKi9cblxuXG5mcy5ta2R0ZW1wU3luYyA9IChwcmVmaXgsIG9wdGlvbnMpID0+IHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHByZWZpeCwgJ3ByZWZpeCcsICdzdHJpbmcnKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmLTgnXG4gIH0pO1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGNvbnN0IE1BWF9SRVRSSUVTID0gMTAwO1xuXG4gIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSByYW5kb21DaGFyYWN0ZXJzKDYsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBnZW5lcmF0ZSBzaXggcmFuZG9tIGNoYXJhY3RlcnNcblxuICAgIGNvbnN0IHBhdGggPSBgJHtwcmVmaXh9JHtnZW5lcmF0ZWR9YDtcblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aCwgMG83MDApOyAvLyBkb24ndCB0cnkgcmVjdXJzaXZlXG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFRVhJU1QnKSB7XG4gICAgICAgIHRocm93IGU7IC8vIGJ1YmJsZSB1cCBlcnJvclxuICAgICAgfSAvLyBuYW1lIHdhcyBub3QgdW5pcXVlLCBzbyByZXRyeVxuXG5cbiAgICAgIHJldHJ5Q291bnQrKztcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYSB1bmlxdWUgZGlyZWN0b3J5IG5hbWUgd2l0aCBwcmVmaXggJHtwcmVmaXh9YCk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZURlc2NyaXB0b3JDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIC0gZ2VuZXJhdGVkIGZpbGUgZGVzY3JpcHRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9MG82NjZdIGZpbGUgbW9kZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmaWxlXG4gKiBAcGFyYW0ge2ZpbGVEZXNjcmlwdG9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5vcGVuID0gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykgPT4ge1xuICAvLyBmbGFncyBhbmQgbW9kZSBhcmUgb3B0aW9uYWwsIHdlIG5lZWQgdG8gaGFuZGxlIGlmIG5vdCBzdXBwbGllZCFcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAncic7XG4gICAgbW9kZSA9IDBvNjY2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtb2RlO1xuICAgIG1vZGUgPSAwbzY2NjtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCBmaWxlRGVzY3JpcHRvcjtcblxuICAgIHRyeSB7XG4gICAgICBmaWxlRGVzY3JpcHRvciA9IGZzLm9wZW5TeW5jKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBmaWxlRGVzY3JpcHRvcik7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3M9J3InXSBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3NcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW19tb2RlPTBvNjY2XSBmaWxlIG1vZGUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5mcy5vcGVuU3luYyA9IChwYXRoLCBmbGFncyA9ICdyJywgX21vZGUgPSAwbzY2NikgPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcblxuICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgIC8vIFRPRE86IFN1cHBvcnQgY3JlYXRpbmcgZmlsZSB3aXRoIHNwZWNpZmljIG1vZGVcbiAgICBvbmVUaW1lV2FybmluZygnZnMub3BlblN5bmMubW9kZScsICdmcy5vcGVuU3luY1xcJ3MgbW9kZSBwYXJhbWV0ZXIgaXMgdW5zdXBwb3J0ZWQgaW4gVGl0YW5pdW0gYW5kIHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgaWYgKCF0aUZpbGUuY3JlYXRlRmlsZSgpKSB7XG4gICAgICAvLyBPaCBjcmFwLCB3ZSBmYWlsZWQgdG8gY3JlYXRlIHRoZSBmaWxlLiB3aHk/XG4gICAgICBpZiAoIXRpRmlsZS5wYXJlbnQuZXhpc3RzKCkpIHtcbiAgICAgICAgLy8gcGFyZW50IGRvZXMgbm90IGV4aXN0IVxuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdvcGVuJywgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNyZWF0ZSBmaWxlIGF0IHBhdGggJHtwYXRofWApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbGFncykge1xuICAgIC8vIGZpbGUvZGlyIGV4aXN0cy4uLlxuICAgIGlmICgoZmxhZ3MuY2hhckF0KDApID09PSAndycgfHwgZmxhZ3MuY2hhckF0KDApID09PSAnYScpICYmIHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAvLyBJZiB1c2VyIGlzIHRyeWluZyB0byB3cml0ZSBvciBhcHBlbmQgYW5kIGl0J3MgYSBkaXJlY3RvcnksIGZhaWxcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ29wZW4nLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MubGVuZ3RoID4gMSAmJiBmbGFncy5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgLy8gSWYgdXNlciBoYXMgXCJleGNsdXNpdmVcIiBmbGFnIG9uLCBmYWlsIGlmIGZpbGUgYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdvcGVuJywgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGlNb2RlID0gRkxBR1NfVE9fVElfTU9ERS5nZXQoZmxhZ3MpO1xuXG4gIGlmICh0aU1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IE1ha2UgdXNlIG9mIGNvbW1vbiBlcnJvciB0eXBlL2NvZGUgZm9yIHRoaXMgb25jZSB3ZSBoYXZlIGludGVybmFsL2Vycm9ycy5qc1xuICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoYFRoZSB2YWx1ZSBcIiR7U3RyaW5nKGZsYWdzKX1cIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJmbGFnc1wiYCk7XG4gICAgZXJyLmNvZGUgPSAnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJztcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgdGlGaWxlLm9wZW4odGlNb2RlKSk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZXNSZWFkIC0gbnVtYmVyIG9mIGJ5dGVzIHJlYWRcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBwb3NpdGlvbiB3aGVyZSB0byBiZWdpbiByZWFkaW5nIGZyb20gaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7cmVhZENhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZCA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB9IC8vIEZJWE1FOiBBbGxvdyB1c2luZyBwb3NpdGlvbiBhcmd1bWVudCFcblxuXG4gIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkU3luYy5wb3NpdGlvbicsICdmcy5yZWFkU3luY1xcJ3MgcG9zaXRpb24gYXJndW1lbnQgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHdpbGwgYmUgdHJlYXRlZCBhcyBudWxsJyk7XG4gIH1cblxuICB0aUZpbGVTdHJlYW0ucmVhZChidWZmZXIudG9UaUJ1ZmZlcigpLCBvZmZzZXQsIGxlbmd0aCwgcmVhZE9iaiA9PiB7XG4gICAgaWYgKCFyZWFkT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihyZWFkT2JqLmVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVhZE9iai5ieXRlc1Byb2Nlc3NlZCwgYnVmZmVyKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ8VGkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHRvIHJlYWQgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgYXQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBfcG9zaXRpb24gd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gYnl0ZXMgcmVhZFxuICovXG5cblxuZnMucmVhZFN5bmMgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIF9wb3NpdGlvbikgPT4ge1xuICBjb25zdCBmaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gIH0gLy8gRklYTUU6IEFsbG93IHVzaW5nIHBvc2l0aW9uIGFyZ3VtZW50IVxuXG5cbiAgaWYgKF9wb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkU3luYy5wb3NpdGlvbicsICdmcy5yZWFkU3luY1xcJ3MgcG9zaXRpb24gYXJndW1lbnQgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHdpbGwgYmUgdHJlYXRlZCBhcyBudWxsJyk7XG4gIH1cblxuICByZXR1cm4gZmlsZVN0cmVhbS5yZWFkKGJ1ZmZlci50b1RpQnVmZmVyKCksIG9mZnNldCwgbGVuZ3RoKTtcbn07XG4vKipcbiAqIEBjYWxsYmFjayBmaWxlc0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nW118QnVmZmVyW118ZnMuRGlyZW50W119IGZpbGVzIC0gZmlsZSBsaXN0aW5nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBkaXJlY3RvcnkgdG8gbGlzdFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdG8gdXNlIGZvciBmaWxlbmFtZXMsIGlmIGAnYnVmZmVyJ2AsIHJldHVybnMgYEJ1ZmZlcmAgb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53aXRoRmlsZVR5cGVzPWZhbHNlXSBpZiB0cnVlLCByZXR1cm5zIGBmcy5EaXJlbnRgIG9iamVjdHNcbiAqIEBwYXJhbSB7ZmlsZXNDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlYWRkaXIgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZnMucmVhZGRpclN5bmMocGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggZGlyZWN0b3J5IHRvIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZSBmb3IgZmlsZW5hbWVzLCBpZiBgJ2J1ZmZlcidgLCByZXR1cm5zIGBCdWZmZXJgIG9iamVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2l0aEZpbGVUeXBlcz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBgZnMuRGlyZW50YCBvYmplY3RzXG4gKiBAcmV0dXJucyB7c3RyaW5nW118QnVmZmVyW118ZnMuRGlyZW50W119XG4gKi9cblxuXG5mcy5yZWFkZGlyU3luYyA9IChmaWxlcGF0aCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBmaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUoZmlsZXBhdGgpO1xuXG4gIGlmICghZmlsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBpZiAoIWZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cblxuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgd2l0aEZpbGVUeXBlczogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGxpc3RpbmcgPSBmaWxlLmdldERpcmVjdG9yeUxpc3RpbmcoKTtcblxuICBpZiAob3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlKSB7XG4gICAgLy8gVE9ETzogaWYgb3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlLCByZXR1cm4gZnMuRGlyZW50IG9iamVjdHNcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZGRpclxcJ3Mgb3B0aW9ucy53aXRoRmlsZVR5cGVzIGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCBzdHJpbmdzIHdpbGwgYmUgcmV0dXJuZWQnKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgIHJldHVybiBsaXN0aW5nLm1hcChuYW1lID0+IEJ1ZmZlci5mcm9tKG5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0aW5nO1xufTtcbi8qKlxuICogQGNhbGxiYWNrIHJlYWRGaWxlUG9zdE9wZW5DYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gYnVmZmVyXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZpbGVEZXNjcmlwdG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtyZWFkRmlsZVBvc3RPcGVuQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mdW5jdGlvbiByZWFkRmlsZVBvc3RPcGVuKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBmcy5mc3RhdChmaWxlRGVzY3JpcHRvciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVTaXplID0gc3RhdHMuc2l6ZTsgLy8gQ3JlYXRlIGEgVGkuQnVmZmVyIHRvIHJlYWQgaW50b1xuXG4gICAgY29uc3QgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgIGxlbmd0aDogZmlsZVNpemVcbiAgICB9KTsgLy8gVXNlIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykgd2hpY2ggc3BpbnMgb2ZmIGEgc2VwYXJhdGUgdGhyZWFkIHRvIHJlYWQgaW4gd2hpbGUgbG9vcCFcblxuICAgIGNvbnN0IHNvdXJjZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IpO1xuICAgIFRpLlN0cmVhbS5yZWFkQWxsKHNvdXJjZVN0cmVhbSwgYnVmZmVyLCByZWFkQWxsT2JqID0+IHtcbiAgICAgIGlmICghcmVhZEFsbE9iai5zdWNjZXNzKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihyZWFkQWxsT2JqLmVycm9yKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIEBjYWxsYmFjayByZWFkRmlsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICovXG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVhZCBlbnRpcmUgY29udGVudHMgb2YgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBwYXRoIGZpbGVuYW1lIG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J3InXSBmaWxlIHN5c3RlbSBmbGFnXG4gKiBAcGFyYW0ge3JlYWRGaWxlQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZWFkRmlsZSA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgZmxhZzogJ3InXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGZsYWc6ICdyJ1xuICAgIH0pO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgcGF0aCA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IHBhdGg7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIHBvc3NpYmxlIEVycm9yXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSBidWZmZXIgVGkuQnVmZmVyIGluc3RhbmNlXG4gICAqL1xuXG4gIGNvbnN0IGhhbmRsZUJ1ZmZlciA9IChlcnIsIGJ1ZmZlcikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gICAgfSAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cblxuICAgIGNhbGxiYWNrKG51bGwsIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpKTtcbiAgfTtcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMub3BlbihwYXRoLCBvcHRpb25zLmZsYWcsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIHJlYWRGaWxlUG9zdE9wZW4oZmQsIGhhbmRsZUJ1ZmZlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEZpbGVQb3N0T3BlbihwYXRoLCBoYW5kbGVCdWZmZXIpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdyJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9IHN0cmluZyBpZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQsIG90aGVyd2lzZSBCdWZmZXJcbiAqL1xuXG5cbmZzLnJlYWRGaWxlU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogbnVsbCxcbiAgICBmbGFnOiAncidcbiAgfSk7XG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIHBhdGggPT09ICdudW1iZXInO1xuICBjb25zdCBmaWxlRGVzY3JpcHRvciA9IHdhc0ZpbGVEZXNjcmlwdG9yID8gcGF0aCA6IGZzLm9wZW5TeW5jKHBhdGgsIG9wdGlvbnMuZmxhZyk7IC8vIHVzZSBkZWZhdWx0IG1vZGVcblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTsgLy8gSnVzdCB1c2Ugb3VyIG93biBBUEkgdGhhdCByZWFkcyBmdWxsIHN0cmVhbSBpblxuXG4gIGNvbnN0IGJ1ZmZlciA9IFRpLlN0cmVhbS5yZWFkQWxsKHRpRmlsZVN0cmVhbSk7IC8vIGZzLmNsb3NlU3luYyBpZiBpdCB3YXMgbm90IG9yaWdpbmFsbHkgYSBmaWxlIGRlc2NyaXB0b3JcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgfSAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cblxuICByZXR1cm4gZW5jb2RlQnVmZmVyKG9wdGlvbnMuZW5jb2RpbmcsIGJ1ZmZlcik7XG59OyAvLyBUT0RPOiBmcy5yZWFkbGluayhwYXRoWywgb3B0aW9uc10sIGNhbGxiYWNrKVxuLy8gVE9ETzogZnMucmVhZGxpbmtTeW5jKHBhdGhbLCBvcHRpb25zXSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhbHBhdGhDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IHJlc29sdmVkUGF0aCB0aGUgcmVzb2x2ZWQgcGF0aFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZmlsZXBhdGggb3JpZ2luYWwgZmlsZXBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9zbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHVzZWQgZm9yIHJldHVybmVkIG9iamVjdC4gSWYgJ2J1ZmZlclwiLCB3ZSdsbCByZXR1cm4gYSBCdWZmZXIgaW4gcGFsY2Ugb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7cmVhbHBhdGhDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlYWxwYXRoID0gKGZpbGVwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnXG4gIH0pO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIG5vIHN5bWxpbmtzLCB3aGljaCB3ZSByZWFsbHkgZG9uJ3QgaGF2ZSBmdWxsIHN1cHBvcnQgZm9yIGluIG91ciBTREsgYW55d2F5cy5cbiAgICBjb25zdCByZXN1bHQgPSBwYXRoLm5vcm1hbGl6ZShmaWxlcGF0aCk7XG4gICAgZnMuZXhpc3RzKHJlc3VsdCwgcmVzdWx0RXhpc3RzID0+IHtcbiAgICAgIGlmIChyZXN1bHRFeGlzdHMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5mcm9tKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICB9IC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG5cblxuICAgICAgY29uc3Qgc2VnbWVudHMgPSByZXN1bHQuc3BsaXQocGF0aC5zZXApOyAvLyBGSVhNRTogRHJvcCBsYXN0IHNlZ21lbnQgYXMgd2UgYWxyZWFkeSBrbm93IHRoZSBmdWxsIHBhdGggZG9lc24ndCBleGlzdD9cblxuICAgICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuICAgICAgbGV0IGluZGV4ID0gMDsgLy8gaGFuZGxlIHR5cGljYWwgY2FzZSBvZiBlbXB0eSBmaXJzdCBzZWdtZW50IHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW4gYXN5bmMgc2V0VGltZW91dCB0byBnZXQgdG8gZmlyc3QgcmVhbCBjYXNlXG5cbiAgICAgIGlmIChzZWdtZW50c1tpbmRleF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyeVBhdGgoKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBkb24ndCBydW4gcGFzdCBlbmQgb2Ygc2VnbWVudHMsIHRocm93IGVycm9yIGZvciByZXNvbHZlZCBwYXRoXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5vU3VjaEZpbGUocmVzdWx0KSk7XG4gICAgICAgIH0gLy8gZ3JhYiBuZXh0IHNlZ21lbnRcblxuXG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleCsrXTtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGVtcHR5IHNlZ21lbnQuLi5cbiAgICAgICAgICAvLyB0cnkgYWdhaW4gYXQgbmV4dCBpbmRleFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuICAgICAgICB9IC8vIG5vcm1hbCBjYXNlXG5cblxuICAgICAgICBwYXJ0aWFsRmlsZVBhdGggKz0gcGF0aC5zZXAgKyBzZWdtZW50OyAvLyBjaGVjayBpZiBwYXRoIHVwIHRvIHRoaXMgcG9pbnQgZXhpc3RzLi4uXG5cbiAgICAgICAgZnMuZXhpc3RzKHBhcnRpYWxGaWxlUGF0aCwgcGFydGlhbEV4aXN0cyA9PiB7XG4gICAgICAgICAgaWYgKCFwYXJ0aWFsRXhpc3RzKSB7XG4gICAgICAgICAgICAvLyBub3BlLCB0aHJvdyB0aGUgRXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhub1N1Y2hGaWxlKCdsc3RhdCcsIHBhcnRpYWxGaWxlUGF0aCkpO1xuICAgICAgICAgIH0gLy8gdHJ5IGFnYWluIGF0IG5leHQgZGVwdGggb2YgZGlyIHRyZWVcblxuXG4gICAgICAgICAgc2V0VGltZW91dCh0cnlQYXRoLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDEpO1xufTtcblxuZnMucmVhbHBhdGgubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGZzLnJlYWxwYXRoKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGZpbGVwYXRoIG9yaWdpbmFsIGZpbGVwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB1c2VkIGZvciByZXR1cm5lZCBvYmplY3QuIElmICdidWZmZXJcIiwgd2UnbGwgcmV0dXJuIGEgQnVmZmVyIGluIHBhbGNlIG9mIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn1cbiAqL1xuXG5cbmZzLnJlYWxwYXRoU3luYyA9IChmaWxlcGF0aCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4J1xuICB9KTsgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBubyBzeW1saW5rcywgd2hpY2ggd2UgcmVhbGx5IGRvbid0IGhhdmUgZnVsbCBzdXBwb3J0IGZvciBpbiBvdXIgU0RLIGFueXdheXMuXG5cbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5ub3JtYWxpemUoZmlsZXBhdGgpO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhyZXN1bHQpKSB7XG4gICAgLy8gdGhpcyBwYXRoIGRvZXNuJ3QgZXhpc3QsIHRyeSBlYWNoIHNlZ21lbnQgdW50aWwgd2UgZmluZCBmaXJzdCB0aGF0IGRvZXNuJ3RcbiAgICBjb25zdCBzZWdtZW50cyA9IHJlc3VsdC5zcGxpdChwYXRoLnNlcCk7XG4gICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhcnRpYWxGaWxlUGF0aCArPSBwYXRoLnNlcCArIHNlZ21lbnQ7XG5cbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwYXJ0aWFsRmlsZVBhdGgpKSB7XG4gICAgICAgIHRocm93IG5vU3VjaEZpbGUoJ2xzdGF0JywgcGFydGlhbEZpbGVQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mcy5yZWFscGF0aFN5bmMubmF0aXZlID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbiAgZnMucmVhbHBhdGhTeW5jKHBhdGgsIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gb2xkUGF0aCBzb3VyY2UgZmlsZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG5ld1BhdGggZGVzdGluYXRpb24gZmlsZXBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlbmFtZSA9IChvbGRQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMucmVuYW1lU3luYyhvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG9sZFBhdGggc291cmNlIGZpbGVwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBuZXdQYXRoIGRlc3RpbmF0aW9uIGZpbGVwYXRoXG4gKi9cblxuXG5mcy5yZW5hbWVTeW5jID0gKG9sZFBhdGgsIG5ld1BhdGgpID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUob2xkUGF0aCk7IC8vIHNyYyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0P1xuXG4gIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgY29uc3QgZXJyID0gbm9TdWNoRmlsZSgncmVuYW1lJywgb2xkUGF0aCk7XG4gICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gLT4gJyR7bmV3UGF0aH0nYDtcbiAgICBlcnIuZGVzdCA9IG5ld1BhdGg7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgY29uc3QgZGVzdEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShuZXdQYXRoKTtcblxuICBpZiAoZGVzdEZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgIC8vIGRlc3QgaXMgYSBkaXJlY3RvcnkgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IGVyciA9IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3JlbmFtZScsIG9sZFBhdGgpO1xuICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9IC0+ICcke25ld1BhdGh9J2A7XG4gICAgZXJyLmRlc3QgPSBuZXdQYXRoO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGxldCB0ZW1wUGF0aDtcblxuICBpZiAoZGVzdEZpbGUuaXNGaWxlKCkpIHtcbiAgICAvLyBkZXN0aW5hdGlvbiBmaWxlIGV4aXN0cywgd2Ugc2hvdWxkIG92ZXJ3cml0ZVxuICAgIC8vIE91ciBBUElzIHdpbGwgZmFpbCBpZiB3ZSB0cnksIHNvIGZpcnN0IGxldCdzIG1ha2UgYSBiYWNrdXAgY29weSBhbmQgZGVsZXRlIHRoZSB0aGUgb3JpZ2luYWxcbiAgICB0ZW1wUGF0aCA9IHBhdGguam9pbihmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oVGkuRmlsZXN5c3RlbS50ZW1wRGlyZWN0b3J5LCAncmVuYW1lLScpKSwgcGF0aC5iYXNlbmFtZShuZXdQYXRoKSk7XG4gICAgZGVzdEZpbGUubW92ZSh0ZW1wUGF0aCk7XG4gIH1cblxuICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgc3VjY2VzcyA9IHRpRmlsZS5tb3ZlKG5ld1BhdGgpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICh0ZW1wUGF0aCkge1xuICAgICAgLy8gd2UgdGVtcG9yYXJpbHkgY29waWVkIHRoZSBleGlzdGluZyBkZXN0aW5hdGlvbiB0byBiYWNrIGl0IHVwLi4uXG4gICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAvLyBtb3ZlIHdvcmtlZCwgc28gd2UgY2FuIHdpcGUgaXQgYXdheSB3aGVuZXZlci4uLlxuICAgICAgICBmcy51bmxpbmsodGVtcFBhdGgsIF9lcnIgPT4ge30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSBpdCBiYWNrLCBiZWNhdXNlIHdlIGZhaWxlZCFcbiAgICAgICAgY29uc3QgdG1wRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHRlbXBQYXRoKTtcbiAgICAgICAgdG1wRmlsZS5tb3ZlKG5ld1BhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJtZGlyID0gKHBhdGgsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5ybWRpclN5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICovXG5cblxuZnMucm1kaXJTeW5jID0gcGF0aCA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICghdGlGaWxlLmRlbGV0ZURpcmVjdG9yeShmYWxzZSkpIHtcbiAgICAvLyBkbyBub3QgZGVsZXRlIGNvbnRlbnRzIVxuICAgIC8vIHdlIGZhaWxlZCB0byBkZWxldGUsIGJ1dCB3aHk/XG4gICAgLy8gZG9lcyBpdCBleGlzdD9cbiAgICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbm9TdWNoRmlsZSgncm1kaXInLCBwYXRoKTtcbiAgICB9IC8vIGlzIGl0IGEgZmlsZT9cblxuXG4gICAgaWYgKHRpRmlsZS5pc0ZpbGUoKSkge1xuICAgICAgdGhyb3cgbm90QURpcmVjdG9yeSgncm1kaXInLCBwYXRoKTtcbiAgICB9IC8vIGlzIGl0IG5vdCBlbXB0eT9cblxuXG4gICAgY29uc3Qgc3ViRmlsZXMgPSB0aUZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuXG4gICAgaWYgKHN1YkZpbGVzICYmIHN1YkZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IGRpcmVjdG9yeU5vdEVtcHR5KCdybWRpcicsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHBhcmFtIHtzdGF0c0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMuc3RhdCA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IGZzLlN0YXRzKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggZmlsZXBhdGggb3IgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW19vcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHJldHVybnMge2ZzLlN0YXRzfVxuICovXG5cblxuZnMuc3RhdFN5bmMgPSAocGF0aCwgX29wdGlvbnMpID0+IG5ldyBmcy5TdGF0cyhwYXRoKTtcblxuZnMuc3ltbGluayA9ICh0YXJnZXQsIHBhdGgsIHR5cGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnc3ltbGluaycsIGNhbGxiYWNrKTtcblxuZnMuc3ltbGlua1N5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3N5bWxpbmtTeW5jJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5mcy50cnVuY2F0ZSA9IChwYXRoLCBsZW4sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBsZW4pO1xuXG4gIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykge1xuICAgIGxlbiA9IDA7XG4gIH1cblxuICBpZiAobGVuIDw9IDApIHtcbiAgICBmcy53cml0ZUZpbGUocGF0aCwgJycsIGNhbGxiYWNrKTsgLy8gZW1wdHkgdGhlIGZpbGVcblxuICAgIHJldHVybjtcbiAgfSAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuXG5cbiAgZnMub3BlbihwYXRoLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZzLndyaXRlRmlsZShwYXRoLCBidWZmZXIsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqL1xuXG5cbmZzLnRydW5jYXRlU3luYyA9IChwYXRoLCBsZW4gPSAwKSA9PiB7XG4gIGlmIChsZW4gPD0gMCkge1xuICAgIC8vIGVtcHR5IHRoZSBmaWxlXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCAnJyk7XG4gICAgcmV0dXJuO1xuICB9IC8vIHdlIGhhdmUgdG8gcmV0YWluIHNvbWUgb2YgdGhlIGZpbGUhXG4gIC8vIHl1Y2ssIHNvIGxldCdzIHJlYWQgd2hhdCB3ZSBuZWVkIHRvIHJldGFpbiwgdGhlbiBvdmVyd3JpdGUgZmlsZSB3aXRoIGl0XG5cblxuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgZnMucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsKTtcbiAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCBidWZmZXIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnVubGluayA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMudW5saW5rU3luYyhwYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZzLnVubGlua1N5bmMgPSBwYXRoID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCF0aUZpbGUuZGVsZXRlRmlsZSgpKSB7XG4gICAgLy8gd2UgZmFpbGVkLCBidXQgd2h5P1xuICAgIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBub1N1Y2hGaWxlKCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAodGlGaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IGlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkoJ3VubGluaycsIHBhdGgpO1xuICAgIH1cbiAgfVxufTtcblxuZnMudW53YXRjaEZpbGUgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3Vud2F0Y2hGaWxlJyk7XG5cbmZzLnV0aW1lcyA9IChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzJywgY2FsbGJhY2spO1xuXG5mcy51dGltZXNTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1dGltZXNTeW5jJyk7XG5mcy53YXRjaCA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2gnKTtcbmZzLndhdGNoRmlsZSA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnd2F0Y2hGaWxlJyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gZmlsZSBmaWxlIHBhdGggb3IgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd9IGRhdGEgZGF0YSB0byB3cml0ZVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9ucywgZW5jb2RpbmcgaWYgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9kZT0wbzY2Nl0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZsYWc9J3cnXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuZnMud3JpdGVGaWxlID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ3cnXG4gIH0pOyAvLyBUdXJuIGludG8gZmlsZSBkZXNjcmlwdG9yXG5cbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgZmlsZSA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IGZpbGU7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcblxuICBjb25zdCBmaW5pc2ggPSBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZnMuY2xvc2UgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cblxuICAgIGZzLmNsb3NlKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4oZmlsZSwgb3B0aW9ucy5mbGFnLCBvcHRpb25zLm1vZGUsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZzLndyaXRlKGZpbGVEZXNjcmlwdG9yLCBkYXRhLCBmaW5pc2gpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZmxhZz0ndyddIG9wdGlvbnNcbiAqL1xuXG5cbmZzLndyaXRlRmlsZVN5bmMgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAndydcbiAgfSk7IC8vIFR1cm4gaW50byBmaWxlIGRlc2NyaXB0b3JcblxuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJztcbiAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSB3YXNGaWxlRGVzY3JpcHRvciA/IGZpbGUgOiBmcy5vcGVuU3luYyhmaWxlLCBvcHRpb25zLmZsYWcsIG9wdGlvbnMubW9kZSk7IC8vIGlmIGRhdGEgaXMgYSBzdHJpbmcsIG1ha2UgaXQgYSBidWZmZXIgZmlyc3RcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgnJyArIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBmb3JjZSBkYXRhIHRvIGJlIGEgc3RyaW5nLCBoYW5kbGVzIGNhc2Ugd2hlcmUgaXQncyB1bmRlZmluZWQgYW5kIHdyaXRlcyAndW5kZWZpbmVkJyB0byBmaWxlIVxuICB9XG5cbiAgZnMud3JpdGVTeW5jKGZpbGVEZXNjcmlwdG9yLCBkYXRhKTsgLy8gY2xvc2UgaWYgdXNlciBkaWRuJ3QgZ2l2ZSB1cyBmaWxlIGRlc2NyaXB0b3JcblxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlVGlGaWxlU3RyZWFtQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICovXG5cbi8qKlxuICogQHBhcmFtIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IHRpRmlsZVN0cmVhbSBmaWxlIHN0cmVhbVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgd2UncmUgd3JpdGluZ1xuICogQHBhcmFtIHt3cml0ZVRpRmlsZVN0cmVhbUNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIFRpLlN0cmVhbS53cml0ZSh0aUZpbGVTdHJlYW0sIGJ1ZmZlci50b1RpQnVmZmVyKCksIHdyaXRlT2JqID0+IHtcbiAgICBpZiAoIXdyaXRlT2JqLnN1Y2Nlc3MpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih3cml0ZU9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHdyaXRlT2JqLmJ5dGVzUHJvY2Vzc2VkKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZTogQnVmZmVyIG9yIHN0cmluZ1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZTsgT1Igb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIHN0cmluZylcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXI7IE9SIGV4cGVjdGVkIHN0cmluZyBlbmNvZGluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfGludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW4gKGlmIEJ1ZmZlcik7IE9SIGFzeW5jIGNhbGxiYWNrIGlmIHN0cmluZ1xuICogQHBhcmFtIHt3cml0ZUNhbGxiYWNrfSBbY2FsbGJhY2tdIGFzeW5jIGNhbGxiYWNrIChpZiBCdWZmZXIpXG4gKi9cblxuXG5mcy53cml0ZSA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG5cbiAgaWYgKGlzQnVmZmVyKSB7XG4gICAgd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVTdHJpbmcoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSAgZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gcG9zaXRpb25cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnMud3JpdGVTeW5jID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICBjb25zdCBpc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpO1xuXG4gIGlmIChpc0J1ZmZlcikge1xuICAgIHJldHVybiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlU3RyaW5nU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG59OyAvLyBUT0RPOiBBZGQgRmlsZUhhbmRsZSBjbGFzcyB0byBtYXRjaCBOb2RlJ3Mgd3JhcHBlciBmb3IgZmlsZSBkZXNjcmlwdG9ycy4gUmUtcHVycG9zZSBvdXIgb3duIHdyYXBwZXI/XG4vLyBUT0RPOiBBZGQgdGhlIGZzLnByb21pc2VzIEFQSSFcbi8vIFRPRE86IERlZmluZSBmcy5EaXJlbnQgY2xhc3MsIHdoaWNoIGNhbiBzaW1wbHkgd3JhcCBhIFRpLkZpbGVzeXN0ZW0uRmlsZSAoYW5kIGlzIHZlcnkgc2ltaWxhciB0byBmcy5TdGF0cyEpXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRyYWNrcyB0aGUgcGFpcmluZyBvZiB0aGUgbnVtYmVyIHdlIHVzZSB0byByZXByZXNlbnQgdGhlIGZpbGUgZXh0ZXJuYWxseSwgdGhlIGZpbGVwYXRoIGl0J3MgcG9pbnRpbmcgYXQsIGFuZCB0aGUgc3RyZWFtIHBvaW50aW5nIGF0IGl0LlxuICovXG5cblxuY2xhc3MgRmlsZURlc2NyaXB0b3Ige1xuICBjb25zdHJ1Y3RvcihudW1iZXIsIHBhdGgsIHN0cmVhbSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cblxufVxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gQW5kcm9pZCBpcyBwcm9iYWJseSBiZXR0ZXIgb2ZmIHdpdGggVGkuU3RyZWFtLndyaXRlU3RyZWFtLCBsZXNzIG92ZXJoZWFkIGJhY2sgYW5kIGZvcnRoIHRoZSBicmlkZ2VcbiAgICAvLyBUaG91Z2ggQW5kcm9pZCBkb2VzIHN1cHBvcnQgdGhlIFRpLlN0cmVhbS5wdW1wL1RpLlN0cmVhbS53cml0ZSBwYXR0ZXJuIHVzaW5nIGJvdGggQVBJcyBhc3luY1xuICAgIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH0gLy8gaU9TIGhhcyBzb21lLi4uIGlzc3VlcyB3aXRoIHdyaXRlU3RyZWFtIGNhbGxpbmcgdGhlIGNhbGxiYWNrIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcCAqYW5kKiBhdCB0aGUgZW5kXG59XG4vKipcbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IHNyY1N0cmVhbSBpbnB1dCBzdHJlYW0gd2UncmUgcmVhZGluZyBmcm9tXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBkZXN0U3RyZWFtIG91dHB1dCBzdHJlYW0gd2UncmUgd3JpdGluZyB0b1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gcGlwZVZpYVdyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLndyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgQ09QWV9GSUxFX0NIVU5LX1NJWkUsIHJlc3VsdCA9PiB7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpKTtcbiAgICB9IC8vIEFuZHJvaWQgd2lsbCBvbmx5IGNhbGwgdGhpcyBhdCB0aGUgZW5kIG9yIGVycm9yLCBzbyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB3ZSdyZSBkb25lIGhlcmUuXG4gICAgLy8gaU9TIHdpbGwgY2FsbCBwZXIgbG9vcCBpdGVyYXRpb24sIHNlZSBodHRwczovL2ppcmEuYXBwY2VsZXJhdG9yLm9yZy9icm93c2UvVElNT0ItMjczMjBcblxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gZmlsZVN0cmVhbSBmaWxlIHN0cmVhbVxuICogQHJldHVybnMge2ludGVnZXJ9IGZpbGUgZGVzY3JpcHRvclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRmlsZURlc2NyaXB0b3IocGF0aCwgZmlsZVN0cmVhbSkge1xuICBjb25zdCBwb2ludGVyID0gZmlsZURlc2NyaXB0b3JDb3VudCsrOyAvLyBpbmNyZW1lbnQgZ2xvYmFsIGNvdW50ZXJcblxuICBjb25zdCBmZCA9IG5ldyBGaWxlRGVzY3JpcHRvcihwb2ludGVyLCBwYXRoLCBmaWxlU3RyZWFtKTtcbiAgZmlsZURlc2NyaXB0b3JzLnNldChwb2ludGVyLCBmZCk7IC8vIHVzZSBpdCB0byByZWZlciB0byB0aGlzIGZpbGUgc3RyZWFtIGFzIHRoZSBcImRlc2NyaXB0b3JcIlxuXG4gIHJldHVybiBwb2ludGVyO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gbWF0Y2hpbmcgc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKSB7XG4gIGNvbnN0IHdyYXBwZXIgPSBmaWxlRGVzY3JpcHRvcnMuZ2V0KGZkKTtcbiAgcmV0dXJuIHdyYXBwZXIuc3RyZWFtO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge3N0cmluZ30gbWF0Y2hpbmcgc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiBwYXRoRm9yRmlsZURlc2NyaXB0b3IoZmQpIHtcbiAgY29uc3Qgd3JhcHBlciA9IGZpbGVEZXNjcmlwdG9ycy5nZXQoZmQpO1xuICByZXR1cm4gd3JhcHBlci5wYXRoO1xufVxuLyoqXG4gKiBVc2VkIHRvIG1lcmdlIHRoZSB1c2VyLXN1cHBsaWVkIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdHMgZm9yIGEgZnVuY3Rpb24uIFNwZWNpYWwgY2FzZXMgYSBzdHJpbmcgdG8gYmUgZW5jb2RpbmcuXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgdXNlci1zdXBwbGllZCBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdHMgZGVmYXVsdHMgdG8gdXNlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uc1R5cGUgPSB0eXBlb2Ygb3B0aW9ucztcblxuICBzd2l0Y2ggKG9wdGlvbnNUeXBlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gZGVmYXVsdHM7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVXNlIGNvcHkgb2YgZGVmYXVsdHMgYnV0IHdpdGggZW5jb2Rpbmcgc2V0IHRvIHRoZSAnb3B0aW9ucycgdmFsdWUhXG4gICAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gICAgICBtZXJnZWQuZW5jb2RpbmcgPSBvcHRpb25zO1xuICAgICAgcmV0dXJuIG1lcmdlZDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gb3B0aW9ucztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnRBcmd1bWVudFR5cGUob3B0aW9ucywgJ29wdGlvbnMnLCAnb2JqZWN0Jyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzaG91bGQgbmV2ZXIgZ2V0IHJlYWNoZWRcbiAgfVxufVxuLyoqXG4gKiBFbmZvcmNlcyB0aGF0IHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFjayBmdW5jdGlvbi4gVGhyb3dzIFR5cGVFcnJvciBpZiBub3QuXG4gKiBAcGFyYW0geyp9IGNiIHBvc3NpYmxlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cblxuXG5mdW5jdGlvbiBtYXliZUNhbGxiYWNrKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2I7XG4gIH1cblxuICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKGBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uIFJlY2VpdmVkICR7Y2J9YCk7XG4gIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX0NBTExCQUNLJztcbiAgdGhyb3cgZXJyO1xufVxuLyoqXG4gKiByZXR1cm5zIHJhbmRvbWx5IGdlbmVyYXRlZCBjaGFyYWN0ZXJzIG9mIGdpdmVuIGxlbmd0aCAxLTE2XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAxIC0gMTZcbiAqIEBwYXJhbSB7c3RyaW5nfSBbX2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgb2YgdGhlIHN0cmluZyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb21DaGFyYWN0ZXJzKGxlbmd0aCwgX2VuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIC8vIEZJWE1FOiB1c2UgdGhlIGVuY29kaW5nIHNwZWNpZmllZCFcbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSArICcwMDAwMDAwMDAwMDAwMDAwMCcpLnNsaWNlKDIsIGxlbmd0aCArIDIpO1xufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3IoY29kZSwgbWVzc2FnZSwgZXJybm8sIHN5c2NhbGwsIHBhdGgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX0sICR7c3lzY2FsbH0gJyR7cGF0aH0nYCk7XG4gIGVycm9yLmVycm5vID0gZXJybm87XG4gIGVycm9yLnN5c2NhbGwgPSBzeXNjYWxsO1xuICBlcnJvci5jb2RlID0gY29kZTtcbiAgZXJyb3IucGF0aCA9IHBhdGg7XG4gIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHdoYXQgd2UncmUgZW5jb2RpbmcgdG9cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciBUaS5CdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IG5vZGUtY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihlbmNvZGluZywgdGlCdWZmZXIpIHtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgY2FzZSBudWxsOlxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlJ3JlIGFsd2F5cyByZWFkaW5nIGEgZmlsZSBpbnRvIGEgVGkuQnVmZmVyXG4gICAgICAvLyBXcmFwcGluZyBUaS5CdWZmZXIgaXMgc3VwZXItc2xvdyBhbmQgc2hvdWxkIHJlYWxseSBvbmx5IGJlIGlmIHdlJ3JlIGdvaW5nIHRvIHdyaXRlIHRvIGl0XG4gICAgICAvLyBHbyB0aGUgZmFzdGVyIHBhdGggYnkgY29udmVydGluZyB0byBBcnJheUJ1ZmZlciBhbmQgd3JhcHBpbmcgdGhhdFxuICAgICAgLy8gVE9ETzogRXhwbGljaXRseSByZWxlYXNlIHRoZSBibG9iIGFmdGVyIGNvbnZlcnNpb24/XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGlCdWZmZXIudG9CbG9iKCkudG9BcnJheUJ1ZmZlcigpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBoZXJlJyB3ZXJlIGNvbnZlcnRpbmcgdG8gYSBzdHJpbmcgYmFzZWQgb24gZW5jb2RpbmcuIEludGVybmFsbHkgb3VyIGZhc3RlciBCdWZmZXIgaW1wbCBzdGlsbCBkZWxlZ2F0ZXMgdG8gVGkuQnVmZmVyIGluIG1vc3QgY2FzZXNcbiAgICAgIC8vIHNvIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBtdWNoIGJlbmVmaXQgZnJvbSBjb252ZXJ0aW5nIHRvIEFycmF5QnVmZmVyIGZpcnN0XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20odGlCdWZmZXIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybiB7VGkuRmlsZXN5c3RlbS5GaWxlfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCkge1xuICAvLyBUaGlzIGlzIGEgaGFjayB0aGF0IGlzIGxpa2VseSB0byB3b3JrIGluIG1vc3QgY2FzZXM/XG4gIC8vIEJhc2ljYWxseSBhc3N1bWVzIEJ1ZmZlciBpcyBob2xkaW5nIGEgdXRmLTggc3RyaW5nIGZpbGVuYW1lL3BhdGhcbiAgLy8gTm9kZSBqdXN0IGNvcGllcyB0aGUgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyIGFzLWlzIG9uIHRoZSBuYXRpdmUgc2lkZSBhbmQgYWRkcyBhIG51bGwgdGVybWluYXRvclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgcGF0aCA9IHBhdGgudG9TdHJpbmcoKTsgLy8gYXNzdW1lcyB1dGYtOCBzdHJpbmdcbiAgfSAvLyBGSVhNRTogSGFuZGxlIFVSTHMhIFdlIGRvbid0IGhhdmUgYW4gVVJMIHNoaW0geWV0LCBzbyBubyB3YXkgdG8gaGFuZGxlIHRob3NlIHlldFxuXG5cbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICByZXR1cm4gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHBhdGgpO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVCdWZmZXJDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gb3JpZ2luYWwgQnVmZmVyIGJlaW5nIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCB3aXRoaW4gQnVmZmVyIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlblxuICogQHBhcmFtIHt3cml0ZUJ1ZmZlckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgcG9zaXRpb24gfHwgbGVuZ3RoIHx8IG9mZnNldCk7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgfSAvLyBvayBub3cgd2hhdD9cblxuXG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpOyAvLyBNYWtlIHVzZSBvZiB0aGUgYnVmZmVyIHNsaWNlIHRoYXQncyBzcGVjaWZpZWQgYnkgb2Zmc2V0L2xlbmd0aFxuXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cblxuICB3cml0ZVRpRmlsZVN0cmVhbSh0aUZpbGVTdHJlYW0sIGJ1ZmZlciwgKGVyciwgYnl0ZXNQcm9jZXNzZWQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzUHJvY2Vzc2VkLCBidWZmZXIpO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgY29udGVudHMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldF0gb2Zmc2V0IHdpdGhpbiBCdWZmZXIgdG8gd3JpdGVcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aF0gbGVuZ3RoIG9mIGJ5dGVzIHRvIHdyaXRlIGlmIEJ1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyU3luYyhmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuXG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpOyAvLyBNYWtlIHVzZSBvZiB0aGUgYnVmZmVyIHNsaWNlIHRoYXQncyBzcGVjaWZpZWQgYnkgb2Zmc2V0L2xlbmd0aFxuXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cblxuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVTdHJpbmdDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gb3JpZ2luYWwgc3RyaW5nIGJlaW5nIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7d3JpdGVTdHJpbmdDYWxsYmFja30gW2NhbGxiYWNrXSBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmcoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgZW5jb2RpbmcgfHwgcG9zaXRpb24pOyAvLyBwb3NpdGlvbiBjb3VsZCBiZTogbnVtYmVyLCBmdW5jdGlvbiAoY2FsbGJhY2spXG5cbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICBwb3NpdGlvbiA9IG51bGw7XG4gIH0gLy8gZW5jb2RpbmcgY291bGQgYmU6IGZ1bmN0aW9uIChjYWxsYmFjaykgb3Igc3RyaW5nXG5cblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmluZyArPSAnJzsgLy8gY29lcmNlIHRvIHN0cmluZ1xuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpOyAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cbiAgd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIChlcnIsIGJ5dGVzUHJvY2Vzc2VkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBieXRlc1Byb2Nlc3NlZCwgc3RyaW5nKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdTeW5jKGZkLCBzdHJpbmcsIHBvc2l0aW9uLCBlbmNvZGluZykge1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcbiAgc3RyaW5nICs9ICcnOyAvLyBjb2VyY2UgdG8gc3RyaW5nXG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZyk7IC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcblxuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuXG5mdW5jdGlvbiBTdHJlYW0oX29wdHMpIHtcbiAgLy8gRklYTUU6IENhbid0IGNhbGwgRXZlbnRFbWl0dGVyIGFzIGEgZnVuY3Rpb24hXG4gIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDsgLy8gRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0cyk7XG4gIC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzP1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFdmVudEVtaXR0ZXIpOyAvLyBVc2UgdXRpbC5pbmhlcml0cz9cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcbiAgfSAvLyBUT0RPOiByZWFkYWJsZVN0YXRlP1xuXG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChfbikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBub3QgaW1wbGVtZW50ZWQ6IF9yZWFkKCknKTtcbn07XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgY29uc3QgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIGlmICghaXNEdXBsZXggJiYgISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gICAgfVxuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIH1cblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBUT0RPOiBQcm92aWRlIG1vcmUgdGhhbiBhbiBlbXB0eSBjbGFzcyFcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlOyAvLyB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTsgLy8gQ29weSBXcml0YWJsZSBtZXRob2RzIHRvIER1cGxleCAoYmFzaWNhbGx5IHRoZSBvZGQgZG91YmxlLWluaGVyaXRhbmNlKVxuXG5jb25zdCB3cml0YWJsZU1ldGhvZHMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdyaXRhYmxlTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBtZXRob2QgPSB3cml0YWJsZU1ldGhvZHM7XG5cbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIHtcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICB9XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzIVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gICAgfVxuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgLy8gdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcblxufVxuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07IC8vIGxlZ2FjeSBjb21wYXRcblxuU3RyZWFtLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcblN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlO1xuU3RyZWFtLldyaXRhYmxlID0gV3JpdGFibGU7XG5TdHJlYW0uRHVwbGV4ID0gRHVwbGV4OyAvLyBTdHJlYW0uUGFzc1Rocm91Z2ggPSBQYXNzVGhyb3VnaDtcblxuLy8gTG9hZCBhbGwgdGhlIG5vZGUgY29tcGF0aWJsZSBjb3JlIG1vZHVsZXNcbnJlZ2lzdGVyKCdwYXRoJywgcGF0aCk7XG5yZWdpc3Rlcignb3MnLCBPUyk7XG5yZWdpc3RlcigndHR5JywgdHR5KTtcbnJlZ2lzdGVyKCd1dGlsJywgdXRpbCk7XG5yZWdpc3RlcignYXNzZXJ0JywgYXNzZXJ0KTtcbnJlZ2lzdGVyKCdldmVudHMnLCBFdmVudEVtaXR0ZXIpO1xucmVnaXN0ZXIoJ2J1ZmZlcicsIEJ1ZmZlck1vZHVsZSk7XG5yZWdpc3Rlcignc3RyaW5nX2RlY29kZXInLCBTdHJpbmdEZWNvZGVyJDEpO1xucmVnaXN0ZXIoJ2ZzJywgZnMpO1xucmVnaXN0ZXIoJ3N0cmVhbScsIFN0cmVhbSk7IC8vIFJlZ2lzdGVyIHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlciBhcyBnbG9iYWxcblxuZ2xvYmFsLkJ1ZmZlciA9IEJ1ZmZlck1vZHVsZS5CdWZmZXI7XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIERlc2NyaXB0aW9uOlxuICogVGhpcyBzY3JpcHQgbG9hZHMgYWxsIEphdmFTY3JpcHQgZmlsZXMgZW5kaW5nIHdpdGggdGhlIG5hbWUgXCIqLmJvb3RzdHJhcC5qc1wiIGFuZCB0aGVuIGV4ZWN1dGVzIHRoZW0uXG4gKiBUaGUgbWFpbiBpbnRlbnRpb24gb2YgdGhpcyBmZWF0dXJlIGlzIHRvIGFsbG93IEphdmFTY3JpcHQgZmlsZXMgdG8ga2ljay1vZmYgZnVuY3Rpb25hbGl0eSBvclxuICogZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIgYmVmb3JlIHRoZSBcImFwcC5qc1wiIGdldHMgbG9hZGVkLiBUaGlzIGZlYXR1cmUgaXMgdGhlIENvbW1vbkpTXG4gKiBlcXVpdmFsZW50IHRvIFRpdGFuaXVtJ3MgQW5kcm9pZCBtb2R1bGUgb25BcHBDcmVhdGUoKSBvciBpT1MgbW9kdWxlIGxvYWQoKSBmZWF0dXJlcy5cbiAqXG4gKiBVc2UtQ2FzZXM6XG4gKiAtIEF1dG9tYXRpY2FsbHkga2ljay1vZmYgYW5hbHl0aWNzIGZ1bmN0aW9uYWxpdHkgb24gYXBwIHN0YXJ0dXAuXG4gKiAtIEVuc3VyZSBcIkdvb2dsZSBQbGF5IFNlcnZpY2VzXCIgaXMgaW5zdGFsbGVkL3VwZGF0ZWQgb24gYXBwIHN0YXJ0dXAgb24gQW5kcm9pZC5cbiAqL1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGJvb3RzdHJhcHMgZnJvbSBhIFwiYm9vdHN0cmFwLmpzb25cIiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGFwcCBidWlsZCBzeXN0ZW0uXG4gKiBUaGlzIGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIGlzIHRoZSBmYXN0ZXN0IG1ldGhvZCBvZiBhY3F1aXJpbmcgYm9vc3RyYXBzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBUaGlzIEpTT04gZmlsZSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoaXMgc2NyaXB0LlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGlmIGJvb3RzdHJhcHMgd2VyZSBzdWNjZXNzZnVsbHkgbG9hZGVkIGZyb20gSlNPTi5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgSlNPTiBmaWxlIHdhcyBmb3VuZCwgYnV0IG5vIGJvb3RzdHJhcHMgd2VyZSBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogUmV0dXJucyBudWxsIGlmIEpTT04gZmlsZSB3YXMgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tSnNvbigpIHtcbiAgY29uc3QgSlNPTl9GSUxFX05BTUUgPSAnYm9vdHN0cmFwLmpzb24nO1xuXG4gIHRyeSB7XG4gICAgY29uc3QganNvbkZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksIGB0aS5pbnRlcm5hbC8ke0pTT05fRklMRV9OQU1FfWApO1xuXG4gICAgaWYgKGpzb25GaWxlLmV4aXN0cygpKSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5zY3JpcHRzKSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2NyaXB0cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoYEZhaWxlZCB0byByZWFkIFwiJHtKU09OX0ZJTEVfTkFNRX1cIi4gUmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgdGhlIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBhbGwgXCIqLmJvb3RzdHJhcC5qc1wiIGZpbGVzLlxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGZvciBlYWNoIGJvb3RzdHJhcCBmb3VuZCBpbiB0aGUgc2VhcmNoLlxuICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBubyBib290c3RyYXAgZmlsZXMgd2VyZSBmb3VuZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKSB7XG4gIGNvbnN0IHJlc291cmNlRGlyZWN0b3J5ID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5KTtcbiAgY29uc3QgcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoID0gcmVzb3VyY2VEaXJlY3RvcnkubmF0aXZlUGF0aC5sZW5ndGg7XG4gIGNvbnN0IGJvb3RzdHJhcFNjcmlwdHMgPSBbXTtcblxuICBmdW5jdGlvbiBsb2FkRnJvbShmaWxlKSB7XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIGlmIChmaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdG9yeS4gUmVjdXJzaXZlbHkgbG9vayBmb3IgYm9vdHN0cmFwIGZpbGVzIHVuZGVyIGl0LlxuICAgICAgICBjb25zdCBmaWxlTmFtZUFycmF5ID0gZmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG5cbiAgICAgICAgaWYgKGZpbGVOYW1lQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZmlsZU5hbWVBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGxvYWRGcm9tKFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShmaWxlLm5hdGl2ZVBhdGgsIGZpbGVOYW1lQXJyYXlbaW5kZXhdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGUubmFtZS5zZWFyY2goLy5ib290c3RyYXAuanMkLykgPj0gMCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgYm9vdHN0cmFwIGZpbGUuXG4gICAgICAgIC8vIENvbnZlcnQgaXRzIHBhdGggdG8gc29tZXRoaW5nIGxvYWRhYmxlIHZpYSByZXF1aXJlKCkgYW5kIGFkZCBpdCB0byB0aGUgYXJyYXkuXG4gICAgICAgIGxldCBib290c3RyYXBQYXRoID0gZmlsZS5uYXRpdmVQYXRoO1xuICAgICAgICBib290c3RyYXBQYXRoID0gYm9vdHN0cmFwUGF0aC5zdWJzdHIocmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoLCBib290c3RyYXBQYXRoLmxlbmd0aCAtIHJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCAtICcuanMnLmxlbmd0aCk7XG4gICAgICAgIGJvb3RzdHJhcFNjcmlwdHMucHVzaChib290c3RyYXBQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkRnJvbShyZXNvdXJjZURpcmVjdG9yeSk7XG4gIHJldHVybiBib290c3RyYXBTY3JpcHRzO1xufVxuLyoqXG4gKiBOb24tYmxvY2tpbmcgZnVuY3Rpb24gd2hpY2ggbG9hZHMgYW5kIGV4ZWN1dGVzIGFsbCBib290c3RyYXAgc2NyaXB0cyBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmluaXNoZWQgQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbmNlIGFsbCBib290c3RyYXBzIGhhdmUgZmluaXNoZWQgZXhlY3V0aW5nLiBDYW5ub3QgYmUgbnVsbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRBc3luYyhmaW5pc2hlZCkge1xuICAvLyBBY3F1aXJlIGFuIGFycmF5IG9mIGFsbCBib290c3RyYXAgc2NyaXB0cyBpbmNsdWRlZCB3aXRoIHRoZSBhcHAuXG4gIC8vIC0gRm9yIGJlc3QgcGVyZm9ybWFuY2UsIGF0dGVtcHQgdG8gZmV0Y2ggc2NyaXB0cyB2aWEgYW4gb3B0aW9uYWwgSlNPTiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGJ1aWxkIHN5c3RlbS5cbiAgLy8gLSBJZiBKU09OIGZpbGUgbm90IGZvdW5kICh3aWxsIHJldHVybiBudWxsKSwgdGhlbiBzZWFyY2ggXCJSZXNvdXJjZXNcIiBkaXJlY3RvcnkgZm9yIGJvb3RzdHJhcCBmaWxlcy5cbiAgbGV0IGJvb3RzdHJhcFNjcmlwdHMgPSBmZXRjaFNjcmlwdHNGcm9tSnNvbigpO1xuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cykge1xuICAgIGJvb3RzdHJhcFNjcmlwdHMgPSBmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5KCk7XG4gIH0gLy8gRG8gbm90IGNvbnRpbnVlIGlmIG5vIGJvb3RzdHJhcHMgd2VyZSBmb3VuZC5cblxuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cyB8fCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCA8PSAwKSB7XG4gICAgZmluaXNoZWQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gU29ydCB0aGUgYm9vdHN0cmFwcyBzbyB0aGF0IHRoZXknbGwgYmUgbG9hZGVkIGluIGEgY29uc2lzdGVudCBvcmRlciBiZXR3ZWVuIHBsYXRmb3Jtcy5cblxuXG4gIGJvb3RzdHJhcFNjcmlwdHMuc29ydCgpOyAvLyBMb2FkcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgZm91bmQuXG5cbiAgZnVuY3Rpb24gbG9hZEJvb3RzdHJhcFNjcmlwdHMoZmluaXNoZWQpIHtcbiAgICBsZXQgYm9vdHN0cmFwSW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gZG9Mb2FkKCkge1xuICAgICAgLy8gQXR0ZW1wdCB0byBsb2FkIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgICAgIHdoaWxlIChib290c3RyYXBJbmRleCA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIExvYWQgdGhlIG5leHQgYm9vdHN0cmFwLlxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGJvb3RzdHJhcFNjcmlwdHNbYm9vdHN0cmFwSW5kZXhdO1xuXG4gICAgICAgIGNvbnN0IGJvb3RzdHJhcCA9IHJlcXVpcmUoZmlsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgIC8vIEludm9rZSB0aGUgYm9vdHN0cmFwJ3MgZXhlY3V0ZSgpIG1ldGhvZCBpZiBpdCBoYXMgb25lLiAoVGhpcyBpcyBvcHRpb25hbC4pXG4gICAgICAgIC8vIFdlIG11c3Qgd2FpdCBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYmVmb3JlIGxvYWRpbmcgdGhlIG5leHQgc2NyaXB0LlxuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGV4cGVjdGVkIHRvIGJlIHVzZWQgdG8gZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIuXG5cblxuICAgICAgICBpZiAoYm9vdHN0cmFwLmV4ZWN1dGUpIHtcbiAgICAgICAgICBib290c3RyYXAuZXhlY3V0ZShvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gV2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IGJvb3RzdHJhcC4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cblxuXG4gICAgICAgIGJvb3RzdHJhcEluZGV4Kys7XG4gICAgICB9IC8vIEludm9rZSBnaXZlbiBjYWxsYmFjayB0byBpbmZvcm0gY2FsbGVyIHRoYXQgYWxsIGxvYWRpbmcgaXMgZG9uZS5cblxuXG4gICAgICBmaW5pc2hlZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQm9vdHN0cmFwRXhlY3V0aW9uRmluaXNoZWQoKSB7XG4gICAgICAvLyBMYXN0IGJvb3RzdHJhcCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uLiBUaW1lIHRvIGxvYWQgdGhlIG5leHQgb25lLlxuICAgICAgLy8gTm90ZTogQWRkIGEgdGlueSBkZWxheSBzbyB3aGF0ZXZlciBVSSB0aGUgbGFzdCBib290c3RyYXAgbG9hZGVkIGhhcyB0aW1lIHRvIGNsb3NlLlxuICAgICAgYm9vdHN0cmFwSW5kZXgrKztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZG9Mb2FkKCksIDEpO1xuICAgIH1cblxuICAgIGRvTG9hZCgpO1xuICB9IC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gSW5mb3JtIGNhbGxlciBieSBpbnZva2luZyB0aGUgY2FsbGJhY2sgZ2l2ZW4gdG8gbG9hZEFzeW5jKCkuXG5cblxuICBsb2FkQm9vdHN0cmFwU2NyaXB0cyhmaW5pc2hlZCk7XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIFRoaXMgc2NyaXB0IGlzIGxvYWRlZCBvbiBhcHAgc3RhcnR1cCBvbiBhbGwgcGxhdGZvcm1zLiBJdCBpcyB1c2VkIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFByb3ZpZGUgY29uc2lzdGVudCBzdGFydHVwIGJlaGF2aW9yIGJldHdlZW4gcGxhdGZvcm1zLCBzdWNoIGFzIGxvZ2dpbmcgVGl0YW5pdW0gdmVyc2lvbi5cbiAqIC0gTG9hZCBUaXRhbml1bSdzIGNvcmUgSmF2YVNjcmlwdCBleHRlbnNpb25zIHNoYXJlZCBieSBhbGwgcGxhdGZvcm1zLlxuICogLSBQcm92aWRlIFwiKi5ib290c3RyYXAuanNcIiBzY3JpcHQgc3VwcG9ydC4gKFNpbWlsYXIgdG8gbmF0aXZlIG1vZHVsZSBvbkFwcENyZWF0ZSgpL2xvYWQoKSBzdXBwb3J0LilcbiAqIC0gTG9hZCB0aGUgYXBwIGRldmVsb3BlcidzIG1haW4gXCJhcHAuanNcIiBzY3JpcHQgYWZ0ZXIgZG9pbmcgYWxsIG9mIHRoZSBhYm92ZS5cbiAqL1xuXG5UaS5BUEkuaW5mbyhgJHtUaS5BcHAubmFtZX0gJHtUaS5BcHAudmVyc2lvbn0gKFBvd2VyZWQgYnkgVGl0YW5pdW0gJHtcIjEwLjEuMVwifS4ke1wiMjQ0OGNmYTY3MVwifSlgKTsgLy8gTG9hZCBKUyBsYW5ndWFnZSBwb2x5ZmlsbHNcbmxvYWRBc3luYyhmdW5jdGlvbiAoKSB7XG4gIC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gV2UgY2FuIG5vdyBwcm9jZWVkIHRvIHJ1biB0aGUgbWFpbiBcImFwcC5qc1wiIHNjcmlwdC5cbiAgcmVxdWlyZSgnLi9hcHAnKTsgLy8gVGhpcyBldmVudCBpcyB0byBiZSBmaXJlZCBhZnRlciBcImFwcC5qc1wiIGV4ZWN1dGlvbi4gUmVhc29uczpcbiAgLy8gLSBBbGxvdyBzeXN0ZW0gdG8gcXVldWUgc3RhcnR1cCByZWxhdGVkIGV2ZW50cyB1bnRpbCBcImFwcC5qc1wiIGhhcyBoYWQgYSBjaGFuY2UgdG8gYWRkIGxpc3RlbmVycy5cbiAgLy8gLSBGb3IgQWxsb3kgYXBwcywgd2Ugbm93IGtub3cgdGhhdCBBbGxveSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaXRzIGdsb2JhbHMgd2VyZSBhZGRlZC5cblxuXG4gIFRpLkFwcC5maXJlRXZlbnQoJ3N0YXJ0ZWQnKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiJDOlxcUHJvZ3JhbURhdGFcXFRpdGFuaXVtXFxtb2JpbGVzZGtcXHdpbjMyXFwxMC4xLjEuR0FcXGNvbW1vblxcUmVzb3VyY2VzXFxhbmRyb2lkIn0=
